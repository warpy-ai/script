mod compiler;
mod vm;

use crate::compiler::Codegen;
use crate::compiler::borrow_ck::BorrowChecker;
use crate::vm::VM;
use swc_common::{FileName, SourceMap, sync::Lrc};
use swc_ecma_parser::{Parser, StringInput, Syntax, lexer::Lexer};

#[cfg(test)]
mod tests;

fn main() {
    let cm: Lrc<SourceMap> = Default::default();

    // DEMO: Closure Capturing - Solving the Stack Frame Paradox
    //
    // The arrow function captures `data` from the outer scope.
    // When setTimeout fires (after 100ms), the outer scope is long gone,
    // but the closure still has access to `data` because it was "lifted"
    // from the stack to the heap.
    let code = "
let data = { message: 'Hello from the past!' };

console.log('Setting up async callback...');

setTimeout(() => {
    console.log(data.message);
}, 100);

console.log('Main script done. Callback will fire soon...');
";

    let fm = cm.new_source_file(FileName::Custom("input.js".into()).into(), code);
    let lexer = Lexer::new(
        Syntax::Es(Default::default()),
        Default::default(),
        StringInput::from(&*fm),
        None,
    );

    let mut parser = Parser::new_from(lexer);
    let module = parser.parse_module().expect("Parse failed");

    // 1. RUN BORROW CHECKER
    let mut bc = BorrowChecker::new();
    for item in &module.body {
        if let Some(stmt) = item.as_stmt()
            && let Err(e) = bc.analyze_stmt(stmt)
        {
            eprintln!("BORROW CHECK ERROR: {}", e);
            return;
        }
    }

    // 2. Codegen (Generate Bytecode)
    let mut cg = Codegen::new();
    let bytecode = cg.generate(&module);

    println!("Generated Bytecode:");
    for (i, op) in bytecode.iter().enumerate() {
        println!("  {:04}: {:?}", i, op);
    }

    // 3. Execution (VM)
    let mut my_vm = VM::new();

    println!("\nStarting VM Execution:");
    my_vm.load_program(bytecode);
    my_vm.run_event_loop();
}
