// Expression Parsers - Recursive descent expression parsing

let PRECEDENCE = {
    "||": 1,
    "&&": 2,
    "|": 3,
    "^": 4,
    "&": 5,
    "==": 6,
    "!=": 6,
    "===": 6,
    "!==": 6,
    "<": 7,
    ">": 7,
    "<=": 7,
    ">=": 7,
    "in": 7,
    "instanceof": 7,
    "<<": 8,
    ">>": 8,
    ">>>": 8,
    "+": 9,
    "-": 9,
    "*": 10,
    "/": 10,
    "%": 10,
    "**": 11
};

function parseExpression(parser) {
    return parseAssignment(parser);
}

function parseAssignment(parser) {
    let left = parseConditional(parser);
    if (left == null) return null;
    let op = peekValue(parser);
    if (op == "=" || op == "+=" || op == "-=" || op == "*=" || op == "/=" || op == "%=" || op == "**=") {
        parserAdvance(parser);
        let right = parseAssignment(parser);
        return {
            type: "AssignmentExpression",
            operator: op,
            left: left,
            right: right
        };
    }
    return left;
}

function parseConditional(parser) {
    let test = parseBinary(parser, 0);
    if (test == null) return null;
    if (match(parser, "OPERATOR", "??")) {
        let consequent = parseAssignment(parser);
        expect(parser, "OPERATOR", ":");
        let alternate = parseAssignment(parser);
        return {
            type: "ConditionalExpression",
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }
    if (match(parser, "OPERATOR", "?")) {
        let consequent = parseAssignment(parser);
        expect(parser, "OPERATOR", ":");
        let alternate = parseAssignment(parser);
        return {
            type: "ConditionalExpression",
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }
    return test;
}

function parseBinary(parser, minPrec) {
    let left = parseUnary(parser);
    if (left == null) return null;
    while (true) {
        let op = peekValue(parser);
        let prec = PRECEDENCE[op];
        if (prec == null || prec < minPrec) break;
        parserAdvance(parser);
        let nextPrec = prec + 1;
        let right = parseBinary(parser, nextPrec);
        if (right == null) return left;
        left = {
            type: "BinaryExpression",
            operator: op,
            left: left,
            right: right
        };
    }
    return left;
}

function parseUnary(parser) {
    let tok = parserPeek(parser);
    if (tok == null) return parsePostfix(parser);
    let op = tok.value;
    let isOperator = tok.type == "OPERATOR";
    let isKeyword = tok.type == "KEYWORD";
    if ((isOperator && (op == "!" || op == "-" || op == "+" || op == "~")) ||
        (isKeyword && (op == "typeof" || op == "void" || op == "delete"))) {
        parserAdvance(parser);
        let arg = parseUnary(parser);
        return {
            type: "UnaryExpression",
            operator: op,
            argument: arg,
            prefix: true
        };
    }
    return parsePostfix(parser);
}

function parsePostfix(parser) {
    let expr = parsePrimary(parser);
    if (expr == null) return null;
    while (true) {
        if (match(parser, "DELIMITER", ".")) {
            let propTok = parserPeek(parser);
            if (propTok != null && (propTok.type == "IDENTIFIER" || propTok.type == "KEYWORD")) {
                parserAdvance(parser);
                expr = {
                    type: "MemberExpression",
                    object: expr,
                    property: { type: "Identifier", name: propTok.value },
                    computed: false,
                    optional: false
                };
            } else {
                break;
            }
        }
        else if (match(parser, "DELIMITER", "[")) {
            let index = parseExpression(parser);
            expect(parser, "DELIMITER", "]");
            expr = {
                type: "MemberExpression",
                object: expr,
                property: index,
                computed: true,
                optional: false
            };
        }
        else if (match(parser, "DELIMITER", "(")) {
            let args = [];
            while (!match(parser, "DELIMITER", ")")) {
                if (peekType(parser) == "EOF") break;
                let arg = parseExpression(parser);
                if (arg != null) {
                    args.push(arg);
                }
                if (!match(parser, "DELIMITER", ",")) {
                    match(parser, "DELIMITER", ")");
                    break;
                }
            }
            expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
            };
        }
        else if (match(parser, "OPERATOR", "++")) {
            expr = {
                type: "UpdateExpression",
                operator: "++",
                argument: expr,
                prefix: false
            };
        }
        else if (match(parser, "OPERATOR", "--")) {
            expr = {
                type: "UpdateExpression",
                operator: "--",
                argument: expr,
                prefix: false
            };
        }
        else {
            break;
        }
    }
    return expr;
}

function parsePrimary(parser) {
    let tok = parserPeek(parser);
    if (tok == null) return null;

    if (tok.type == "NUMBER") {
        parserAdvance(parser);
        return {
            type: "Literal",
            value: parseFloat(tok.value),
            raw: tok.value
        };
    }

    if (tok.type == "STRING") {
        parserAdvance(parser);
        return {
            type: "Literal",
            value: tok.value,
            raw: "\"" + tok.value + "\""
        };
    }

    if (tok.type == "KEYWORD") {
        if (tok.value == "true") {
            parserAdvance(parser);
            return { type: "Literal", value: true, raw: "true" };
        }
        if (tok.value == "false") {
            parserAdvance(parser);
            return { type: "Literal", value: false, raw: "false" };
        }
        if (tok.value == "null") {
            parserAdvance(parser);
            return { type: "Literal", value: null, raw: "null" };
        }
        if (tok.value == "undefined") {
            parserAdvance(parser);
            return { type: "Identifier", name: "undefined" };
        }
        if (tok.value == "NaN") {
            parserAdvance(parser);
            return { type: "Identifier", name: "NaN" };
        }
        if (tok.value == "this") {
            parserAdvance(parser);
            return { type: "ThisExpression" };
        }
        if (tok.value == "function") {
            return parseFunctionExpression(parser);
        }
        if (tok.value == "async") {
            let next = parser.tokens[parser.pos + 1];
            if (next != null && (next.type == "KEYWORD" && next.value == "function")) {
                return parseFunctionExpression(parser, true);
            }
            if (next != null && next.type == "DELIMITER" && next.value == "(") {
                return parseAsyncExpression(parser);
            }
            if (next != null && next.type == "IDENTIFIER") {
                let next2 = parser.tokens[parser.pos + 2];
                if (next2 != null && next2.type == "OPERATOR" && next2.value == "=>") {
                    return parseArrowFunction(parser, true);
                }
            }
        }
    }

    if (tok.type == "IDENTIFIER") {
        parserAdvance(parser);
        return { type: "Identifier", name: tok.value };
    }

    if (match(parser, "OPERATOR", "(")) {
        if (peekType(parser) == "IDENTIFIER" || peekType(parser) == "NUMBER") {
            let next = parser.tokens[parser.pos];
            if (next != null && next.value == ":") {
                let param = {
                    name: tok.value,
                    typeAnnotation: tryParseTypeAnnotation(parser)
                };
                expect(parser, "OPERATOR", ")");
                expect(parser, "OPERATOR", "=>");
                let body = parseArrowBody(parser);
                return {
                    type: "ArrowFunctionExpression",
                    params: [param],
                    returnType: null,
                    body: body,
                    isAsync: false
                };
            }
        }
        let expr = parseExpression(parser);
        expect(parser, "OPERATOR", ")");
        return expr;
    }

    if (match(parser, "OPERATOR", "=>")) {
        return parseArrowFunction(parser, false);
    }

    if (match(parser, "DELIMITER", "[")) {
        return parseArrayExpression(parser);
    }

    if (match(parser, "DELIMITER", "{")) {
        return parseObjectExpression(parser);
    }

    if (match(parser, "KEYWORD", "new")) {
        return parseNewExpression(parser);
    }

    if (match(parser, "OPERATOR", "?")) {
        let expr = parseExpression(parser);
        expect(parser, "OPERATOR", ".");
        return {
            type: "ChainExpression",
            expression: expr
        };
    }

    return null;
}

function parseFunctionExpression(parser, forceAsync = false) {
    let isAsync = forceAsync;
    if (!isAsync && match(parser, "KEYWORD", "async")) {
        isAsync = true;
    }
    parserAdvance(parser);
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let genericParams = null;
    let lifetimeParams = null;
    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "<") {
        let parsed = parseGenericParams(parser);
        genericParams = parsed.typeParams;
        lifetimeParams = parsed.lifetimeParams;
    }
    let params = parseTypedParams(parser);
    let returnType = tryParseTypeAnnotation(parser);
    let body = parseBlockStatement(parser);
    return {
        type: "FunctionExpression",
        name: name,
        genericParams: genericParams,
        lifetimeParams: lifetimeParams,
        params: params,
        returnType: returnType,
        body: body,
        isAsync: isAsync
    };
}

function parseArrowFunction(parser, isAsync) {
    let params = [];
    if (match(parser, "DELIMITER", "(")) {
        while (!match(parser, "DELIMITER", ")")) {
            if (isTypedParam(parser)) {
                params.push(parseTypedParam(parser));
            } else if (peekType(parser) == "IDENTIFIER") {
                params.push(peekValue(parser));
                parserAdvance(parser);
            }
            match(parser, "DELIMITER", ",");
        }
    } else if (peekType(parser) == "IDENTIFIER") {
        params.push(peekValue(parser));
        parserAdvance(parser);
    }
    let returnType = tryParseTypeAnnotation(parser);
    let body = parseArrowBody(parser);
    return {
        type: "ArrowFunctionExpression",
        params: params,
        returnType: returnType,
        body: body,
        isAsync: isAsync
    };
}

function parseAsyncExpression(parser) {
    let params = [];
    if (match(parser, "DELIMITER", "(")) {
        while (!match(parser, "DELIMITER", ")")) {
            if (isTypedParam(parser)) {
                params.push(parseTypedParam(parser));
            } else if (peekType(parser) == "IDENTIFIER") {
                params.push(peekValue(parser));
                parserAdvance(parser);
            }
            match(parser, "DELIMITER", ",");
        }
    }
    let returnType = tryParseTypeAnnotation(parser);
    expect(parser, "OPERATOR", "=>");
    let body = parseArrowBody(parser);
    return {
        type: "ArrowFunctionExpression",
        params: params,
        returnType: returnType,
        body: body,
        isAsync: true
    };
}

function parseArrowBody(parser) {
    if (peekType(parser) == "DELIMITER" && peekValue(parser) == "{") {
        return parseBlockStatement(parser);
    }
    return parseExpression(parser);
}

function parseArrayExpression(parser) {
    let elements = [];
    while (!match(parser, "DELIMITER", "]")) {
        if (match(parser, "OPERATOR", ",")) {
            elements.push(null);
        } else if (peekType(parser) == "OPERATOR" && peekValue(parser) == "...") {
            // Spread element: ...expr
            parserAdvance(parser);
            let arg = parseExpression(parser);
            elements.push({
                type: "SpreadElement",
                argument: arg
            });
            match(parser, "DELIMITER", ",");
        } else {
            let elem = parseExpression(parser);
            elements.push(elem);
            match(parser, "DELIMITER", ",");
        }
    }
    return {
        type: "ArrayExpression",
        elements: elements
    };
}

function parseObjectExpression(parser) {
    let properties = [];
    while (!match(parser, "DELIMITER", "}")) {
        // Check for spread: { ...obj }
        if (peekType(parser) == "OPERATOR" && peekValue(parser) == "...") {
            parserAdvance(parser);
            let arg = parseExpression(parser);
            properties.push({
                type: "SpreadElement",
                argument: arg
            });
            match(parser, "DELIMITER", ",");
            continue;
        }

        let key = null;
        let isShorthand = false;
        if (peekType(parser) == "STRING" || peekType(parser) == "NUMBER") {
            key = {
                type: "Literal",
                value: parseFloat(peekValue(parser)),
                raw: peekValue(parser)
            };
            parserAdvance(parser);
        } else if (peekType(parser) == "IDENTIFIER") {
            key = {
                type: "Identifier",
                name: peekValue(parser)
            };
            parserAdvance(parser);
            // Check for shorthand: { x } instead of { x: x }
            if (peekType(parser) == "DELIMITER" && (peekValue(parser) == "," || peekValue(parser) == "}")) {
                isShorthand = true;
                properties.push({
                    type: "ObjectProperty",
                    key: key,
                    value: key,
                    shorthand: true,
                    kind: "init"
                });
                match(parser, "DELIMITER", ",");
                continue;
            }
        }
        expect(parser, "DELIMITER", ":");
        let value = parseExpression(parser);
        properties.push({
            type: "ObjectProperty",
            key: key,
            value: value,
            shorthand: false,
            kind: "init"
        });
        match(parser, "DELIMITER", ",");
    }
    return {
        type: "ObjectExpression",
        properties: properties
    };
}

function parseNewExpression(parser) {
    let callee = parsePrimary(parser);
    if (callee == null) return null;
    let args = [];
    if (match(parser, "DELIMITER", "(")) {
        while (!match(parser, "DELIMITER", ")")) {
            let arg = parseExpression(parser);
            args.push(arg);
            match(parser, "DELIMITER", ",");
        }
    }
    return {
        type: "NewExpression",
        callee: callee,
        arguments: args
    };
}

console.log("Expression parsers loaded");
