// Statement Parsers - Parser state and statement parsing

function createParser(tokens) {
    return {
        tokens: tokens,
        pos: 0
    };
}

function parserPeek(parser) {
    if (parser.pos >= parser.tokens.length) {
        return null;
    }
    return parser.tokens[parser.pos];
}

function peekType(parser) {
    let tok = parserPeek(parser);
    if (tok == null) {
        return "EOF";
    }
    return tok.type;
}

function peekValue(parser) {
    let tok = parserPeek(parser);
    if (tok == null) {
        return "";
    }
    return tok.value;
}

function parserAdvance(parser) {
    let tok = parserPeek(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

function match(parser, type, value) {
    let tok = parserPeek(parser);
    if (tok != null && tok.type == type && (value == null || tok.value == value)) {
        parserAdvance(parser);
        return true;
    }
    return false;
}

function expect(parser, type, value) {
    let tok = parserPeek(parser);
    if (tok != null && tok.type == type && (value == null || tok.value == value)) {
        return parserAdvance(parser);
    }
    if (tok != null) {
        parserAdvance(parser);
    }
    return null;
}

function parseTypeAnnotation(parser) {
    let baseType = parseBaseType(parser);
    if (baseType == null) {
        return null;
    }

    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "|") {
        let unionTypes = [baseType];
        while (peekType(parser) == "OPERATOR" && peekValue(parser) == "|") {
            parserAdvance(parser);
            let nextType = parseBaseType(parser);
            if (nextType != null) {
                unionTypes.push(nextType);
            }
        }
        return {
            type: "TypeAnnotation",
            typeKind: "union",
            isArray: false,
            elementType: null,
            unionTypes: unionTypes,
            genericParams: null
        };
    }

    return baseType;
}

function parseBaseType(parser) {
    let tok = parserPeek(parser);

    if (tok != null && tok.type == "DELIMITER" && tok.value == "(") {
        parserAdvance(parser);
        let params = [];
        while (peekType(parser) != "DELIMITER" || peekValue(parser) != ")") {
            if (peekType(parser) == "EOF") break;
            let paramName = "";
            if (peekType(parser) == "IDENTIFIER") {
                paramName = peekValue(parser);
                parserAdvance(parser);
            }
            let paramType = null;
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
                parserAdvance(parser);
                paramType = parseTypeAnnotation(parser);
            }
            params.push({
                name: paramName,
                typeAnnotation: paramType
            });
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == ",") {
                parserAdvance(parser);
            }
        }
        expect(parser, "DELIMITER", ")");
        expect(parser, "OPERATOR", "=>");
        let returnType = parseTypeAnnotation(parser);
        return {
            type: "FunctionTypeAnnotation",
            params: params,
            returnType: returnType
        };
    }

    if (tok != null && tok.type == "DELIMITER" && tok.value == "{") {
        parserAdvance(parser);
        let members = [];
        let indexType = null;
        let indexValueType = null;
        while (peekType(parser) != "DELIMITER" || peekValue(parser) != "}") {
            if (peekType(parser) == "EOF") break;

            // Handle indexed type: [key: string]: valueType
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == "[") {
                parserAdvance(parser); // consume '['
                // Skip key name
                if (peekType(parser) == "IDENTIFIER") {
                    parserAdvance(parser);
                }
                // Expect ':'
                if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
                    parserAdvance(parser);
                    indexType = parseTypeAnnotation(parser);
                }
                // Expect ']'
                expect(parser, "DELIMITER", "]");
                // Expect ':'
                if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
                    parserAdvance(parser);
                    indexValueType = parseTypeAnnotation(parser);
                }
                // Skip optional semicolon or comma
                if (peekType(parser) == "DELIMITER" && (peekValue(parser) == ";" || peekValue(parser) == ",")) {
                    parserAdvance(parser);
                }
                continue;
            }

            let memberName = "";
            let optional = false;
            if (peekType(parser) == "IDENTIFIER" || peekType(parser) == "KEYWORD") {
                memberName = peekValue(parser);
                parserAdvance(parser);
            }
            if (peekType(parser) == "OPERATOR" && peekValue(parser) == "?") {
                optional = true;
                parserAdvance(parser);
            }
            let memberType = null;
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
                parserAdvance(parser);
                memberType = parseTypeAnnotation(parser);
            }
            members.push({
                name: memberName,
                optional: optional,
                typeAnnotation: memberType
            });
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == ",") {
                parserAdvance(parser);
            } else if (peekType(parser) == "DELIMITER" && peekValue(parser) == ";") {
                parserAdvance(parser);
            }
        }
        expect(parser, "DELIMITER", "}");
        return {
            type: "ObjectTypeAnnotation",
            members: members,
            indexType: indexType,
            indexValueType: indexValueType
        };
    }

    // Handle string literal types: "foo" | "bar"
    if (tok != null && tok.type == "STRING") {
        parserAdvance(parser);
        return {
            type: "TypeAnnotation",
            typeKind: "literal",
            literalValue: tok.value,
            isArray: false,
            elementType: null,
            unionTypes: null,
            genericParams: null
        };
    }

    if (tok == null || (tok.type != "KEYWORD" && tok.type != "IDENTIFIER")) {
        return null;
    }
    let typeKind = tok.value;
    parserAdvance(parser);

    let isArray = false;
    let elementType = null;
    let genericParams = null;
    let isGeneric = false;

    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "<") {
        parserAdvance(parser);
        genericParams = [];
        while (peekType(parser) != "OPERATOR" || peekValue(parser) != ">") {
            if (peekType(parser) == "EOF") break;
            let param = parseTypeAnnotation(parser);
            if (param != null) {
                genericParams.push(param);
                if (peekType(parser) == "DELIMITER" && peekValue(parser) == ",") {
                    parserAdvance(parser);
                }
            } else {
                break;
            }
        }
        expect(parser, "OPERATOR", ">");
        isGeneric = true;
    }

    if (peekType(parser) == "DELIMITER" && peekValue(parser) == "[") {
        parserAdvance(parser);
        expect(parser, "DELIMITER", "]");
        isArray = true;
        elementType = {
            type: "TypeAnnotation",
            typeKind: typeKind,
            isArray: false,
            elementType: null,
            unionTypes: null,
            genericParams: isGeneric ? genericParams : null
        };
    }

    return {
        type: "TypeAnnotation",
        typeKind: typeKind,
        isArray: isArray,
        elementType: elementType,
        unionTypes: null,
        genericParams: isGeneric && !isArray ? genericParams : null
    };
}

function tryParseTypeAnnotation(parser) {
    if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
        parserAdvance(parser);
        return parseTypeAnnotation(parser);
    }
    return null;
}

function isTypedParam(parser) {
    if (peekType(parser) == "IDENTIFIER") {
        let next = parser.tokens[parser.pos + 1];
        if (next != null && next.type == "DELIMITER" && next.value == ":") {
            return true;
        }
    }
    return false;
}

function parseTypedParam(parser) {
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let typeAnnotation = null;
    if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
        typeAnnotation = tryParseTypeAnnotation(parser);
    }
    return {
        name: name,
        typeAnnotation: typeAnnotation
    };
}

function parseTypedParams(parser) {
    let params = [];
    expect(parser, "DELIMITER", "(");
    while (!match(parser, "DELIMITER", ")")) {
        if (isTypedParam(parser)) {
            params.push(parseTypedParam(parser));
        } else {
            let name = peekValue(parser);
            params.push(name);
            parserAdvance(parser);
        }
        match(parser, "DELIMITER", ",");
    }
    return params;
}

function parseStatement(parser) {
    let tok = parserPeek(parser);
    if (tok == null) return null;

    if (tok.type == "KEYWORD") {
        if (tok.value == "let" || tok.value == "const" || tok.value == "var") {
            return parseVariableDeclaration(parser);
        }
        if (tok.value == "function") {
            return parseFunctionDeclaration(parser);
        }
        if (tok.value == "async") {
            let next = parser.tokens[parser.pos + 1];
            if (next != null && next.type == "KEYWORD" && next.value == "function") {
                parserAdvance(parser);
                return parseFunctionDeclaration(parser, true);
            }
            parserAdvance(parser);
            return parseExpressionStatement(parser);
        }
        if (tok.value == "class") {
            return parseClassDeclaration(parser);
        }
        if (tok.value == "if") {
            return parseIfStatement(parser);
        }
        if (tok.value == "while") {
            return parseWhileStatement(parser);
        }
        if (tok.value == "do") {
            return parseDoWhileStatement(parser);
        }
        if (tok.value == "for") {
            return parseForStatement(parser);
        }
        if (tok.value == "return") {
            return parseReturnStatement(parser);
        }
        if (tok.value == "throw") {
            return parseThrowStatement(parser);
        }
        if (tok.value == "try") {
            return parseTryStatement(parser);
        }
        if (tok.value == "break") {
            return parseBreakStatement(parser);
        }
        if (tok.value == "continue") {
            return parseContinueStatement(parser);
        }
        if (tok.value == "import") {
            return parseImportDeclaration(parser);
        }
        if (tok.value == "export") {
            return parseExportDeclaration(parser);
        }
        if (tok.value == "require") {
            return parseRequireStatement(parser);
        }
        if (tok.value == "type") {
            return parseTypeAliasDeclaration(parser);
        }
        if (tok.value == "interface") {
            return parseInterfaceDeclaration(parser);
        }
        if (tok.value == "enum") {
            return parseEnumDeclaration(parser);
        }
    }

    if (tok.type == "DELIMITER" && tok.value == "{") {
        return parseBlockStatement(parser);
    }

    return parseExpressionStatement(parser);
}

function parseBlockStatement(parser) {
    expect(parser, "DELIMITER", "{");
    let body = [];
    while (!match(parser, "DELIMITER", "}")) {
        if (peekType(parser) == "EOF") break;
        let startPos = parser.pos;
        let stmt = parseStatement(parser);
        if (stmt != null) {
            body.push(stmt);
        }
        if (parser.pos == startPos) {
            parserAdvance(parser);
        }
    }
    return {
        type: "BlockStatement",
        body: body
    };
}

function parseVariableDeclaration(parser) {
    let kind = "let";
    let tok = parserPeek(parser);
    if (tok.value == "let" || tok.value == "const" || tok.value == "var") {
        kind = tok.value;
        parserAdvance(parser);
    }
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let typeAnnotation = tryParseTypeAnnotation(parser);
    let init = null;
    if (match(parser, "OPERATOR", "=")) {
        init = parseExpression(parser);
    }
    expect(parser, "DELIMITER", ";");
    return {
        type: "VariableDeclaration",
        name: name,
        typeAnnotation: typeAnnotation,
        init: init,
        kind: kind
    };
}

function parseFunctionDeclaration(parser, isAsyncParam = false) {
    parserAdvance(parser);
    let isAsync = isAsyncParam;
    if (!isAsync && peekType(parser) == "KEYWORD" && peekValue(parser) == "async") {
        isAsync = true;
        parserAdvance(parser);
    }
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let genericParams = null;
    let lifetimeParams = null;
    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "<") {
        let parsed = parseGenericParams(parser);
        genericParams = parsed.typeParams;
        lifetimeParams = parsed.lifetimeParams;
    }
    let params = parseTypedParams(parser);
    let returnType = tryParseTypeAnnotation(parser);
    let body = parseBlockStatement(parser);
    return {
        type: "FunctionDeclaration",
        name: name,
        genericParams: genericParams,
        lifetimeParams: lifetimeParams,
        params: params,
        returnType: returnType,
        body: body,
        isAsync: isAsync
    };
}

function parseIfStatement(parser) {
    parserAdvance(parser);
    expect(parser, "DELIMITER", "(");
    let test = parseExpression(parser);
    expect(parser, "DELIMITER", ")");
    let consequent = parseStatement(parser);
    let alternate = null;
    if (match(parser, "KEYWORD", "else")) {
        alternate = parseStatement(parser);
    }
    return {
        type: "IfStatement",
        test: test,
        consequent: consequent,
        alternate: alternate
    };
}

function parseWhileStatement(parser) {
    parserAdvance(parser);
    expect(parser, "DELIMITER", "(");
    let test = parseExpression(parser);
    expect(parser, "DELIMITER", ")");
    let body = parseStatement(parser);
    return {
        type: "WhileStatement",
        test: test,
        body: body
    };
}

function parseDoWhileStatement(parser) {
    parserAdvance(parser);
    let body = parseStatement(parser);
    expect(parser, "KEYWORD", "while");
    expect(parser, "DELIMITER", "(");
    let test = parseExpression(parser);
    expect(parser, "DELIMITER", ")");
    expect(parser, "DELIMITER", ";");
    return {
        type: "DoWhileStatement",
        body: body,
        test: test
    };
}

function parseForStatement(parser) {
    parserAdvance(parser);
    expect(parser, "DELIMITER", "(");

    // Check for for...in or for...of
    let left = null;
    let isForIn = false;
    let isForOf = false;

    // Parse the left side (variable declaration or identifier)
    if (peekType(parser) == "KEYWORD" && (peekValue(parser) == "let" || peekValue(parser) == "const" || peekValue(parser) == "var")) {
        let kind = peekValue(parser);
        parserAdvance(parser);
        let varName = peekValue(parser);
        parserAdvance(parser);

        // Check if this is for...in or for...of
        if (peekType(parser) == "KEYWORD" && peekValue(parser) == "in") {
            isForIn = true;
            parserAdvance(parser);
            left = {
                type: "VariableDeclaration",
                kind: kind,
                declarations: [{
                    type: "VariableDeclarator",
                    id: { type: "Identifier", name: varName },
                    init: null
                }]
            };
        } else if (peekType(parser) == "KEYWORD" && peekValue(parser) == "of") {
            isForOf = true;
            parserAdvance(parser);
            left = {
                type: "VariableDeclaration",
                kind: kind,
                declarations: [{
                    type: "VariableDeclarator",
                    id: { type: "Identifier", name: varName },
                    init: null
                }]
            };
        } else {
            // Regular for loop - need to parse the rest of the variable declaration
            let init = null;
            if (match(parser, "OPERATOR", "=")) {
                init = parseExpression(parser);
            }
            left = {
                type: "VariableDeclaration",
                kind: kind,
                declarations: [{
                    type: "VariableDeclarator",
                    id: { type: "Identifier", name: varName },
                    init: init
                }]
            };
        }
    } else {
        left = parseExpression(parser);
        // Check for for...in or for...of with existing variable
        if (peekType(parser) == "KEYWORD" && peekValue(parser) == "in") {
            isForIn = true;
            parserAdvance(parser);
        } else if (peekType(parser) == "KEYWORD" && peekValue(parser) == "of") {
            isForOf = true;
            parserAdvance(parser);
        }
    }

    // Handle for...in
    if (isForIn) {
        let right = parseExpression(parser);
        expect(parser, "DELIMITER", ")");
        let body = parseStatement(parser);
        return {
            type: "ForInStatement",
            left: left,
            right: right,
            body: body
        };
    }

    // Handle for...of
    if (isForOf) {
        let right = parseExpression(parser);
        expect(parser, "DELIMITER", ")");
        let body = parseStatement(parser);
        return {
            type: "ForOfStatement",
            left: left,
            right: right,
            body: body
        };
    }

    // Regular for loop
    let init = left;
    expect(parser, "DELIMITER", ";");
    let test = null;
    if (peekType(parser) != "DELIMITER" || peekValue(parser) != ";") {
        test = parseExpression(parser);
    }
    expect(parser, "DELIMITER", ";");
    let update = null;
    if (peekType(parser) != "DELIMITER" || peekValue(parser) != ")") {
        update = parseExpression(parser);
    }
    expect(parser, "DELIMITER", ")");
    let body = parseStatement(parser);
    return {
        type: "ForStatement",
        init: init,
        test: test,
        update: update,
        body: body
    };
}

function parseReturnStatement(parser) {
    parserAdvance(parser);
    let argument = null;
    if (!match(parser, "DELIMITER", ";")) {
        argument = parseExpression(parser);
        expect(parser, "DELIMITER", ";");
    }
    return {
        type: "ReturnStatement",
        argument: argument
    };
}

function parseThrowStatement(parser) {
    parserAdvance(parser);
    let argument = parseExpression(parser);
    expect(parser, "DELIMITER", ";");
    return {
        type: "ThrowStatement",
        argument: argument
    };
}

function parseTryStatement(parser) {
    parserAdvance(parser);
    let block = parseBlockStatement(parser);
    let handler = null;
    if (match(parser, "KEYWORD", "catch")) {
        let param = "";
        if (match(parser, "DELIMITER", "(")) {
            if (peekType(parser) == "IDENTIFIER") {
                param = peekValue(parser);
            }
            parserAdvance(parser);
            expect(parser, "DELIMITER", ")");
        }
        let body = parseBlockStatement(parser);
        handler = {
            type: "CatchClause",
            param: param,
            body: body
        };
    }
    let finalizer = null;
    if (match(parser, "KEYWORD", "finally")) {
        finalizer = parseBlockStatement(parser);
    }
    return {
        type: "TryStatement",
        block: block,
        handler: handler,
        finalizer: finalizer
    };
}

function parseBreakStatement(parser) {
    parserAdvance(parser);
    expect(parser, "DELIMITER", ";");
    return {
        type: "BreakStatement",
        label: null
    };
}

function parseContinueStatement(parser) {
    parserAdvance(parser);
    expect(parser, "DELIMITER", ";");
    return {
        type: "ContinueStatement",
        label: null
    };
}

function parseClassDeclaration(parser) {
    parserAdvance(parser);
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let superClass = null;
    if (match(parser, "KEYWORD", "extends")) {
        if (peekType(parser) == "IDENTIFIER") {
            superClass = {
                type: "Identifier",
                name: peekValue(parser)
            };
        }
        parserAdvance(parser);
    }
    let body = parseBlockStatement(parser);
    return {
        type: "ClassDeclaration",
        name: name,
        superClass: superClass,
        body: body,
        decorators: []
    };
}

function parseImportDeclaration(parser) {
    parserAdvance(parser);
    let specifiers = [];
    if (peekType(parser) == "IDENTIFIER") {
        specifiers.push({
            type: "ImportDefaultSpecifier",
            local: peekValue(parser)
        });
        parserAdvance(parser);
        if (match(parser, "KEYWORD", "from")) {
        }
    } else if (match(parser, "OPERATOR", "{")) {
        while (!match(parser, "OPERATOR", "}")) {
            let imported = "";
            let local = "";
            if (peekType(parser) == "IDENTIFIER") {
                imported = peekValue(parser);
                local = imported;
                parserAdvance(parser);
                if (match(parser, "KEYWORD", "as")) {
                    if (peekType(parser) == "IDENTIFIER") {
                        local = peekValue(parser);
                    }
                    parserAdvance(parser);
                }
                specifiers.push({
                    type: "ImportSpecifier",
                    imported: imported,
                    local: local
                });
                match(parser, "DELIMITER", ",");
            }
        }
    } else if (match(parser, "OPERATOR", "*")) {
        expect(parser, "KEYWORD", "as");
        if (peekType(parser) == "IDENTIFIER") {
            specifiers.push({
                type: "ImportNamespaceSpecifier",
                local: peekValue(parser)
            });
        }
        parserAdvance(parser);
    }
    expect(parser, "KEYWORD", "from");
    let source = "";
    if (peekType(parser) == "STRING") {
        source = peekValue(parser);
        parserAdvance(parser);
    }
    expect(parser, "DELIMITER", ";");
    return {
        type: "ImportDeclaration",
        specifiers: specifiers,
        source: source
    };
}

function parseExportDeclaration(parser) {
    parserAdvance(parser);
    if (match(parser, "KEYWORD", "const") || match(parser, "KEYWORD", "let") || match(parser, "KEYWORD", "function")) {
        parser.pos = parser.pos - 1;
        let decl = parseVariableDeclaration(parser);
        return {
            type: "ExportNamedDeclaration",
            specifiers: [],
            source: null,
            declaration: decl
        };
    }
    if (match(parser, "OPERATOR", "{")) {
        let specifiers = [];
        while (!match(parser, "OPERATOR", "}")) {
            let local = "";
            let exported = "";
            if (peekType(parser) == "IDENTIFIER") {
                local = peekValue(parser);
                exported = local;
                parserAdvance(parser);
                if (match(parser, "KEYWORD", "as")) {
                    if (peekType(parser) == "IDENTIFIER") {
                        exported = peekValue(parser);
                    }
                    parserAdvance(parser);
                }
                specifiers.push({
                    type: "ExportSpecifier",
                    local: local,
                    exported: exported
                });
                match(parser, "DELIMITER", ",");
            }
        }
        if (match(parser, "KEYWORD", "from")) {
            let source = "";
            if (peekType(parser) == "STRING") {
                source = peekValue(parser);
                parserAdvance(parser);
            }
            expect(parser, "DELIMITER", ";");
            return {
                type: "ExportNamedDeclaration",
                specifiers: specifiers,
                source: source,
                declaration: null
            };
        }
        expect(parser, "DELIMITER", ";");
        return {
            type: "ExportNamedDeclaration",
            specifiers: specifiers,
            source: null,
            declaration: null
        };
    }
    if (match(parser, "KEYWORD", "default")) {
        let decl = null;
        if (peekType(parser) == "KEYWORD" && peekValue(parser) == "function") {
            decl = parseFunctionDeclaration(parser);
        } else {
            decl = parseExpressionStatement(parser);
        }
        return {
            type: "ExportDefaultDeclaration",
            declaration: decl
        };
    }
    if (match(parser, "OPERATOR", "*")) {
        expect(parser, "KEYWORD", "from");
        let source = "";
        if (peekType(parser) == "STRING") {
            source = peekValue(parser);
            parserAdvance(parser);
        }
        expect(parser, "DELIMITER", ";");
        return {
            type: "ExportAllDeclaration",
            source: source
        };
    }
    return null;
}

function parseRequireStatement(parser) {
    parserAdvance(parser); // consume 'require'
    let path = "";
    // require can be followed by a string or a path like ./lexer
    if (peekType(parser) == "STRING") {
        path = peekValue(parser);
        parserAdvance(parser);
    } else {
        // Read path tokens until semicolon or newline
        while (peekType(parser) != "DELIMITER" || peekValue(parser) != ";") {
            if (peekType(parser) == "EOF") break;
            path = path + peekValue(parser);
            parserAdvance(parser);
        }
    }
    match(parser, "DELIMITER", ";");
    return {
        type: "RequireStatement",
        path: path
    };
}

function parseTypeAliasDeclaration(parser) {
    parserAdvance(parser);
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let genericParams = null;
    let lifetimeParams = null;
    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "<") {
        let parsed = parseGenericParams(parser);
        genericParams = parsed.typeParams;
        lifetimeParams = parsed.lifetimeParams;
    }
    expect(parser, "OPERATOR", "=");
    let typeAnnotation = parseTypeAnnotation(parser);
    match(parser, "DELIMITER", ";");
    return {
        type: "TypeAliasDeclaration",
        name: name,
        genericParams: genericParams,
        lifetimeParams: lifetimeParams,
        typeAnnotation: typeAnnotation
    };
}

function parseInterfaceDeclaration(parser) {
    parserAdvance(parser);
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    let genericParams = null;
    let lifetimeParams = null;
    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "<") {
        let parsed = parseGenericParams(parser);
        genericParams = parsed.typeParams;
        lifetimeParams = parsed.lifetimeParams;
    }
    let extendsTypes = [];
    if (peekType(parser) == "KEYWORD" && peekValue(parser) == "extends") {
        parserAdvance(parser);
        while (true) {
            let extendType = parseTypeAnnotation(parser);
            if (extendType != null) {
                extendsTypes.push(extendType);
            }
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == ",") {
                parserAdvance(parser);
            } else {
                break;
            }
        }
    }
    expect(parser, "DELIMITER", "{");
    let members = [];
    while (peekType(parser) != "DELIMITER" || peekValue(parser) != "}") {
        if (peekType(parser) == "EOF") break;
        let member = parseInterfaceMember(parser);
        if (member != null) {
            members.push(member);
        }
    }
    expect(parser, "DELIMITER", "}");
    return {
        type: "InterfaceDeclaration",
        name: name,
        genericParams: genericParams,
        lifetimeParams: lifetimeParams,
        extends: extendsTypes,
        members: members
    };
}

function parseInterfaceMember(parser) {
    let name = "";
    let optional = false;
    if (peekType(parser) == "IDENTIFIER" || peekType(parser) == "KEYWORD") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "?") {
        optional = true;
        parserAdvance(parser);
    }
    let typeAnnotation = null;
    if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
        typeAnnotation = tryParseTypeAnnotation(parser);
    } else if (peekType(parser) == "DELIMITER" && peekValue(parser) == "(") {
        let params = parseTypedParams(parser);
        let returnType = tryParseTypeAnnotation(parser);
        typeAnnotation = {
            type: "FunctionTypeAnnotation",
            params: params,
            returnType: returnType
        };
    }
    match(parser, "DELIMITER", ";");
    match(parser, "DELIMITER", ",");
    return {
        type: "InterfaceMember",
        name: name,
        optional: optional,
        typeAnnotation: typeAnnotation
    };
}

function parseEnumDeclaration(parser) {
    parserAdvance(parser); // consume 'enum'
    let name = "";
    if (peekType(parser) == "IDENTIFIER") {
        name = peekValue(parser);
        parserAdvance(parser);
    }
    expect(parser, "DELIMITER", "{");
    let members = [];
    let autoValue = 0;
    while (peekType(parser) != "DELIMITER" || peekValue(parser) != "}") {
        if (peekType(parser) == "EOF") break;
        let memberName = "";
        if (peekType(parser) == "IDENTIFIER") {
            memberName = peekValue(parser);
            parserAdvance(parser);
        }
        let value = null;
        if (peekType(parser) == "OPERATOR" && peekValue(parser) == "=") {
            parserAdvance(parser);
            if (peekType(parser) == "NUMBER") {
                value = parseFloat(peekValue(parser));
                autoValue = value + 1;
                parserAdvance(parser);
            } else if (peekType(parser) == "STRING") {
                value = peekValue(parser);
                parserAdvance(parser);
            }
        } else {
            value = autoValue;
            autoValue = autoValue + 1;
        }
        members.push({
            type: "EnumMember",
            name: memberName,
            value: value
        });
        match(parser, "DELIMITER", ",");
    }
    expect(parser, "DELIMITER", "}");
    return {
        type: "EnumDeclaration",
        name: name,
        members: members
    };
}

function parseLifetimeParams(parser) {
    let lifetimes = [];
    while (peekType(parser) == "OPERATOR" && peekValue(parser) == "'") {
        parserAdvance(parser);
        if (peekType(parser) == "IDENTIFIER") {
            let lifetimeName = peekValue(parser);
            parserAdvance(parser);
            let bounds = [];
            if (peekType(parser) == "DELIMITER" && peekValue(parser) == ":") {
                parserAdvance(parser);
                while (peekType(parser) == "OPERATOR" && peekValue(parser) == "'") {
                    parserAdvance(parser);
                    if (peekType(parser) == "IDENTIFIER") {
                        bounds.push(peekValue(parser));
                        parserAdvance(parser);
                    }
                    if (peekType(parser) == "OPERATOR" && peekValue(parser) == "+") {
                        parserAdvance(parser);
                    } else {
                        break;
                    }
                }
            }
            lifetimes.push({
                type: "LifetimeParameter",
                name: lifetimeName,
                bounds: bounds
            });
        }
        if (peekType(parser) == "DELIMITER" && peekValue(parser) == ",") {
            parserAdvance(parser);
        } else {
            break;
        }
    }
    return lifetimes;
}

function parseGenericParams(parser) {
    let params = [];
    let lifetimeParams = [];
    expect(parser, "OPERATOR", "<");

    lifetimeParams = parseLifetimeParams(parser);

    while (peekType(parser) != "OPERATOR" || peekValue(parser) != ">") {
        if (peekType(parser) == "EOF") break;
        if (peekType(parser) == "IDENTIFIER") {
            let paramName = peekValue(parser);
            parserAdvance(parser);
            let constraint = null;
            if (peekType(parser) == "KEYWORD" && peekValue(parser) == "extends") {
                parserAdvance(parser);
                constraint = parseTypeAnnotation(parser);
            }
            params.push({
                type: "TypeParameter",
                name: paramName,
                constraint: constraint
            });
        }
        if (peekType(parser) == "DELIMITER" && peekValue(parser) == ",") {
            parserAdvance(parser);
        } else {
            break;
        }
    }
    expect(parser, "OPERATOR", ">");
    return {
        typeParams: params,
        lifetimeParams: lifetimeParams
    };
}

function parseExpressionStatement(parser) {
    let expr = parseExpression(parser);
    expect(parser, "DELIMITER", ";");
    return {
        type: "ExpressionStatement",
        expression: expr
    };
}

function isAtEnd(parser) {
    return peekType(parser) == "EOF";
}

console.log("Statement parsers loaded");
