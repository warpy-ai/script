// ============================================================================
// IR Types for tscl Compiler
// ============================================================================

// ============================================================================
// IR Value and Types
// ============================================================================

type IrValue = number;

enum IrType {
    NUMBER = 0,
    STRING = 1,
    BOOLEAN = 2,
    OBJECT = 3,
    ARRAY = 4,
    FUNCTION = 5,
    ANY = 6,
    NEVER = 7,
    VOID = 8
}

// ============================================================================
// IR Operation Codes
// ============================================================================

enum IrOpCode {
    CONST = 0,
    ADD = 1,
    SUB = 2,
    MUL = 3,
    DIV = 4,
    MOD = 5,
    NEG = 6,
    NOT = 7,
    EQ = 8,
    NE = 9,
    LT = 10,
    GT = 11,
    LE = 12,
    GE = 13,
    AND = 14,
    OR = 15,
    LOAD = 16,
    STORE = 17,
    LOAD_LOCAL = 18,
    STORE_LOCAL = 19,
    LOAD_PROP = 20,
    STORE_PROP = 21,
    LOAD_ELEMENT = 22,
    STORE_ELEMENT = 23,
    JUMP = 24,
    JUMP_IF_FALSE = 25,
    CALL = 26,
    CALL_METHOD = 27,
    RETURN = 28,
    PHI = 29,
    NEW_OBJECT = 30,
    NEW_ARRAY = 31,
    LENGTH = 32,
    TO_NUMBER = 33,
    TO_STRING = 34,
    TO_BOOLEAN = 35
}

// ============================================================================
// IR Data Structures
// ============================================================================

interface IrInstruction {
    opcode: IrOpCode;
    dest: number | null;
    args: number[];
    immediate: IrValue | null;
    label: string | null;
}

interface IrBlock {
    label: string;
    ops: IrInstruction[];
    predecessors: IrBlock[];
    successors: IrBlock[];
}

interface IrFunction {
    name: string;
    params: string[];
    return_type: IrType;
    locals: { index: number, name: string, type: IrType }[];
    blocks: IrBlock[];
    entry_block: IrBlock;
}

interface IrModule {
    version: number;
    abi_version: number;
    functions: IrFunction[];
}

interface RegisterAllocator {
    next_reg: number;
    max_regs: number;
}

// ============================================================================
// Register Allocator Functions
// ============================================================================

function createRegisterAllocator(): RegisterAllocator {
    return {
        next_reg: 0,
        max_regs: 0
    };
}

function resetRegisterAllocator(ra: RegisterAllocator): void {
    ra.next_reg = 0;
    ra.max_regs = 0;
}

function allocateRegister(ra: RegisterAllocator): number {
    let reg = ra.next_reg;
    ra.next_reg = ra.next_reg + 1;
    if (ra.next_reg > ra.max_regs) {
        ra.max_regs = ra.next_reg;
    }
    return reg;
}

function getMaxRegisters(ra: RegisterAllocator): number {
    return ra.max_regs;
}

// ============================================================================
// IR Block Construction
// ============================================================================

function createIrBlock(label: string): IrBlock {
    return {
        label: label,
        ops: [],
        predecessors: [],
        successors: []
    };
}

// ============================================================================
// IR Instruction Emission
// ============================================================================

function emitIrOp(block: IrBlock, opcode: IrOpCode, dest: number | null, args: number[], immediate: IrValue | null): void {
    let inst: IrInstruction = {
        opcode: opcode,
        dest: dest,
        args: args,
        immediate: immediate,
        label: null
    };
    block.ops.push(inst);
}

function emitConst(block: IrBlock, dest: number, value: IrValue): void {
    emitIrOp(block, IrOpCode.CONST, dest, [], value);
}

function emitBinaryOp(block: IrBlock, opcode: IrOpCode, dest: number, left: number, right: number): void {
    emitIrOp(block, opcode, dest, [left, right], null);
}

function emitLoadLocal(block: IrBlock, dest: number, slot: number): void {
    emitIrOp(block, IrOpCode.LOAD_LOCAL, dest, [slot], null);
}

function emitStoreLocal(block: IrBlock, slot: number, value: number): void {
    emitIrOp(block, IrOpCode.STORE_LOCAL, null, [slot, value], null);
}

function emitJump(block: IrBlock, targetBlock: IrBlock): void {
    let inst: IrInstruction = {
        opcode: IrOpCode.JUMP,
        dest: null,
        args: [],
        immediate: null,
        label: targetBlock.label
    };
    block.ops.push(inst);
    block.successors.push(targetBlock);
    targetBlock.predecessors.push(block);
}

function emitJumpIfFalse(block: IrBlock, cond: number, targetBlock: IrBlock): void {
    let inst: IrInstruction = {
        opcode: IrOpCode.JUMP_IF_FALSE,
        dest: null,
        args: [cond],
        immediate: null,
        label: targetBlock.label
    };
    block.ops.push(inst);
    block.successors.push(targetBlock);
    targetBlock.predecessors.push(block);
}

function emitReturn(block: IrBlock, value: number | null): void {
    if (value != null) {
        emitIrOp(block, IrOpCode.RETURN, null, [value], null);
    } else {
        emitIrOp(block, IrOpCode.RETURN, null, [], null);
    }
}

function emitCall(block: IrBlock, dest: number, funcReg: number, argRegs: number[]): void {
    // Store [funcReg, argc, arg0, arg1, ...]
    let args: number[] = [funcReg, argRegs.length];
    let i = 0;
    while (i < argRegs.length) {
        args.push(argRegs[i]);
        i = i + 1;
    }
    emitIrOp(block, IrOpCode.CALL, dest, args, null);
}

function emitMethodCall(block: IrBlock, dest: number, objName: string, methodName: string, argRegs: number[]): void {
    // Store argument value IDs and method name as immediate
    // args contains [argc, arg0, arg1, ...]
    let args: number[] = [argRegs.length];
    let i = 0;
    while (i < argRegs.length) {
        args.push(argRegs[i]);
        i = i + 1;
    }
    // Use immediate to store "objName.methodName"
    let methodPath = objName + "." + methodName;
    emitIrOp(block, IrOpCode.CALL_METHOD, dest, args, methodPath);
}

// ============================================================================
// IR Verification
// ============================================================================

function verifyIrModule(module: IrModule): boolean {
    let i = 0;
    while (i < module.functions.length) {
        let func = module.functions[i];
        if (!verifyIrFunction(func)) {
            console.log("IR verification failed for function: " + func.name);
            return false;
        }
        i = i + 1;
    }
    return true;
}

function verifyIrFunction(func: IrFunction): boolean {
    if (func.name == null || func.name == "") {
        console.log("Function name is empty");
        return false;
    }
    if (func.entry_block == null) {
        console.log("Function " + func.name + " has no entry block");
        return false;
    }
    let i = 0;
    while (i < func.blocks.length) {
        let block = func.blocks[i];
        if (!verifyIrBlock(block)) {
            console.log("IR verification failed for block: " + block.label);
            return false;
        }
        i = i + 1;
    }
    return true;
}

function verifyIrBlock(block: IrBlock): boolean {
    if (block.label == null || block.label == "") {
        console.log("Block label is empty");
        return false;
    }
    let i = 0;
    while (i < block.ops.length) {
        let op = block.ops[i];
        if (op.opcode == null) {
            console.log("Block " + block.label + " has instruction with null opcode");
            return false;
        }
        i = i + 1;
    }
    return true;
}

// ============================================================================
// IR Serialization (Deterministic)
// ============================================================================

// Helper to get opcode name (VM doesn't support reverse enum lookup)
// Using explicit numeric comparisons due to VM enum resolution issues
function getOpCodeName(opcode: IrOpCode): string {
    if (opcode == 0) return "CONST";
    if (opcode == 1) return "ADD";
    if (opcode == 2) return "SUB";
    if (opcode == 3) return "MUL";
    if (opcode == 4) return "DIV";
    if (opcode == 5) return "MOD";
    if (opcode == 6) return "NEG";
    if (opcode == 7) return "NOT";
    if (opcode == 8) return "EQ";
    if (opcode == 9) return "NE";
    if (opcode == 10) return "LT";
    if (opcode == 11) return "GT";
    if (opcode == 12) return "LE";
    if (opcode == 13) return "GE";
    if (opcode == 14) return "AND";
    if (opcode == 15) return "OR";
    if (opcode == 16) return "LOAD";
    if (opcode == 17) return "STORE";
    if (opcode == 18) return "LOAD_LOCAL";
    if (opcode == 19) return "STORE_LOCAL";
    if (opcode == 20) return "LOAD_PROP";
    if (opcode == 21) return "STORE_PROP";
    if (opcode == 22) return "LOAD_ELEMENT";
    if (opcode == 23) return "STORE_ELEMENT";
    if (opcode == 24) return "JUMP";
    if (opcode == 25) return "JUMP_IF_FALSE";
    if (opcode == 26) return "CALL";
    if (opcode == 27) return "CALL_METHOD";
    if (opcode == 28) return "RETURN";
    if (opcode == 29) return "PHI";
    if (opcode == 30) return "NEW_OBJECT";
    if (opcode == 31) return "NEW_ARRAY";
    if (opcode == 32) return "LENGTH";
    if (opcode == 33) return "TO_NUMBER";
    if (opcode == 34) return "TO_STRING";
    if (opcode == 35) return "TO_BOOLEAN";
    return "UNKNOWN(" + opcode + ")";
}

// Helper to get type name (VM doesn't support reverse enum lookup)
function getTypeName(ty: IrType): string {
    if (ty == IrType.NUMBER) return "number";
    if (ty == IrType.STRING) return "string";
    if (ty == IrType.BOOLEAN) return "boolean";
    if (ty == IrType.OBJECT) return "object";
    if (ty == IrType.ARRAY) return "array";
    if (ty == IrType.FUNCTION) return "function";
    if (ty == IrType.ANY) return "any";
    if (ty == IrType.NEVER) return "never";
    if (ty == IrType.VOID) return "void";
    return "unknown";
}

function serializeIrModule(module: IrModule): string {
    let lines: string[] = [];
    lines.push("; ============================================================");
    lines.push("; tscl IR Module");
    lines.push("; Format version: " + module.version);
    lines.push("; ABI version: " + module.abi_version);
    lines.push("; ============================================================");
    lines.push("");

    let i = 0;
    while (i < module.functions.length) {
        lines.push(serializeIrFunction(module.functions[i]));
        lines.push("");
        i = i + 1;
    }

    let result = "";
    let j = 0;
    while (j < lines.length) {
        result = result + lines[j] + "\n";
        j = j + 1;
    }
    return result;
}

function serializeIrFunction(func: IrFunction): string {
    let lines: string[] = [];
    lines.push("fn " + func.name + "(" + func.params.join(", ") + ") -> " + getTypeName(func.return_type) + " {");

    let i = 0;
    while (i < func.locals.length) {
        let loc = func.locals[i];
        lines.push("    local $" + loc.index + ": " + loc.name + ": " + getTypeName(loc.type));
        i = i + 1;
    }
    lines.push("");

    let j = 0;
    while (j < func.blocks.length) {
        lines.push(serializeIrBlock(func.blocks[j]));
        j = j + 1;
    }
    lines.push("}");

    let result = "";
    let k = 0;
    while (k < lines.length) {
        result = result + lines[k] + "\n";
        k = k + 1;
    }
    return result;
}

function serializeIrBlock(block: IrBlock): string {
    let lines: string[] = [];
    lines.push(block.label + ":");
    let i = 0;
    while (i < block.ops.length) {
        lines.push("    " + serializeIrInstruction(block.ops[i]));
        i = i + 1;
    }
    let result = "";
    let j = 0;
    while (j < lines.length) {
        result = result + lines[j] + "\n";
        j = j + 1;
    }
    return result;
}

function serializeIrInstruction(inst: IrInstruction): string {
    let opName = getOpCodeName(inst.opcode);
    if (inst.dest != null) {
        if (inst.args.length > 0) {
            let args = "";
            let i = 0;
            while (i < inst.args.length) {
                args = args + "v" + inst.args[i];
                if (i < inst.args.length - 1) {
                    args = args + ", ";
                }
                i = i + 1;
            }
            return opName + " v" + inst.dest + " = " + args;
        } else if (inst.immediate != null) {
            return opName + " v" + inst.dest + " = " + String(inst.immediate);
        } else {
            return opName + " v" + inst.dest;
        }
    } else {
        if (inst.args.length > 0) {
            let args = "";
            let i = 0;
            while (i < inst.args.length) {
                args = args + "v" + inst.args[i];
                if (i < inst.args.length - 1) {
                    args = args + ", ";
                }
                i = i + 1;
            }
            return opName + " " + args;
        }
    }
    return opName;
}

console.log("IR module loaded");
