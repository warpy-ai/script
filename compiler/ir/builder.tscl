// ============================================================================
// IR Builder for tscl Compiler
// ============================================================================

require ./mod;

// ============================================================================
// Builder State
// ============================================================================

function createIrBuilder() {
    return {
        currentFunction: null,
        currentBlock: null,
        ra: createRegisterAllocator(),
        functions: []
    };
}

function irBuilderEnterFunction(builder, name, returnType) {
    let func = {
        name: name,
        params: [],
        return_type: returnType,
        locals: [],
        blocks: [],
        entry_block: null,
        current_block: null
    };
    builder.currentFunction = func;
    builder.functions.push(func);
    resetRegisterAllocator(builder.ra);
    return func;
}

function irBuilderAddParam(builder, name) {
    let func = builder.currentFunction;
    let slot = func.params.length;
    func.params.push(name);
    func.locals.push({ index: slot, name: name, type: IrType.ANY });
    return slot;
}

function irBuilderCreateEntryBlock(builder) {
    let func = builder.currentFunction;
    let block = createIrBlock(func.name + "_entry");
    func.entry_block = block;
    func.blocks.push(block);
    builder.currentBlock = block;
    return block;
}

function irBuilderAddBlock(builder, label) {
    let func = builder.currentFunction;
    let block = createIrBlock(label);
    func.blocks.push(block);
    builder.currentBlock = block;
    return block;
}

function irBuilderSetBlock(builder, block) {
    builder.currentBlock = block;
}

function irBuilderGetBlockOpCount(builder) {
    if (builder.currentBlock == null) {
        return 0;
    }
    return builder.currentBlock.ops.length;
}

function irBuilderEmitConst(builder, value) {
    let dest = allocateRegister(builder.ra);
    emitConst(builder.currentBlock, dest, value);
    return dest;
}

function irBuilderEmitConstString(builder, value) {
    let dest = allocateRegister(builder.ra);
    emitIrOp(builder.currentBlock, IrOpCode.CONST, dest, [], value);
    return dest;
}

function irBuilderEmitBinaryOp(builder, opcode, left, right) {
    let dest = allocateRegister(builder.ra);
    emitBinaryOp(builder.currentBlock, opcode, dest, left, right);
    return dest;
}

function irBuilderEmitAdd(builder, left, right) {
    return irBuilderEmitBinaryOp(builder, IrOpCode.ADD, left, right);
}

function irBuilderEmitSub(builder, left, right) {
    return irBuilderEmitBinaryOp(builder, IrOpCode.SUB, left, right);
}

function irBuilderEmitMul(builder, left, right) {
    return irBuilderEmitBinaryOp(builder, IrOpCode.MUL, left, right);
}

function irBuilderEmitDiv(builder, left, right) {
    return irBuilderEmitBinaryOp(builder, IrOpCode.DIV, left, right);
}

function irBuilderEmitLoadLocal(builder, slot) {
    let dest = allocateRegister(builder.ra);
    emitLoadLocal(builder.currentBlock, dest, slot);
    return dest;
}

function irBuilderEmitStoreLocal(builder, slot, value) {
    emitStoreLocal(builder.currentBlock, slot, value);
}

function irBuilderEmitJump(builder, targetBlock) {
    emitJump(builder.currentBlock, targetBlock);
}

function irBuilderEmitJumpIfFalse(builder, cond, targetBlock) {
    emitJumpIfFalse(builder.currentBlock, cond, targetBlock);
}

function irBuilderEmitReturn(builder, value) {
    emitReturn(builder.currentBlock, value);
}

function irBuilderEmitReturnVoid(builder) {
    emitReturn(builder.currentBlock, null);
}

function irBuilderEmitCall(builder, funcReg, argc) {
    let dest = allocateRegister(builder.ra);
    emitCall(builder.currentBlock, dest, funcReg, argc);
    return dest;
}

function irBuilderEmitLoad(builder, address) {
    let dest = allocateRegister(builder.ra);
    emitIrOp(builder.currentBlock, IrOpCode.LOAD, dest, [address], null);
    return dest;
}

function irBuilderEmitStore(builder, address, value) {
    emitIrOp(builder.currentBlock, IrOpCode.STORE, null, [address, value], null);
}

function irBuilderEmitLoadProp(builder, objReg, propName) {
    let dest = allocateRegister(builder.ra);
    emitIrOp(builder.currentBlock, IrOpCode.LOAD_PROP, dest, [objReg], propName);
    return dest;
}

function irBuilderEmitStoreProp(builder, objReg, propName, valueReg) {
    emitIrOp(builder.currentBlock, IrOpCode.STORE_PROP, null, [objReg, valueReg], propName);
}

function irBuilderEmitLoadElement(builder, arrReg, indexReg) {
    let dest = allocateRegister(builder.ra);
    emitIrOp(builder.currentBlock, IrOpCode.LOAD_ELEMENT, dest, [arrReg, indexReg], null);
    return dest;
}

function irBuilderEmitStoreElement(builder, arrReg, indexReg, valueReg) {
    emitIrOp(builder.currentBlock, IrOpCode.STORE_ELEMENT, null, [arrReg, indexReg, valueReg], null);
}

function irBuilderGetMaxRegs(builder) {
    return getMaxRegisters(builder.ra);
}

// ============================================================================
// High-level IR Construction Helpers
// ============================================================================

function irBuilderCreateSimpleFunction(builder, name, bodyBuilder) {
    let func = irBuilderEnterFunction(builder, name, IrType.ANY);
    irBuilderCreateEntryBlock(builder);
    bodyBuilder(builder);
    return func;
}

function irBuilderCreateMathFunction(builder, name, op) {
    return irBuilderCreateSimpleFunction(builder, name, function(b) {
        let aSlot = irBuilderAddParam(b, "a");
        let bSlot = irBuilderAddParam(b, "b");
        let a = irBuilderEmitLoadLocal(b, aSlot);
        let b = irBuilderEmitLoadLocal(b, bSlot);
        let result = irBuilderEmitBinaryOp(b, op, a, b);
        irBuilderEmitReturn(b, result);
    });
}

function irBuilderCreateComparisonFunction(builder, name, op) {
    return irBuilderCreateSimpleFunction(builder, name, function(b) {
        let aSlot = irBuilderAddParam(b, "a");
        let bSlot = irBuilderAddParam(b, "b");
        let a = irBuilderEmitLoadLocal(b, aSlot);
        let b = irBuilderEmitLoadLocal(b, bSlot);
        let result = irBuilderEmitBinaryOp(b, op, a, b);
        irBuilderEmitReturn(b, result);
    });
}

// ============================================================================
// AST to IR Lowering
// ============================================================================

// Lowering context for tracking variable bindings and loop targets
function createLoweringContext(builder) {
    return {
        builder: builder,
        variables: {},  // name -> slot
        nextSlot: 0,
        loopStack: []   // Stack of { breakBlock, continueBlock, label }
    };
}

// Push a loop context for break/continue
function contextPushLoop(ctx, breakBlock, continueBlock, label) {
    ctx.loopStack.push({
        breakBlock: breakBlock,
        continueBlock: continueBlock,
        label: label
    });
}

// Pop a loop context
function contextPopLoop(ctx) {
    ctx.loopStack.pop();
}

// Find loop target for break/continue (with optional label)
function contextFindLoop(ctx, label) {
    if (ctx.loopStack.length == 0) {
        return null;
    }
    if (label == null) {
        // No label - use innermost loop
        return ctx.loopStack[ctx.loopStack.length - 1];
    }
    // Search for labeled loop
    let i = ctx.loopStack.length - 1;
    while (i >= 0) {
        if (ctx.loopStack[i].label == label) {
            return ctx.loopStack[i];
        }
        i = i - 1;
    }
    return null;
}

function contextDeclareVariable(ctx, name) {
    let slot = ctx.nextSlot;
    ctx.nextSlot = ctx.nextSlot + 1;
    ctx.variables[name] = slot;
    return slot;
}

function contextLookupVariable(ctx, name) {
    if (ctx.variables[name] != null) {
        return ctx.variables[name];
    }
    return -1;
}

// Lower a complete program to IR module
function lowerProgramToIr(ast) {
    let builder = createIrBuilder();

    // First pass: lower all function declarations
    let i = 0;
    while (i < ast.body.length) {
        let stmt = ast.body[i];
        if (stmt.type == "FunctionDeclaration") {
            lowerFunctionDeclarationFull(builder, stmt);
        }
        i = i + 1;
    }

    // Second pass: create main function for top-level code
    let hasTopLevel = false;
    i = 0;
    while (i < ast.body.length) {
        let stmt = ast.body[i];
        if (stmt.type != "FunctionDeclaration") {
            hasTopLevel = true;
        }
        i = i + 1;
    }

    if (hasTopLevel) {
        irBuilderEnterFunction(builder, "main", IrType.VOID);
        irBuilderCreateEntryBlock(builder);
        let ctx = createLoweringContext(builder);

        i = 0;
        while (i < ast.body.length) {
            let stmt = ast.body[i];
            if (stmt.type != "FunctionDeclaration") {
                lowerStatement(ctx, stmt);
            }
            i = i + 1;
        }

        irBuilderEmitReturnVoid(builder);
    }

    return irBuilderFinish(builder);
}

// Lower a function declaration
function lowerFunctionDeclarationFull(builder, node) {
    let returnType = IrType.ANY;
    if (node.returnType != null) {
        returnType = irTypeFromAnnotation(node.returnType);
    }

    irBuilderEnterFunction(builder, node.name, returnType);
    irBuilderCreateEntryBlock(builder);

    let ctx = createLoweringContext(builder);

    // Add parameters
    let j = 0;
    while (j < node.params.length) {
        let param = node.params[j];
        let paramName = param;
        if (typeof param === "object" && param.name != null) {
            paramName = param.name;
        }
        let slot = irBuilderAddParam(builder, paramName);
        ctx.variables[paramName] = slot;
        ctx.nextSlot = slot + 1;
        j = j + 1;
    }

    // Lower function body
    if (node.body != null && node.body.type == "BlockStatement") {
        lowerBlockStatement(ctx, node.body);
    }

    // Ensure function ends with return
    let lastOp = irBuilderGetBlockOpCount(builder);
    if (lastOp == 0 || !blockEndsWithReturn(builder)) {
        irBuilderEmitReturnVoid(builder);
    }
}

function blockEndsWithReturn(builder) {
    if (builder.currentBlock == null) {
        return false;
    }
    let ops = builder.currentBlock.ops;
    if (ops.length == 0) {
        return false;
    }
    let lastOp = ops[ops.length - 1];
    return lastOp.opcode == IrOpCode.RETURN;
}

// Lower a block statement (list of statements)
function lowerBlockStatement(ctx, node) {
    let i = 0;
    while (i < node.body.length) {
        lowerStatement(ctx, node.body[i]);
        i = i + 1;
    }
}

// Lower a single statement
function lowerStatement(ctx, stmt) {
    if (stmt.type == "VariableDeclaration") {
        lowerVariableDeclaration(ctx, stmt);
    } else if (stmt.type == "ExpressionStatement") {
        lowerExpression(ctx, stmt.expression);
    } else if (stmt.type == "ReturnStatement") {
        lowerReturnStatement(ctx, stmt);
    } else if (stmt.type == "IfStatement") {
        lowerIfStatement(ctx, stmt);
    } else if (stmt.type == "WhileStatement") {
        lowerWhileStatement(ctx, stmt);
    } else if (stmt.type == "ForStatement") {
        lowerForStatement(ctx, stmt);
    } else if (stmt.type == "DoWhileStatement") {
        lowerDoWhileStatement(ctx, stmt);
    } else if (stmt.type == "BlockStatement") {
        lowerBlockStatement(ctx, stmt);
    } else if (stmt.type == "BreakStatement") {
        lowerBreakStatement(ctx, stmt);
    } else if (stmt.type == "ContinueStatement") {
        lowerContinueStatement(ctx, stmt);
    } else if (stmt.type == "ThrowStatement") {
        lowerThrowStatement(ctx, stmt);
    } else if (stmt.type == "TryStatement") {
        lowerTryStatement(ctx, stmt);
    }
}

// Lower variable declaration
function lowerVariableDeclaration(ctx, node) {
    let declarations = node.declarations;
    if (declarations == null) {
        declarations = [node];
    }

    let i = 0;
    while (i < declarations.length) {
        let decl = declarations[i];
        let name = decl.id;
        if (typeof decl.id === "object" && decl.id.name != null) {
            name = decl.id.name;
        }

        let slot = contextDeclareVariable(ctx, name);
        ctx.builder.currentFunction.locals.push({
            index: slot,
            name: name,
            type: IrType.ANY
        });

        if (decl.init != null) {
            let valueReg = lowerExpression(ctx, decl.init);
            irBuilderEmitStoreLocal(ctx.builder, slot, valueReg);
        }
        i = i + 1;
    }
}

// Lower return statement
function lowerReturnStatement(ctx, stmt) {
    if (stmt.argument != null) {
        let valueReg = lowerExpression(ctx, stmt.argument);
        irBuilderEmitReturn(ctx.builder, valueReg);
    } else {
        irBuilderEmitReturnVoid(ctx.builder);
    }
}

// Lower if statement
function lowerIfStatement(ctx, stmt) {
    let builder = ctx.builder;
    let thenBlock = irBuilderAddBlock(builder, "if_then");
    let elseBlock = irBuilderAddBlock(builder, "if_else");
    let mergeBlock = irBuilderAddBlock(builder, "if_merge");

    let currentBlock = builder.currentBlock;
    irBuilderSetBlock(builder, currentBlock);

    // Evaluate condition
    let cond = lowerExpression(ctx, stmt.test);
    irBuilderEmitJumpIfFalse(builder, cond, elseBlock);
    irBuilderEmitJump(builder, thenBlock);

    // Then branch
    irBuilderSetBlock(builder, thenBlock);
    if (stmt.consequent.type == "BlockStatement") {
        lowerBlockStatement(ctx, stmt.consequent);
    } else {
        lowerStatement(ctx, stmt.consequent);
    }
    if (!blockEndsWithReturn(builder)) {
        irBuilderEmitJump(builder, mergeBlock);
    }

    // Else branch
    irBuilderSetBlock(builder, elseBlock);
    if (stmt.alternate != null) {
        if (stmt.alternate.type == "BlockStatement") {
            lowerBlockStatement(ctx, stmt.alternate);
        } else {
            lowerStatement(ctx, stmt.alternate);
        }
    }
    if (!blockEndsWithReturn(builder)) {
        irBuilderEmitJump(builder, mergeBlock);
    }

    // Continue in merge block
    irBuilderSetBlock(builder, mergeBlock);
}

// Lower while statement
function lowerWhileStatement(ctx, stmt) {
    let builder = ctx.builder;
    let loopBlock = irBuilderAddBlock(builder, "while_cond");
    let bodyBlock = irBuilderAddBlock(builder, "while_body");
    let exitBlock = irBuilderAddBlock(builder, "while_exit");

    // Push loop context for break/continue
    contextPushLoop(ctx, exitBlock, loopBlock, null);

    // Jump to condition check
    irBuilderEmitJump(builder, loopBlock);

    // Condition check
    irBuilderSetBlock(builder, loopBlock);
    let cond = lowerExpression(ctx, stmt.test);
    irBuilderEmitJumpIfFalse(builder, cond, exitBlock);
    irBuilderEmitJump(builder, bodyBlock);

    // Body
    irBuilderSetBlock(builder, bodyBlock);
    if (stmt.body.type == "BlockStatement") {
        lowerBlockStatement(ctx, stmt.body);
    } else {
        lowerStatement(ctx, stmt.body);
    }
    irBuilderEmitJump(builder, loopBlock);

    // Pop loop context
    contextPopLoop(ctx);

    // Continue after loop
    irBuilderSetBlock(builder, exitBlock);
}

// Lower for statement
function lowerForStatement(ctx, stmt) {
    let builder = ctx.builder;

    // Initialize
    if (stmt.init != null) {
        if (stmt.init.type == "VariableDeclaration") {
            lowerVariableDeclaration(ctx, stmt.init);
        } else {
            lowerExpression(ctx, stmt.init);
        }
    }

    let loopBlock = irBuilderAddBlock(builder, "for_cond");
    let bodyBlock = irBuilderAddBlock(builder, "for_body");
    let updateBlock = irBuilderAddBlock(builder, "for_update");
    let exitBlock = irBuilderAddBlock(builder, "for_exit");

    // Push loop context for break/continue (continue goes to update, not cond)
    contextPushLoop(ctx, exitBlock, updateBlock, null);

    // Jump to condition check
    irBuilderEmitJump(builder, loopBlock);

    // Condition check
    irBuilderSetBlock(builder, loopBlock);
    if (stmt.test != null) {
        let cond = lowerExpression(ctx, stmt.test);
        irBuilderEmitJumpIfFalse(builder, cond, exitBlock);
    }
    irBuilderEmitJump(builder, bodyBlock);

    // Body
    irBuilderSetBlock(builder, bodyBlock);
    if (stmt.body.type == "BlockStatement") {
        lowerBlockStatement(ctx, stmt.body);
    } else {
        lowerStatement(ctx, stmt.body);
    }
    irBuilderEmitJump(builder, updateBlock);

    // Update
    irBuilderSetBlock(builder, updateBlock);
    if (stmt.update != null) {
        lowerExpression(ctx, stmt.update);
    }
    irBuilderEmitJump(builder, loopBlock);

    // Pop loop context
    contextPopLoop(ctx);

    // Continue after loop
    irBuilderSetBlock(builder, exitBlock);
}

// Lower do-while statement
function lowerDoWhileStatement(ctx, stmt) {
    let builder = ctx.builder;
    let bodyBlock = irBuilderAddBlock(builder, "dowhile_body");
    let condBlock = irBuilderAddBlock(builder, "dowhile_cond");
    let exitBlock = irBuilderAddBlock(builder, "dowhile_exit");

    // Push loop context for break/continue (continue goes to condition)
    contextPushLoop(ctx, exitBlock, condBlock, null);

    // Jump to body (execute at least once)
    irBuilderEmitJump(builder, bodyBlock);

    // Body
    irBuilderSetBlock(builder, bodyBlock);
    if (stmt.body.type == "BlockStatement") {
        lowerBlockStatement(ctx, stmt.body);
    } else {
        lowerStatement(ctx, stmt.body);
    }
    irBuilderEmitJump(builder, condBlock);

    // Condition check
    irBuilderSetBlock(builder, condBlock);
    let cond = lowerExpression(ctx, stmt.test);
    irBuilderEmitJumpIfFalse(builder, cond, exitBlock);
    irBuilderEmitJump(builder, bodyBlock);

    // Pop loop context
    contextPopLoop(ctx);

    // Continue after loop
    irBuilderSetBlock(builder, exitBlock);
}

// Lower break statement
function lowerBreakStatement(ctx, stmt) {
    let label = stmt.label;
    if (label != null && typeof label === "object") {
        label = label.name;
    }
    let loop = contextFindLoop(ctx, label);
    if (loop != null) {
        irBuilderEmitJump(ctx.builder, loop.breakBlock);
    }
}

// Lower continue statement
function lowerContinueStatement(ctx, stmt) {
    let label = stmt.label;
    if (label != null && typeof label === "object") {
        label = label.name;
    }
    let loop = contextFindLoop(ctx, label);
    if (loop != null) {
        irBuilderEmitJump(ctx.builder, loop.continueBlock);
    }
}

// Lower throw statement
function lowerThrowStatement(ctx, stmt) {
    // Lower the exception value
    let valueReg = lowerExpression(ctx, stmt.argument);
    // For now, emit as a return with error flag
    // In a full implementation, this would unwind the stack
    irBuilderEmitReturn(ctx.builder, valueReg);
}

// Lower try statement
function lowerTryStatement(ctx, stmt) {
    // Basic try/catch lowering (without full exception handling)
    // This lowers try block, and if there's a catch, sets up the handler
    let builder = ctx.builder;

    let tryBlock = irBuilderAddBlock(builder, "try_body");
    let catchBlock = null;
    let finallyBlock = null;
    let exitBlock = irBuilderAddBlock(builder, "try_exit");

    if (stmt.handler != null) {
        catchBlock = irBuilderAddBlock(builder, "catch_body");
    }
    if (stmt.finalizer != null) {
        finallyBlock = irBuilderAddBlock(builder, "finally_body");
    }

    // Jump to try block
    irBuilderEmitJump(builder, tryBlock);

    // Try body
    irBuilderSetBlock(builder, tryBlock);
    if (stmt.block != null) {
        lowerBlockStatement(ctx, stmt.block);
    }
    // Jump to finally or exit
    if (finallyBlock != null) {
        irBuilderEmitJump(builder, finallyBlock);
    } else {
        irBuilderEmitJump(builder, exitBlock);
    }

    // Catch handler (if present)
    if (catchBlock != null && stmt.handler != null) {
        irBuilderSetBlock(builder, catchBlock);
        // Declare the catch parameter if present
        if (stmt.handler.param != null) {
            let paramName = stmt.handler.param.name;
            if (paramName == null && typeof stmt.handler.param === "string") {
                paramName = stmt.handler.param;
            }
            if (paramName != null) {
                let slot = contextDeclareVariable(ctx, paramName);
                ctx.builder.currentFunction.locals.push({
                    index: slot,
                    name: paramName,
                    type: IrType.ANY
                });
            }
        }
        // Lower catch body
        if (stmt.handler.body != null) {
            lowerBlockStatement(ctx, stmt.handler.body);
        }
        if (finallyBlock != null) {
            irBuilderEmitJump(builder, finallyBlock);
        } else {
            irBuilderEmitJump(builder, exitBlock);
        }
    }

    // Finally block (if present)
    if (finallyBlock != null && stmt.finalizer != null) {
        irBuilderSetBlock(builder, finallyBlock);
        lowerBlockStatement(ctx, stmt.finalizer);
        irBuilderEmitJump(builder, exitBlock);
    }

    // Continue after try/catch/finally
    irBuilderSetBlock(builder, exitBlock);
}

// Lower an expression and return the register holding the result
function lowerExpression(ctx, node) {
    let builder = ctx.builder;

    if (node.type == "Literal" || node.type == "NumericLiteral") {
        return irBuilderEmitConst(builder, node.value);
    }

    if (node.type == "StringLiteral") {
        return irBuilderEmitConstString(builder, node.value);
    }

    if (node.type == "BooleanLiteral") {
        return irBuilderEmitConst(builder, node.value ? 1 : 0);
    }

    if (node.type == "Identifier") {
        let slot = contextLookupVariable(ctx, node.name);
        if (slot >= 0) {
            return irBuilderEmitLoadLocal(builder, slot);
        }
        // Global/unknown variable - emit as constant for now
        return irBuilderEmitConstString(builder, node.name);
    }

    if (node.type == "BinaryExpression") {
        let left = lowerExpression(ctx, node.left);
        let right = lowerExpression(ctx, node.right);
        let opcode = getIrOpCodeForBinaryOp(node.operator);
        return irBuilderEmitBinaryOp(builder, opcode, left, right);
    }

    if (node.type == "UnaryExpression") {
        let arg = lowerExpression(ctx, node.argument);
        if (node.operator == "-") {
            return irBuilderEmitBinaryOp(builder, IrOpCode.NEG, arg, 0);
        }
        if (node.operator == "!") {
            return irBuilderEmitBinaryOp(builder, IrOpCode.NOT, arg, 0);
        }
        return arg;
    }

    if (node.type == "AssignmentExpression") {
        let valueReg = lowerExpression(ctx, node.right);

        if (node.left.type == "Identifier") {
            let slot = contextLookupVariable(ctx, node.left.name);
            if (slot >= 0) {
                irBuilderEmitStoreLocal(builder, slot, valueReg);
            }
        } else if (node.left.type == "MemberExpression") {
            let objReg = lowerExpression(ctx, node.left.object);
            if (node.left.computed) {
                // obj[index] = value
                let indexReg = lowerExpression(ctx, node.left.property);
                irBuilderEmitStoreElement(builder, objReg, indexReg, valueReg);
            } else {
                // obj.prop = value
                let propName = node.left.property.name;
                if (propName == null) {
                    propName = String(node.left.property);
                }
                irBuilderEmitStoreProp(builder, objReg, propName, valueReg);
            }
        }

        return valueReg;
    }

    if (node.type == "UpdateExpression") {
        // ++x or x++
        if (node.argument.type == "Identifier") {
            let slot = contextLookupVariable(ctx, node.argument.name);
            if (slot >= 0) {
                let currentVal = irBuilderEmitLoadLocal(builder, slot);
                let one = irBuilderEmitConst(builder, 1);
                let newVal;
                if (node.operator == "++") {
                    newVal = irBuilderEmitAdd(builder, currentVal, one);
                } else {
                    newVal = irBuilderEmitSub(builder, currentVal, one);
                }
                irBuilderEmitStoreLocal(builder, slot, newVal);

                if (node.prefix) {
                    return newVal;
                } else {
                    return currentVal;
                }
            }
        }
        return irBuilderEmitConst(builder, 0);
    }

    if (node.type == "CallExpression") {
        // Lower arguments first
        let argc = node.arguments.length;
        let i = 0;
        while (i < argc) {
            lowerExpression(ctx, node.arguments[i]);
            i = i + 1;
        }

        // Lower callee
        let calleeReg = lowerExpression(ctx, node.callee);
        return irBuilderEmitCall(builder, calleeReg, argc);
    }

    if (node.type == "MemberExpression") {
        let objReg = lowerExpression(ctx, node.object);
        if (node.computed) {
            // obj[index] - computed property access
            let indexReg = lowerExpression(ctx, node.property);
            return irBuilderEmitLoadElement(builder, objReg, indexReg);
        } else {
            // obj.prop - dot notation
            let propName = node.property.name;
            if (propName == null && node.property.type == "Identifier") {
                propName = node.property.name;
            }
            if (propName == null) {
                propName = String(node.property);
            }
            return irBuilderEmitLoadProp(builder, objReg, propName);
        }
    }

    if (node.type == "ConditionalExpression") {
        // Ternary: test ? consequent : alternate
        let testReg = lowerExpression(ctx, node.test);

        let thenBlock = irBuilderAddBlock(builder, "ternary_then");
        let elseBlock = irBuilderAddBlock(builder, "ternary_else");
        let mergeBlock = irBuilderAddBlock(builder, "ternary_merge");

        // Allocate a temporary slot to hold the result
        let resultSlot = contextDeclareVariable(ctx, "__ternary_result");
        ctx.builder.currentFunction.locals.push({
            index: resultSlot,
            name: "__ternary_result",
            type: IrType.ANY
        });

        irBuilderEmitJumpIfFalse(builder, testReg, elseBlock);
        irBuilderEmitJump(builder, thenBlock);

        // Then branch - store result
        irBuilderSetBlock(builder, thenBlock);
        let thenVal = lowerExpression(ctx, node.consequent);
        irBuilderEmitStoreLocal(builder, resultSlot, thenVal);
        irBuilderEmitJump(builder, mergeBlock);

        // Else branch - store result
        irBuilderSetBlock(builder, elseBlock);
        let elseVal = lowerExpression(ctx, node.alternate);
        irBuilderEmitStoreLocal(builder, resultSlot, elseVal);
        irBuilderEmitJump(builder, mergeBlock);

        // Merge block - load result
        irBuilderSetBlock(builder, mergeBlock);
        return irBuilderEmitLoadLocal(builder, resultSlot);
    }

    if (node.type == "ArrayExpression") {
        // Create array
        let dest = allocateRegister(builder.ra);
        let elemCount = 0;
        if (node.elements != null) {
            elemCount = node.elements.length;
        }
        emitIrOp(builder.currentBlock, IrOpCode.NEW_ARRAY, dest, [], elemCount);

        // Initialize elements
        if (node.elements != null) {
            let i = 0;
            while (i < node.elements.length) {
                let elem = node.elements[i];
                if (elem != null) {
                    let indexReg = irBuilderEmitConst(builder, i);
                    let valueReg = lowerExpression(ctx, elem);
                    irBuilderEmitStoreElement(builder, dest, indexReg, valueReg);
                }
                i = i + 1;
            }
        }
        return dest;
    }

    if (node.type == "ObjectExpression") {
        // Create object
        let dest = allocateRegister(builder.ra);
        emitIrOp(builder.currentBlock, IrOpCode.NEW_OBJECT, dest, [], null);

        // Initialize properties
        if (node.properties != null) {
            let i = 0;
            while (i < node.properties.length) {
                let prop = node.properties[i];
                let propName = null;

                // Get property key name
                if (prop.key != null) {
                    if (prop.key.type == "Identifier") {
                        propName = prop.key.name;
                    } else if (prop.key.type == "Literal" || prop.key.type == "StringLiteral") {
                        propName = String(prop.key.value);
                    }
                }

                if (propName != null && prop.value != null) {
                    let valueReg = lowerExpression(ctx, prop.value);
                    irBuilderEmitStoreProp(builder, dest, propName, valueReg);
                }
                i = i + 1;
            }
        }
        return dest;
    }

    if (node.type == "ArrowFunctionExpression" || node.type == "FunctionExpression") {
        // Generate a unique name for the anonymous function
        let funcName = "__anon_" + ctx.nextSlot;
        ctx.nextSlot = ctx.nextSlot + 1;

        // Lower the function as a separate declaration
        let funcNode = {
            type: "FunctionDeclaration",
            name: funcName,
            params: node.params,
            body: node.body,
            returnType: node.returnType
        };

        // Save current function context
        let savedFunc = builder.currentFunction;
        let savedBlock = builder.currentBlock;

        // Lower the function
        lowerFunctionDeclarationFull(builder, funcNode);

        // Restore context
        builder.currentFunction = savedFunc;
        builder.currentBlock = savedBlock;

        // Return reference to the function (as a string constant for now)
        return irBuilderEmitConstString(builder, funcName);
    }

    // Default: return zero
    return irBuilderEmitConst(builder, 0);
}

// Map binary operators to IR opcodes
function getIrOpCodeForBinaryOp(operator) {
    if (operator == "+") return IrOpCode.ADD;
    if (operator == "-") return IrOpCode.SUB;
    if (operator == "*") return IrOpCode.MUL;
    if (operator == "/") return IrOpCode.DIV;
    if (operator == "%") return IrOpCode.MOD;
    if (operator == "==") return IrOpCode.EQ;
    if (operator == "===") return IrOpCode.EQ;
    if (operator == "!=") return IrOpCode.NE;
    if (operator == "!==") return IrOpCode.NE;
    if (operator == "<") return IrOpCode.LT;
    if (operator == ">") return IrOpCode.GT;
    if (operator == "<=") return IrOpCode.LE;
    if (operator == ">=") return IrOpCode.GE;
    if (operator == "&&") return IrOpCode.AND;
    if (operator == "||") return IrOpCode.OR;
    return IrOpCode.ADD;
}

// Convert type annotation to IR type
function irTypeFromAnnotation(annotation) {
    if (annotation == null) {
        return IrType.ANY;
    }
    let kind = annotation.typeKind;
    if (kind == null) kind = annotation;
    if (kind == "number") return IrType.NUMBER;
    if (kind == "string") return IrType.STRING;
    if (kind == "boolean") return IrType.BOOLEAN;
    if (kind == "any") return IrType.ANY;
    if (kind == "void") return IrType.VOID;
    if (kind == "never") return IrType.NEVER;
    if (kind == "object") return IrType.OBJECT;
    if (kind == "function") return IrType.FUNCTION;
    return IrType.ANY;
}

// ============================================================================
// Module Building
// ============================================================================

function irBuilderFinish(builder) {
    let module = {
        version: 1,
        abi_version: 1,
        functions: builder.functions
    };
    return module;
}

console.log("IR builder loaded");
