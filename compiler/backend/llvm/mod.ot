// ============================================================================
// LLVM IR Text Emitter for tscl Compiler
// ============================================================================
// Generates LLVM IR text (.ll files) from tscl SSA IR

require ./runtime;
require ./types;

// ============================================================================
// LLVM Emitter State
// ============================================================================

interface LlvmEmitter {
    output: string[];
    regCounter: number;
    blockCounter: number;
    stringConstants: { value: string, id: number }[];
    currentFunction: string;
    regMap: { [key: number]: string };
    localSlots: string[];
}

function createLlvmEmitter(): LlvmEmitter {
    return {
        output: [],
        regCounter: 0,
        blockCounter: 0,
        stringConstants: [],
        currentFunction: "",
        regMap: {},
        localSlots: []
    };
}

// Register a string constant and return its global name
function registerStringConstant(emitter: LlvmEmitter, value: string): string {
    // Check if string already exists
    let i = 0;
    while (i < emitter.stringConstants.length) {
        if (emitter.stringConstants[i].value == value) {
            return "@.str." + String(emitter.stringConstants[i].id);
        }
        i = i + 1;
    }
    // Add new string constant
    let id = emitter.stringConstants.length;
    emitter.stringConstants.push({ value: value, id: id });
    return "@.str." + String(id);
}

// Escape a string for LLVM IR (convert to C-style escapes)
function escapeStringForLlvm(str: string): string {
    let result = "";
    let i = 0;
    while (i < str.length) {
        let c = str[i];
        if (c == "\\") {
            result = result + "\\5C";
        } else if (c == "\"") {
            result = result + "\\22";
        } else if (c == "\n") {
            result = result + "\\0A";
        } else if (c == "\r") {
            result = result + "\\0D";
        } else if (c == "\t") {
            result = result + "\\09";
        } else {
            result = result + c;
        }
        i = i + 1;
    }
    return result;
}

// ============================================================================
// Helper Functions
// ============================================================================

function emit(emitter: LlvmEmitter, line: string): void {
    emitter.output.push(line);
    return;
}

function allocReg(emitter: LlvmEmitter): string {
    let reg = "%r" + String(emitter.regCounter);
    emitter.regCounter = emitter.regCounter + 1;
    return reg;
}

function getBlockLabel(blockLabel: string): string {
    return blockLabel;
}

function getRegForValue(emitter: LlvmEmitter, valueId: number): string {
    let key = "v" + String(valueId);
    if (emitter.regMap[key] != null) {
        return emitter.regMap[key];
    }
    // Value not found - this shouldn't happen in valid IR
    return "%undefined_" + String(valueId);
}

function setRegForValue(emitter: LlvmEmitter, valueId: number, reg: string): void {
    let key = "v" + String(valueId);
    emitter.regMap[key] = reg;
    return;
}

// Format a double value for LLVM IR
function formatDouble(value: number): string {
    // Convert to string
    let str = String(value);
    // Ensure it has a decimal point for LLVM double syntax
    let hasDot = false;
    let hasE = false;
    let i = 0;
    while (i < str.length) {
        let c = str[i];
        if (c == ".") {
            hasDot = true;
        }
        if (c == "e" || c == "E") {
            hasE = true;
        }
        i = i + 1;
    }
    if (!hasDot && !hasE) {
        str = str + ".0";
    }
    return str;
}

// ============================================================================
// Module Emission
// ============================================================================

// Pre-scan IR to collect all string constants
function collectStringConstants(emitter: LlvmEmitter, irModule: IrModule): void {
    let i = 0;
    while (i < irModule.functions.length) {
        let func = irModule.functions[i];
        let j = 0;
        while (j < func.blocks.length) {
            let block = func.blocks[j];
            let k = 0;
            while (k < block.ops.length) {
                let inst = block.ops[k];
                // Check for CONST with string value
                if (inst.opcode == 0 && typeof inst.immediate == "string") {
                    registerStringConstant(emitter, inst.immediate);
                }
                // Check for LOAD_PROP and STORE_PROP property names
                // LOAD_PROP = 20, STORE_PROP = 21
                if ((inst.opcode == 20 || inst.opcode == 21) && typeof inst.immediate == "string") {
                    // Don't register "length" as it's handled specially
                    if (inst.immediate != "length") {
                        registerStringConstant(emitter, inst.immediate);
                    }
                }
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Emit all collected string constants
function emitStringConstants(emitter: LlvmEmitter): void {
    let i = 0;
    while (i < emitter.stringConstants.length) {
        let sc = emitter.stringConstants[i];
        let escaped = escapeStringForLlvm(sc.value);
        let len = sc.value.length + 1;  // +1 for null terminator
        emit(emitter, "@.str." + String(sc.id) + " = private unnamed_addr constant [" + String(len) + " x i8] c\"" + escaped + "\\00\"");
        i = i + 1;
    }
}

function emitLlvmModule(irModule: IrModule): string {
    let emitter = createLlvmEmitter();

    // Pre-scan to collect string constants
    collectStringConstants(emitter, irModule);

    // Emit header
    emit(emitter, "; ============================================================");
    emit(emitter, "; LLVM IR generated by tscl compiler");
    emit(emitter, "; ============================================================");
    emit(emitter, "");

    // Emit target triple (arm64 for Apple Silicon, x86_64 for Intel)
    emit(emitter, "target triple = \"arm64-apple-darwin\"");
    emit(emitter, "");

    // Emit runtime declarations (libc functions)
    emit(emitter, "; External declarations");
    emit(emitter, "declare i32 @printf(i8*, ...)");
    emit(emitter, "declare i32 @sprintf(i8*, i8*, ...)");
    emit(emitter, "declare i8* @malloc(i64)");
    emit(emitter, "declare i64 @strlen(i8*)");
    emit(emitter, "declare i8* @strcpy(i8*, i8*)");
    emit(emitter, "declare i8* @strcat(i8*, i8*)");
    emit(emitter, "");

    // Emit string constants
    emit(emitter, "; String constants");
    emit(emitter, "@.fmt_num = private unnamed_addr constant [4 x i8] c\"%g\\0A\\00\"");
    emit(emitter, "@.fmt_str = private unnamed_addr constant [4 x i8] c\"%s\\0A\\00\"");
    emit(emitter, "@.fmt_num2str = private unnamed_addr constant [3 x i8] c\"%g\\00\"");  // for number-to-string
    emitStringConstants(emitter);
    emit(emitter, "");

    // Emit runtime function definitions (inline)
    emitRuntimeFunctions(emitter);

    // Emit all user functions
    let i = 0;
    while (i < irModule.functions.length) {
        emitLlvmFunction(emitter, irModule.functions[i]);
        i = i + 1;
    }

    // Emit main wrapper
    emitMainWrapper(emitter);

    // Join all output lines
    let result = "";
    let j = 0;
    while (j < emitter.output.length) {
        result = result + emitter.output[j] + "\n";
        j = j + 1;
    }

    return result;
}

// ============================================================================
// Runtime Functions
// ============================================================================

function emitRuntimeFunctions(emitter: LlvmEmitter): void {
    emit(emitter, "; ============================================================");
    emit(emitter, "; Runtime functions");
    emit(emitter, "; ============================================================");
    emit(emitter, "");

    // tscl_console_log - handles both numbers and strings
    // String tag: 0xFFFCxxxxxxxxxxxx (high 16 bits = 0xFFFC = 65532)
    // Numbers: IEEE 754 doubles
    emit(emitter, "define i64 @tscl_console_log(i64 %value) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Check if value is a string (high bits = 0xFFFC)");
    emit(emitter, "  %high = lshr i64 %value, 48");
    emit(emitter, "  %is_str = icmp eq i64 %high, 65532");  // 0xFFFC = 65532
    emit(emitter, "  br i1 %is_str, label %print_str, label %print_num");
    emit(emitter, "print_str:");
    emit(emitter, "  ; Extract pointer (mask off the tag)");
    emit(emitter, "  %ptr_int = and i64 %value, 281474976710655");  // 0x0000FFFFFFFFFFFF
    emit(emitter, "  %ptr = inttoptr i64 %ptr_int to i8*");
    emit(emitter, "  %fmt_s = getelementptr [4 x i8], [4 x i8]* @.fmt_str, i64 0, i64 0");
    emit(emitter, "  call i32 (i8*, ...) @printf(i8* %fmt_s, i8* %ptr)");
    emit(emitter, "  br label %done");
    emit(emitter, "print_num:");
    emit(emitter, "  %dval = bitcast i64 %value to double");
    emit(emitter, "  %fmt_n = getelementptr [4 x i8], [4 x i8]* @.fmt_num, i64 0, i64 0");
    emit(emitter, "  call i32 (i8*, ...) @printf(i8* %fmt_n, double %dval)");
    emit(emitter, "  br label %done");
    emit(emitter, "done:");
    emit(emitter, "  ret i64 9221120237041090561");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_num_to_str - convert a number to a string
    emit(emitter, "define i8* @tscl_num_to_str(i64 %num) {");
    emit(emitter, "entry:");
    emit(emitter, "  %buf = call i8* @malloc(i64 32)");  // 32 bytes should be enough for any double
    emit(emitter, "  %dval = bitcast i64 %num to double");
    emit(emitter, "  %fmt = getelementptr [3 x i8], [3 x i8]* @.fmt_num2str, i64 0, i64 0");
    emit(emitter, "  call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* %fmt, double %dval)");
    emit(emitter, "  ret i8* %buf");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_add_any - handles both number addition and string concatenation
    emit(emitter, "define i64 @tscl_add_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Check if either operand is a string (high 16 bits = 0xFFFC = 65532)");
    emit(emitter, "  %a_high = lshr i64 %a, 48");
    emit(emitter, "  %b_high = lshr i64 %b, 48");
    emit(emitter, "  %a_is_str = icmp eq i64 %a_high, 65532");
    emit(emitter, "  %b_is_str = icmp eq i64 %b_high, 65532");
    emit(emitter, "  %either_str = or i1 %a_is_str, %b_is_str");
    emit(emitter, "  br i1 %either_str, label %check_types, label %do_add");
    emit(emitter, "do_add:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fadd double %a_fp, %b_fp");
    emit(emitter, "  %result_num = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result_num");
    emit(emitter, "check_types:");
    emit(emitter, "  ; Get string pointer for a (convert if needed)");
    emit(emitter, "  br i1 %a_is_str, label %a_already_str, label %convert_a");
    emit(emitter, "a_already_str:");
    emit(emitter, "  %a_ptr_int1 = and i64 %a, 281474976710655");
    emit(emitter, "  %a_ptr1 = inttoptr i64 %a_ptr_int1 to i8*");
    emit(emitter, "  br label %got_a_ptr");
    emit(emitter, "convert_a:");
    emit(emitter, "  %a_ptr2 = call i8* @tscl_num_to_str(i64 %a)");
    emit(emitter, "  br label %got_a_ptr");
    emit(emitter, "got_a_ptr:");
    emit(emitter, "  %a_ptr = phi i8* [%a_ptr1, %a_already_str], [%a_ptr2, %convert_a]");
    emit(emitter, "  ; Get string pointer for b (convert if needed)");
    emit(emitter, "  br i1 %b_is_str, label %b_already_str, label %convert_b");
    emit(emitter, "b_already_str:");
    emit(emitter, "  %b_ptr_int1 = and i64 %b, 281474976710655");
    emit(emitter, "  %b_ptr1 = inttoptr i64 %b_ptr_int1 to i8*");
    emit(emitter, "  br label %got_b_ptr");
    emit(emitter, "convert_b:");
    emit(emitter, "  %b_ptr2 = call i8* @tscl_num_to_str(i64 %b)");
    emit(emitter, "  br label %got_b_ptr");
    emit(emitter, "got_b_ptr:");
    emit(emitter, "  %b_ptr = phi i8* [%b_ptr1, %b_already_str], [%b_ptr2, %convert_b]");
    emit(emitter, "  ; Concatenate the strings");
    emit(emitter, "  %a_len = call i64 @strlen(i8* %a_ptr)");
    emit(emitter, "  %b_len = call i64 @strlen(i8* %b_ptr)");
    emit(emitter, "  %total_len = add i64 %a_len, %b_len");
    emit(emitter, "  %alloc_len = add i64 %total_len, 1");
    emit(emitter, "  %new_buf = call i8* @malloc(i64 %alloc_len)");
    emit(emitter, "  call i8* @strcpy(i8* %new_buf, i8* %a_ptr)");
    emit(emitter, "  call i8* @strcat(i8* %new_buf, i8* %b_ptr)");
    emit(emitter, "  ; Tag the result as a string");
    emit(emitter, "  %new_int = ptrtoint i8* %new_buf to i64");
    emit(emitter, "  %new_masked = and i64 %new_int, 281474976710655");
    emit(emitter, "  %result_str = or i64 %new_masked, 18445618173802708992");
    emit(emitter, "  ret i64 %result_str");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_sub_any
    emit(emitter, "define i64 @tscl_sub_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fsub double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_mul_any
    emit(emitter, "define i64 @tscl_mul_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fmul double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_div_any
    emit(emitter, "define i64 @tscl_div_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fdiv double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_mod_any
    emit(emitter, "define i64 @tscl_mod_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = frem double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_neg
    emit(emitter, "define i64 @tscl_neg(i64 %a) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %result_fp = fsub double 0.0, %a_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_lt_any
    emit(emitter, "define i64 @tscl_lt_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp olt double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_le_any
    emit(emitter, "define i64 @tscl_le_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp ole double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_gt_any
    emit(emitter, "define i64 @tscl_gt_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp ogt double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_ge_any
    emit(emitter, "define i64 @tscl_ge_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp oge double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_eq_any
    emit(emitter, "define i64 @tscl_eq_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp oeq double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_ne_any
    emit(emitter, "define i64 @tscl_ne_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp one double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // ============================================================
    // Array runtime functions
    // ============================================================
    // Array layout: [capacity: i64, length: i64, elements: i64*]
    // Array tag: 0xFFFB (65531) in high 16 bits
    // 0xFFFB000000000000 = 18444492273895866368

    // tscl_alloc_array - allocate an array with given initial capacity
    emit(emitter, "define i64 @tscl_alloc_array(i64 %cap) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Allocate: 2 header i64s + cap elements");
    emit(emitter, "  %header_size = add i64 16, 0");  // 2 * 8 bytes for capacity and length
    emit(emitter, "  %elem_bytes = mul i64 %cap, 8");
    emit(emitter, "  %total_size = add i64 %header_size, %elem_bytes");
    emit(emitter, "  %ptr = call i8* @malloc(i64 %total_size)");
    emit(emitter, "  %arr = bitcast i8* %ptr to i64*");
    emit(emitter, "  ; Store capacity at offset 0");
    emit(emitter, "  store i64 %cap, i64* %arr");
    emit(emitter, "  ; Store length (0) at offset 1");
    emit(emitter, "  %len_ptr = getelementptr i64, i64* %arr, i64 1");
    emit(emitter, "  store i64 0, i64* %len_ptr");
    emit(emitter, "  ; Tag pointer as array (0xFFFB prefix)");
    emit(emitter, "  %ptr_int = ptrtoint i64* %arr to i64");
    emit(emitter, "  %masked = and i64 %ptr_int, 281474976710655");  // 0x0000FFFFFFFFFFFF
    emit(emitter, "  %tagged = or i64 %masked, 18444492273895866368");  // 0xFFFB...
    emit(emitter, "  ret i64 %tagged");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_array_set - set element at index
    emit(emitter, "define void @tscl_array_set(i64 %arr_tagged, i64 %idx_val, i64 %value) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Extract array pointer");
    emit(emitter, "  %ptr_int = and i64 %arr_tagged, 281474976710655");
    emit(emitter, "  %arr = inttoptr i64 %ptr_int to i64*");
    emit(emitter, "  ; Convert index from NaN-boxed double to integer");
    emit(emitter, "  %idx_fp = bitcast i64 %idx_val to double");
    emit(emitter, "  %idx = fptosi double %idx_fp to i64");
    emit(emitter, "  ; Elements start at offset 2 (after capacity and length)");
    emit(emitter, "  %elem_offset = add i64 %idx, 2");
    emit(emitter, "  %elem_ptr = getelementptr i64, i64* %arr, i64 %elem_offset");
    emit(emitter, "  store i64 %value, i64* %elem_ptr");
    emit(emitter, "  ; Update length if needed (idx + 1 > length)");
    emit(emitter, "  %len_ptr = getelementptr i64, i64* %arr, i64 1");
    emit(emitter, "  %curr_len = load i64, i64* %len_ptr");
    emit(emitter, "  %new_len = add i64 %idx, 1");
    emit(emitter, "  %need_update = icmp sgt i64 %new_len, %curr_len");
    emit(emitter, "  br i1 %need_update, label %update_len, label %done");
    emit(emitter, "update_len:");
    emit(emitter, "  store i64 %new_len, i64* %len_ptr");
    emit(emitter, "  br label %done");
    emit(emitter, "done:");
    emit(emitter, "  ret void");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_array_get - get element at index
    emit(emitter, "define i64 @tscl_array_get(i64 %arr_tagged, i64 %idx_val) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Extract array pointer");
    emit(emitter, "  %ptr_int = and i64 %arr_tagged, 281474976710655");
    emit(emitter, "  %arr = inttoptr i64 %ptr_int to i64*");
    emit(emitter, "  ; Convert index from NaN-boxed double to integer");
    emit(emitter, "  %idx_fp = bitcast i64 %idx_val to double");
    emit(emitter, "  %idx = fptosi double %idx_fp to i64");
    emit(emitter, "  ; Elements start at offset 2");
    emit(emitter, "  %elem_offset = add i64 %idx, 2");
    emit(emitter, "  %elem_ptr = getelementptr i64, i64* %arr, i64 %elem_offset");
    emit(emitter, "  %value = load i64, i64* %elem_ptr");
    emit(emitter, "  ret i64 %value");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_array_length - get array length
    emit(emitter, "define i64 @tscl_array_length(i64 %arr_tagged) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Extract array pointer");
    emit(emitter, "  %ptr_int = and i64 %arr_tagged, 281474976710655");
    emit(emitter, "  %arr = inttoptr i64 %ptr_int to i64*");
    emit(emitter, "  ; Length is at offset 1");
    emit(emitter, "  %len_ptr = getelementptr i64, i64* %arr, i64 1");
    emit(emitter, "  %len = load i64, i64* %len_ptr");
    emit(emitter, "  ; Convert to NaN-boxed double");
    emit(emitter, "  %len_fp = sitofp i64 %len to double");
    emit(emitter, "  %result = bitcast double %len_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_array_push - push element to array (returns new length)
    emit(emitter, "define i64 @tscl_array_push(i64 %arr_tagged, i64 %value) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Extract array pointer");
    emit(emitter, "  %ptr_int = and i64 %arr_tagged, 281474976710655");
    emit(emitter, "  %arr = inttoptr i64 %ptr_int to i64*");
    emit(emitter, "  ; Get current length");
    emit(emitter, "  %len_ptr = getelementptr i64, i64* %arr, i64 1");
    emit(emitter, "  %len = load i64, i64* %len_ptr");
    emit(emitter, "  ; Store element at length index (offset 2 + len)");
    emit(emitter, "  %elem_offset = add i64 %len, 2");
    emit(emitter, "  %elem_ptr = getelementptr i64, i64* %arr, i64 %elem_offset");
    emit(emitter, "  store i64 %value, i64* %elem_ptr");
    emit(emitter, "  ; Increment length");
    emit(emitter, "  %new_len = add i64 %len, 1");
    emit(emitter, "  store i64 %new_len, i64* %len_ptr");
    emit(emitter, "  ; Return new length as NaN-boxed double");
    emit(emitter, "  %len_fp = sitofp i64 %new_len to double");
    emit(emitter, "  %result = bitcast double %len_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // ============================================================
    // Object runtime functions
    // ============================================================
    // Object layout: [capacity: i64, count: i64, entries: (key, value)*]
    // Each entry is 2 i64s: key (string tagged pointer), value (any tagged value)
    // Object tag: 0xFFFA (65530) in high 16 bits
    // 0xFFFA000000000000 = 18443366373989023744

    // tscl_alloc_object - allocate an object with given capacity
    emit(emitter, "define i64 @tscl_alloc_object(i64 %cap) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Allocate: 2 header i64s + cap * 2 (key-value pairs)");
    emit(emitter, "  %header_size = add i64 16, 0");
    emit(emitter, "  %entry_count = mul i64 %cap, 2");
    emit(emitter, "  %entry_bytes = mul i64 %entry_count, 8");
    emit(emitter, "  %total_size = add i64 %header_size, %entry_bytes");
    emit(emitter, "  %ptr = call i8* @malloc(i64 %total_size)");
    emit(emitter, "  %obj = bitcast i8* %ptr to i64*");
    emit(emitter, "  ; Store capacity at offset 0");
    emit(emitter, "  store i64 %cap, i64* %obj");
    emit(emitter, "  ; Store count (0) at offset 1");
    emit(emitter, "  %count_ptr = getelementptr i64, i64* %obj, i64 1");
    emit(emitter, "  store i64 0, i64* %count_ptr");
    emit(emitter, "  ; Tag pointer as object (0xFFFA prefix)");
    emit(emitter, "  %ptr_int = ptrtoint i64* %obj to i64");
    emit(emitter, "  %masked = and i64 %ptr_int, 281474976710655");
    emit(emitter, "  %tagged = or i64 %masked, 18443366373989023744");
    emit(emitter, "  ret i64 %tagged");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_object_set - set a property by string key
    emit(emitter, "define void @tscl_object_set(i64 %obj_tagged, i64 %key, i64 %value) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Extract object pointer");
    emit(emitter, "  %ptr_int = and i64 %obj_tagged, 281474976710655");
    emit(emitter, "  %obj = inttoptr i64 %ptr_int to i64*");
    emit(emitter, "  ; Get count");
    emit(emitter, "  %count_ptr = getelementptr i64, i64* %obj, i64 1");
    emit(emitter, "  %count = load i64, i64* %count_ptr");
    emit(emitter, "  ; Search for existing key");
    emit(emitter, "  br label %search_loop");
    emit(emitter, "search_loop:");
    emit(emitter, "  %i = phi i64 [0, %entry], [%i_next, %search_continue]");
    emit(emitter, "  %found = icmp slt i64 %i, %count");
    emit(emitter, "  br i1 %found, label %check_key, label %not_found");
    emit(emitter, "check_key:");
    emit(emitter, "  ; Key is at offset 2 + i*2");
    emit(emitter, "  %key_offset = mul i64 %i, 2");
    emit(emitter, "  %key_idx = add i64 %key_offset, 2");
    emit(emitter, "  %key_ptr = getelementptr i64, i64* %obj, i64 %key_idx");
    emit(emitter, "  %stored_key = load i64, i64* %key_ptr");
    emit(emitter, "  %key_match = icmp eq i64 %stored_key, %key");
    emit(emitter, "  br i1 %key_match, label %update_value, label %search_continue");
    emit(emitter, "search_continue:");
    emit(emitter, "  %i_next = add i64 %i, 1");
    emit(emitter, "  br label %search_loop");
    emit(emitter, "update_value:");
    emit(emitter, "  ; Value is at offset 2 + i*2 + 1");
    emit(emitter, "  %val_idx = add i64 %key_idx, 1");
    emit(emitter, "  %val_ptr = getelementptr i64, i64* %obj, i64 %val_idx");
    emit(emitter, "  store i64 %value, i64* %val_ptr");
    emit(emitter, "  ret void");
    emit(emitter, "not_found:");
    emit(emitter, "  ; Add new entry at count position");
    emit(emitter, "  %new_key_offset = mul i64 %count, 2");
    emit(emitter, "  %new_key_idx = add i64 %new_key_offset, 2");
    emit(emitter, "  %new_key_ptr = getelementptr i64, i64* %obj, i64 %new_key_idx");
    emit(emitter, "  store i64 %key, i64* %new_key_ptr");
    emit(emitter, "  %new_val_idx = add i64 %new_key_idx, 1");
    emit(emitter, "  %new_val_ptr = getelementptr i64, i64* %obj, i64 %new_val_idx");
    emit(emitter, "  store i64 %value, i64* %new_val_ptr");
    emit(emitter, "  ; Increment count");
    emit(emitter, "  %new_count = add i64 %count, 1");
    emit(emitter, "  store i64 %new_count, i64* %count_ptr");
    emit(emitter, "  ret void");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_object_get - get a property by string key
    emit(emitter, "define i64 @tscl_object_get(i64 %obj_tagged, i64 %key) {");
    emit(emitter, "entry:");
    emit(emitter, "  ; Extract object pointer");
    emit(emitter, "  %ptr_int = and i64 %obj_tagged, 281474976710655");
    emit(emitter, "  %obj = inttoptr i64 %ptr_int to i64*");
    emit(emitter, "  ; Get count");
    emit(emitter, "  %count_ptr = getelementptr i64, i64* %obj, i64 1");
    emit(emitter, "  %count = load i64, i64* %count_ptr");
    emit(emitter, "  ; Search for key");
    emit(emitter, "  br label %search_loop");
    emit(emitter, "search_loop:");
    emit(emitter, "  %i = phi i64 [0, %entry], [%i_next, %search_continue]");
    emit(emitter, "  %in_bounds = icmp slt i64 %i, %count");
    emit(emitter, "  br i1 %in_bounds, label %check_key, label %not_found");
    emit(emitter, "check_key:");
    emit(emitter, "  ; Key is at offset 2 + i*2");
    emit(emitter, "  %key_offset = mul i64 %i, 2");
    emit(emitter, "  %key_idx = add i64 %key_offset, 2");
    emit(emitter, "  %key_ptr = getelementptr i64, i64* %obj, i64 %key_idx");
    emit(emitter, "  %stored_key = load i64, i64* %key_ptr");
    emit(emitter, "  %key_match = icmp eq i64 %stored_key, %key");
    emit(emitter, "  br i1 %key_match, label %found, label %search_continue");
    emit(emitter, "search_continue:");
    emit(emitter, "  %i_next = add i64 %i, 1");
    emit(emitter, "  br label %search_loop");
    emit(emitter, "found:");
    emit(emitter, "  ; Value is at offset 2 + i*2 + 1");
    emit(emitter, "  %val_idx = add i64 %key_idx, 1");
    emit(emitter, "  %val_ptr = getelementptr i64, i64* %obj, i64 %val_idx");
    emit(emitter, "  %value = load i64, i64* %val_ptr");
    emit(emitter, "  ret i64 %value");
    emit(emitter, "not_found:");
    emit(emitter, "  ; Return undefined");
    emit(emitter, "  ret i64 9221120237041090561");
    emit(emitter, "}");
    emit(emitter, "");

    return;
}

// ============================================================================
// Function Emission
// ============================================================================

function emitLlvmFunction(emitter: LlvmEmitter, func: IrFunction): void {
    // Reset state for new function
    emitter.regCounter = 0;
    emitter.regMap = {};
    emitter.localSlots = [];

    // Rename "main" to "script_main" to avoid collision with C main wrapper
    let funcName = func.name;
    if (funcName == "main") {
        funcName = "script_main";
    }
    emitter.currentFunction = funcName;

    // Build parameter list
    let params = "";
    let i = 0;
    while (i < func.params.length) {
        if (i > 0) {
            params = params + ", ";
        }
        let paramReg = "%p" + String(i);
        params = params + "i64 " + paramReg;
        // Map parameter to a register
        setRegForValue(emitter, i, paramReg);
        i = i + 1;
    }

    emit(emitter, "; ============================================================");
    emit(emitter, "; Function: " + funcName);
    emit(emitter, "; ============================================================");
    emit(emitter, "define i64 @" + funcName + "(" + params + ") {");

    // Emit entry block with local allocations
    emit(emitter, "entry:");

    // Allocate stack slots for locals
    let j = 0;
    while (j < func.locals.length) {
        let slotReg = "%local" + String(j);
        emit(emitter, "  " + slotReg + " = alloca i64");
        emitter.localSlots.push(slotReg);
        j = j + 1;
    }

    // Store parameters into their local slots
    let p = 0;
    while (p < func.params.length) {
        let paramReg = "%p" + String(p);
        let slotReg = "%local" + String(p);
        emit(emitter, "  store i64 " + paramReg + ", i64* " + slotReg);
        p = p + 1;
    }

    // Jump to first block
    if (func.blocks.length > 0) {
        emit(emitter, "  br label %" + func.entry_block.label);
    }

    // Emit all blocks
    let k = 0;
    while (k < func.blocks.length) {
        emitLlvmBlock(emitter, func.blocks[k]);
        k = k + 1;
    }

    emit(emitter, "}");
    emit(emitter, "");
    return;
}

// ============================================================================
// Block Emission
// ============================================================================

function emitLlvmBlock(emitter: LlvmEmitter, block: IrBlock): void {
    emit(emitter, block.label + ":");

    // Emit all instructions
    let i = 0;
    while (i < block.ops.length) {
        let inst = block.ops[i];
        let nextInst = null;
        if (i + 1 < block.ops.length) {
            nextInst = block.ops[i + 1];
        }

        // Check for JUMP_IF_FALSE + JUMP pattern (conditional branch)
        if (inst.opcode == 25 && nextInst != null && nextInst.opcode == 24) {
            // Combine into single conditional branch
            emitConditionalBranch(emitter, inst, nextInst);
            i = i + 2;  // Skip both instructions
        } else {
            emitLlvmInstruction(emitter, inst);
            i = i + 1;
        }
    }
    return;
}

// Emit a conditional branch from JUMP_IF_FALSE + JUMP pattern
function emitConditionalBranch(emitter: LlvmEmitter, jumpIfFalse: IrInstruction, jump: IrInstruction): void {
    let condReg = getRegForValue(emitter, jumpIfFalse.args[0]);
    let falseLabel = jumpIfFalse.label;  // Where to go if condition is false
    let trueLabel = jump.label;          // Where to go if condition is true

    // Check if condition is truthy (extract low bit for booleans, or check non-zero for numbers)
    let tmp1 = allocReg(emitter);
    let tmp2 = allocReg(emitter);

    // For NaN-boxed booleans: true = ...0001, false = ...0000
    // For numbers: need to check if non-zero
    // Simple approach: check if low bit is set (works for booleans)
    emit(emitter, "  " + tmp1 + " = and i64 " + condReg + ", 1");
    emit(emitter, "  " + tmp2 + " = icmp ne i64 " + tmp1 + ", 0");
    emit(emitter, "  br i1 " + tmp2 + ", label %" + trueLabel + ", label %" + falseLabel);
}

// ============================================================================
// Instruction Emission
// ============================================================================

function emitLlvmInstruction(emitter: LlvmEmitter, inst: IrInstruction): void {
    let opcode = inst.opcode;

    // CONST - load a constant value
    if (opcode == 0) {  // IrOpCode.CONST
        let dest = inst.dest;
        let value = inst.immediate;
        let reg = allocReg(emitter);

        // Check if value is a number
        if (typeof value == "number") {
            // Emit as double, then bitcast to i64
            let tmpReg = allocReg(emitter);
            let dblStr = formatDouble(value);
            emit(emitter, "  " + tmpReg + " = call i64 @tscl_box_number(double " + dblStr + ")");
            setRegForValue(emitter, dest, tmpReg);
        } else if (typeof value == "boolean") {
            // Boolean constant
            if (value) {
                emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");
            } else {
                emit(emitter, "  " + reg + " = add i64 0, 9221120237041090560");
            }
            setRegForValue(emitter, dest, reg);
        } else if (value == null) {
            // Undefined constant
            emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");
            setRegForValue(emitter, dest, reg);
        } else if (typeof value == "string") {
            // String constant - get pointer to the global string
            let strGlobal = registerStringConstant(emitter, value);
            let len = value.length + 1;
            let ptrReg = allocReg(emitter);
            // Get pointer to first character
            emit(emitter, "  " + ptrReg + " = getelementptr [" + String(len) + " x i8], [" + String(len) + " x i8]* " + strGlobal + ", i64 0, i64 0");
            // Convert pointer to i64 and tag it as string
            // We use negative NaN: 0xFFFC prefix (sign=1, exp=7FF, quiet=1, type=string)
            // 0xFFFC000000000000 = 18445618173802708992
            // Pointer goes in low 48 bits, tag in high 16
            let intReg = allocReg(emitter);
            emit(emitter, "  " + intReg + " = ptrtoint i8* " + ptrReg + " to i64");
            // Mask to 48 bits and add tag
            let maskedReg = allocReg(emitter);
            emit(emitter, "  " + maskedReg + " = and i64 " + intReg + ", 281474976710655");  // 0x0000FFFFFFFFFFFF
            emit(emitter, "  " + reg + " = or i64 " + maskedReg + ", 18445618173802708992");
            setRegForValue(emitter, dest, reg);
        } else {
            // Unknown type - use undefined
            emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");
            setRegForValue(emitter, dest, reg);
        }
        return;
    }

    // ADD
    if (opcode == 1) {  // IrOpCode.ADD
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_add_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // SUB
    if (opcode == 2) {  // IrOpCode.SUB
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_sub_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // MUL
    if (opcode == 3) {  // IrOpCode.MUL
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_mul_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // DIV
    if (opcode == 4) {  // IrOpCode.DIV
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_div_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // MOD
    if (opcode == 5) {  // IrOpCode.MOD
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_mod_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NEG
    if (opcode == 6) {  // IrOpCode.NEG
        let dest = inst.dest;
        let srcReg = getRegForValue(emitter, inst.args[0]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_neg(i64 " + srcReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NOT
    if (opcode == 7) {  // IrOpCode.NOT
        let dest = inst.dest;
        let srcReg = getRegForValue(emitter, inst.args[0]);
        let resultReg = allocReg(emitter);
        // NOT: check if value is falsy and return inverted boolean
        let tmp1 = allocReg(emitter);
        let tmp2 = allocReg(emitter);
        emit(emitter, "  " + tmp1 + " = and i64 " + srcReg + ", 1");
        emit(emitter, "  " + tmp2 + " = icmp eq i64 " + tmp1 + ", 0");
        emit(emitter, "  " + resultReg + " = select i1 " + tmp2 + ", i64 9221120237041090561, i64 9221120237041090560");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // EQ
    if (opcode == 8) {  // IrOpCode.EQ
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_eq_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NE
    if (opcode == 9) {  // IrOpCode.NE
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_ne_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // LT
    if (opcode == 10) {  // IrOpCode.LT
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_lt_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // GT
    if (opcode == 11) {  // IrOpCode.GT
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_gt_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // LE
    if (opcode == 12) {  // IrOpCode.LE
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_le_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // GE
    if (opcode == 13) {  // IrOpCode.GE
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_ge_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // AND (logical)
    if (opcode == 14) {  // IrOpCode.AND
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        // For AND, return left if falsy, else return right
        emit(emitter, "  " + resultReg + " = and i64 " + leftReg + ", " + rightReg);
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // OR (logical)
    if (opcode == 15) {  // IrOpCode.OR
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        // For OR, return left if truthy, else return right
        emit(emitter, "  " + resultReg + " = or i64 " + leftReg + ", " + rightReg);
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // LOAD (global)
    if (opcode == 16) {  // IrOpCode.LOAD
        let dest = inst.dest;
        let resultReg = allocReg(emitter);
        // Global loads return undefined for now
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE (global)
    if (opcode == 17) {  // IrOpCode.STORE
        // Global stores are no-ops for now
        return;
    }

    // LOAD_LOCAL
    if (opcode == 18) {  // IrOpCode.LOAD_LOCAL
        let dest = inst.dest;
        let slot = inst.args[0];
        // Allocate slot if it doesn't exist yet (shouldn't normally happen)
        while (emitter.localSlots.length <= slot) {
            let newSlotReg = "%local" + String(emitter.localSlots.length);
            emit(emitter, "  " + newSlotReg + " = alloca i64");
            emitter.localSlots.push(newSlotReg);
        }
        let slotReg = emitter.localSlots[slot];
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = load i64, i64* " + slotReg);
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE_LOCAL
    if (opcode == 19) {  // IrOpCode.STORE_LOCAL
        let slot = inst.args[0];
        let valueReg = getRegForValue(emitter, inst.args[1]);
        // Allocate slot if it doesn't exist yet
        while (emitter.localSlots.length <= slot) {
            let newSlotReg = "%local" + String(emitter.localSlots.length);
            emit(emitter, "  " + newSlotReg + " = alloca i64");
            emitter.localSlots.push(newSlotReg);
        }
        let slotReg = emitter.localSlots[slot];
        emit(emitter, "  store i64 " + valueReg + ", i64* " + slotReg);
        return;
    }

    // LOAD_PROP
    if (opcode == 20) {  // IrOpCode.LOAD_PROP
        let dest = inst.dest;
        let objReg = getRegForValue(emitter, inst.args[0]);
        let propName = inst.immediate;
        let resultReg = allocReg(emitter);

        // Handle "length" property for arrays
        if (propName == "length") {
            emit(emitter, "  " + resultReg + " = call i64 @tscl_array_length(i64 " + objReg + ")");
            setRegForValue(emitter, dest, resultReg);
            return;
        }

        // For other properties, get from object using property name as key
        // Create a tagged string for the property name
        let strGlobal = registerStringConstant(emitter, propName);
        let len = propName.length + 1;
        let ptrReg = allocReg(emitter);
        emit(emitter, "  " + ptrReg + " = getelementptr [" + String(len) + " x i8], [" + String(len) + " x i8]* " + strGlobal + ", i64 0, i64 0");
        let intReg = allocReg(emitter);
        emit(emitter, "  " + intReg + " = ptrtoint i8* " + ptrReg + " to i64");
        let maskedReg = allocReg(emitter);
        emit(emitter, "  " + maskedReg + " = and i64 " + intReg + ", 281474976710655");
        let keyReg = allocReg(emitter);
        emit(emitter, "  " + keyReg + " = or i64 " + maskedReg + ", 18445618173802708992");
        emit(emitter, "  " + resultReg + " = call i64 @tscl_object_get(i64 " + objReg + ", i64 " + keyReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE_PROP
    if (opcode == 21) {  // IrOpCode.STORE_PROP
        let objReg = getRegForValue(emitter, inst.args[0]);
        let valueReg = getRegForValue(emitter, inst.args[1]);
        let propName = inst.immediate;

        // Create a tagged string for the property name
        let strGlobal = registerStringConstant(emitter, propName);
        let len = propName.length + 1;
        let ptrReg = allocReg(emitter);
        emit(emitter, "  " + ptrReg + " = getelementptr [" + String(len) + " x i8], [" + String(len) + " x i8]* " + strGlobal + ", i64 0, i64 0");
        let intReg = allocReg(emitter);
        emit(emitter, "  " + intReg + " = ptrtoint i8* " + ptrReg + " to i64");
        let maskedReg = allocReg(emitter);
        emit(emitter, "  " + maskedReg + " = and i64 " + intReg + ", 281474976710655");
        let keyReg = allocReg(emitter);
        emit(emitter, "  " + keyReg + " = or i64 " + maskedReg + ", 18445618173802708992");
        emit(emitter, "  call void @tscl_object_set(i64 " + objReg + ", i64 " + keyReg + ", i64 " + valueReg + ")");
        return;
    }

    // LOAD_ELEMENT
    if (opcode == 22) {  // IrOpCode.LOAD_ELEMENT
        let dest = inst.dest;
        let arrReg = getRegForValue(emitter, inst.args[0]);
        let idxReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_array_get(i64 " + arrReg + ", i64 " + idxReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE_ELEMENT
    if (opcode == 23) {  // IrOpCode.STORE_ELEMENT
        let arrReg = getRegForValue(emitter, inst.args[0]);
        let idxReg = getRegForValue(emitter, inst.args[1]);
        let valueReg = getRegForValue(emitter, inst.args[2]);
        emit(emitter, "  call void @tscl_array_set(i64 " + arrReg + ", i64 " + idxReg + ", i64 " + valueReg + ")");
        return;
    }

    // JUMP
    if (opcode == 24) {  // IrOpCode.JUMP
        let targetLabel = inst.label;
        emit(emitter, "  br label %" + targetLabel);
        return;
    }

    // JUMP_IF_FALSE (standalone - shouldn't happen often, handled in emitLlvmBlock)
    if (opcode == 25) {  // IrOpCode.JUMP_IF_FALSE
        // This case is handled in emitLlvmBlock when combined with JUMP
        // If we get here, emit a warning comment
        emit(emitter, "  ; WARNING: standalone JUMP_IF_FALSE without following JUMP");
        return;
    }

    // CALL
    if (opcode == 26) {  // IrOpCode.CALL
        let dest = inst.dest;
        let resultReg = allocReg(emitter);

        // Check if this is a direct call (function name in immediate)
        if (inst.immediate != null && typeof inst.immediate == "string") {
            // Direct call: args = [argc, arg0, arg1, ...]
            let funcName = inst.immediate;
            let argc = inst.args[0];
            let args = "";
            let i = 1;
            while (i < inst.args.length) {
                if (i > 1) {
                    args = args + ", ";
                }
                args = args + "i64 " + getRegForValue(emitter, inst.args[i]);
                i = i + 1;
            }
            emit(emitter, "  " + resultReg + " = call i64 @" + funcName + "(" + args + ")");
            setRegForValue(emitter, dest, resultReg);
            return;
        }

        // Indirect call: args = [funcReg, argc, arg0, arg1, ...]
        let funcReg = getRegForValue(emitter, inst.args[0]);
        let argc = inst.args[1];
        // Build call with arguments
        let args = "";
        let i = 2;
        while (i < inst.args.length) {
            if (i > 2) {
                args = args + ", ";
            }
            args = args + "i64 " + getRegForValue(emitter, inst.args[i]);
            i = i + 1;
        }
        // Call through function pointer
        // First, extract the raw pointer from the NaN-boxed i64 and cast to function pointer
        let ptrIntReg = allocReg(emitter);
        emit(emitter, "  " + ptrIntReg + " = and i64 " + funcReg + ", 281474976710655");
        let funcPtrReg = allocReg(emitter);
        emit(emitter, "  " + funcPtrReg + " = inttoptr i64 " + ptrIntReg + " to ptr");
        emit(emitter, "  " + resultReg + " = call i64 " + funcPtrReg + "(" + args + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // CALL_METHOD
    if (opcode == 27) {  // IrOpCode.CALL_METHOD
        let dest = inst.dest;
        let methodPath = inst.immediate;
        let resultReg = allocReg(emitter);

        // Handle console.log (old format: immediate = "object.method", args = [argc, ...])
        if (methodPath == "console.log") {
            let argc = inst.args[0];
            if (argc >= 1) {
                let argReg = getRegForValue(emitter, inst.args[1]);
                emit(emitter, "  " + resultReg + " = call i64 @tscl_console_log(i64 " + argReg + ")");
            } else {
                emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
            }
            setRegForValue(emitter, dest, resultReg);
            return;
        }

        // Handle object method calls (new format: immediate = "method", args = [objReg, argc, ...])
        // Array.push
        if (methodPath == "push") {
            let objReg = getRegForValue(emitter, inst.args[0]);
            let argc = inst.args[1];
            if (argc >= 1) {
                let valueReg = getRegForValue(emitter, inst.args[2]);
                emit(emitter, "  " + resultReg + " = call i64 @tscl_array_push(i64 " + objReg + ", i64 " + valueReg + ")");
            } else {
                emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
            }
            setRegForValue(emitter, dest, resultReg);
            return;
        }

        // Array.pop - not yet implemented, return undefined
        if (methodPath == "pop" || methodPath == "shift" || methodPath == "unshift") {
            emit(emitter, "  ; TODO: implement " + String(methodPath));
            emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
            setRegForValue(emitter, dest, resultReg);
            return;
        }

        // Unknown method - return undefined
        emit(emitter, "  ; Unknown method: " + String(methodPath));
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // RETURN
    if (opcode == 28) {  // IrOpCode.RETURN
        if (inst.args.length > 0) {
            let valueReg = getRegForValue(emitter, inst.args[0]);
            emit(emitter, "  ret i64 " + valueReg);
        } else {
            emit(emitter, "  ret i64 9221120237041090561");  // undefined
        }
        return;
    }

    // PHI
    if (opcode == 29) {  // IrOpCode.PHI
        // PHI nodes need special handling - for now skip
        let dest = inst.dest;
        let reg = allocReg(emitter);
        emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");  // undefined placeholder
        setRegForValue(emitter, dest, reg);
        return;
    }

    // NEW_OBJECT
    if (opcode == 30) {  // IrOpCode.NEW_OBJECT
        let dest = inst.dest;
        // Use default capacity of 8 properties
        let capacity = 8;
        if (inst.immediate != null && typeof inst.immediate == "number") {
            capacity = inst.immediate;
            if (capacity < 4) capacity = 4;
        }
        let resultReg = allocReg(emitter);
        let capReg = allocReg(emitter);
        emit(emitter, "  " + capReg + " = add i64 0, " + String(capacity));
        emit(emitter, "  " + resultReg + " = call i64 @tscl_alloc_object(i64 " + capReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NEW_ARRAY
    if (opcode == 31) {  // IrOpCode.NEW_ARRAY
        let dest = inst.dest;
        // Initial capacity is in immediate field (element count)
        let capacity = inst.immediate;
        if (capacity == null || capacity < 8) {
            capacity = 8;  // Minimum capacity
        }
        let resultReg = allocReg(emitter);
        let capReg = allocReg(emitter);
        emit(emitter, "  " + capReg + " = add i64 0, " + String(capacity));
        emit(emitter, "  " + resultReg + " = call i64 @tscl_alloc_array(i64 " + capReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // Unknown opcode - emit placeholder
    emit(emitter, "  ; Unknown opcode: " + String(opcode));
    return;
}

// ============================================================================
// Main Wrapper
// ============================================================================

function emitMainWrapper(emitter: LlvmEmitter): void {
    emit(emitter, "; ============================================================");
    emit(emitter, "; Main entry point");
    emit(emitter, "; ============================================================");

    // tscl_box_number helper
    emit(emitter, "define i64 @tscl_box_number(double %val) {");
    emit(emitter, "entry:");
    emit(emitter, "  %result = bitcast double %val to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // Main wrapper that calls script_main (or main if it exists)
    emit(emitter, "define i32 @main() {");
    emit(emitter, "entry:");
    emit(emitter, "  call i64 @script_main()");
    emit(emitter, "  ret i32 0");
    emit(emitter, "}");
    emit(emitter, "");
    return;
}

console.log("LLVM emitter module loaded");
