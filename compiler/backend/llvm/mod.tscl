// ============================================================================
// LLVM IR Text Emitter for tscl Compiler
// ============================================================================
// Generates LLVM IR text (.ll files) from tscl SSA IR

require ./runtime;
require ./types;

// ============================================================================
// LLVM Emitter State
// ============================================================================

interface LlvmEmitter {
    output: string[];
    regCounter: number;
    blockCounter: number;
    stringConstants: { value: string, id: number }[];
    currentFunction: string;
    regMap: { [key: number]: string };
    localSlots: string[];
}

function createLlvmEmitter(): LlvmEmitter {
    return {
        output: [],
        regCounter: 0,
        blockCounter: 0,
        stringConstants: [],
        currentFunction: "",
        regMap: {},
        localSlots: []
    };
}

// ============================================================================
// Helper Functions
// ============================================================================

function emit(emitter: LlvmEmitter, line: string): void {
    emitter.output.push(line);
    return;
}

function allocReg(emitter: LlvmEmitter): string {
    let reg = "%r" + String(emitter.regCounter);
    emitter.regCounter = emitter.regCounter + 1;
    return reg;
}

function getBlockLabel(blockLabel: string): string {
    return blockLabel;
}

function getRegForValue(emitter: LlvmEmitter, valueId: number): string {
    let key = "v" + String(valueId);
    if (emitter.regMap[key] != null) {
        return emitter.regMap[key];
    }
    // Value not found - this shouldn't happen in valid IR
    return "%undefined_" + String(valueId);
}

function setRegForValue(emitter: LlvmEmitter, valueId: number, reg: string): void {
    let key = "v" + String(valueId);
    emitter.regMap[key] = reg;
    return;
}

// Format a double value for LLVM IR
function formatDouble(value: number): string {
    // Convert to string
    let str = String(value);
    // Ensure it has a decimal point for LLVM double syntax
    let hasDot = false;
    let hasE = false;
    let i = 0;
    while (i < str.length) {
        let c = str[i];
        if (c == ".") {
            hasDot = true;
        }
        if (c == "e" || c == "E") {
            hasE = true;
        }
        i = i + 1;
    }
    if (!hasDot && !hasE) {
        str = str + ".0";
    }
    return str;
}

// ============================================================================
// Module Emission
// ============================================================================

function emitLlvmModule(irModule: IrModule): string {
    let emitter = createLlvmEmitter();

    // Emit header
    emit(emitter, "; ============================================================");
    emit(emitter, "; LLVM IR generated by tscl compiler");
    emit(emitter, "; ============================================================");
    emit(emitter, "");

    // Emit target triple (arm64 for Apple Silicon, x86_64 for Intel)
    emit(emitter, "target triple = \"arm64-apple-darwin\"");
    emit(emitter, "");

    // Emit runtime declarations (libc printf)
    emit(emitter, "; External declarations");
    emit(emitter, "declare i32 @printf(i8*, ...)");
    emit(emitter, "");

    // Emit string constants
    emit(emitter, "; String constants");
    emit(emitter, "@.fmt_num = private unnamed_addr constant [4 x i8] c\"%g\\0A\\00\"");
    emit(emitter, "");

    // Emit runtime function definitions (inline)
    emitRuntimeFunctions(emitter);

    // Emit all user functions
    let i = 0;
    while (i < irModule.functions.length) {
        emitLlvmFunction(emitter, irModule.functions[i]);
        i = i + 1;
    }

    // Emit main wrapper
    emitMainWrapper(emitter);

    // Join all output lines
    let result = "";
    let j = 0;
    while (j < emitter.output.length) {
        result = result + emitter.output[j] + "\n";
        j = j + 1;
    }

    return result;
}

// ============================================================================
// Runtime Functions
// ============================================================================

function emitRuntimeFunctions(emitter: LlvmEmitter): void {
    emit(emitter, "; ============================================================");
    emit(emitter, "; Runtime functions");
    emit(emitter, "; ============================================================");
    emit(emitter, "");

    // tscl_console_log
    emit(emitter, "define i64 @tscl_console_log(i64 %value) {");
    emit(emitter, "entry:");
    emit(emitter, "  %dval = bitcast i64 %value to double");
    emit(emitter, "  %fmt = getelementptr [4 x i8], [4 x i8]* @.fmt_num, i64 0, i64 0");
    emit(emitter, "  call i32 (i8*, ...) @printf(i8* %fmt, double %dval)");
    emit(emitter, "  ret i64 9221120237041090561");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_add_any
    emit(emitter, "define i64 @tscl_add_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fadd double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_sub_any
    emit(emitter, "define i64 @tscl_sub_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fsub double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_mul_any
    emit(emitter, "define i64 @tscl_mul_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fmul double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_div_any
    emit(emitter, "define i64 @tscl_div_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = fdiv double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_mod_any
    emit(emitter, "define i64 @tscl_mod_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %result_fp = frem double %a_fp, %b_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_neg
    emit(emitter, "define i64 @tscl_neg(i64 %a) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %result_fp = fsub double 0.0, %a_fp");
    emit(emitter, "  %result = bitcast double %result_fp to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_lt_any
    emit(emitter, "define i64 @tscl_lt_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp olt double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_le_any
    emit(emitter, "define i64 @tscl_le_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp ole double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_gt_any
    emit(emitter, "define i64 @tscl_gt_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp ogt double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_ge_any
    emit(emitter, "define i64 @tscl_ge_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp oge double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_eq_any
    emit(emitter, "define i64 @tscl_eq_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp oeq double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // tscl_ne_any
    emit(emitter, "define i64 @tscl_ne_any(i64 %a, i64 %b) {");
    emit(emitter, "entry:");
    emit(emitter, "  %a_fp = bitcast i64 %a to double");
    emit(emitter, "  %b_fp = bitcast i64 %b to double");
    emit(emitter, "  %cmp = fcmp one double %a_fp, %b_fp");
    emit(emitter, "  %cmp_ext = zext i1 %cmp to i64");
    emit(emitter, "  %result = or i64 9221120237041090560, %cmp_ext");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    return;
}

// ============================================================================
// Function Emission
// ============================================================================

function emitLlvmFunction(emitter: LlvmEmitter, func: IrFunction): void {
    // Reset state for new function
    emitter.regCounter = 0;
    emitter.regMap = {};
    emitter.localSlots = [];

    // Rename "main" to "script_main" to avoid collision with C main wrapper
    let funcName = func.name;
    if (funcName == "main") {
        funcName = "script_main";
    }
    emitter.currentFunction = funcName;

    // Build parameter list
    let params = "";
    let i = 0;
    while (i < func.params.length) {
        if (i > 0) {
            params = params + ", ";
        }
        let paramReg = "%p" + String(i);
        params = params + "i64 " + paramReg;
        // Map parameter to a register
        setRegForValue(emitter, i, paramReg);
        i = i + 1;
    }

    emit(emitter, "; ============================================================");
    emit(emitter, "; Function: " + funcName);
    emit(emitter, "; ============================================================");
    emit(emitter, "define i64 @" + funcName + "(" + params + ") {");

    // Emit entry block with local allocations
    emit(emitter, "entry:");

    // Allocate stack slots for locals
    let j = 0;
    while (j < func.locals.length) {
        let slotReg = "%local" + String(j);
        emit(emitter, "  " + slotReg + " = alloca i64");
        emitter.localSlots.push(slotReg);
        j = j + 1;
    }

    // Jump to first block
    if (func.blocks.length > 0) {
        emit(emitter, "  br label %" + func.entry_block.label);
    }

    // Emit all blocks
    let k = 0;
    while (k < func.blocks.length) {
        emitLlvmBlock(emitter, func.blocks[k]);
        k = k + 1;
    }

    emit(emitter, "}");
    emit(emitter, "");
    return;
}

// ============================================================================
// Block Emission
// ============================================================================

function emitLlvmBlock(emitter: LlvmEmitter, block: IrBlock): void {
    emit(emitter, block.label + ":");

    // Emit all instructions
    let i = 0;
    while (i < block.ops.length) {
        emitLlvmInstruction(emitter, block.ops[i]);
        i = i + 1;
    }
    return;
}

// ============================================================================
// Instruction Emission
// ============================================================================

function emitLlvmInstruction(emitter: LlvmEmitter, inst: IrInstruction): void {
    let opcode = inst.opcode;

    // CONST - load a constant value
    if (opcode == 0) {  // IrOpCode.CONST
        let dest = inst.dest;
        let value = inst.immediate;
        let reg = allocReg(emitter);

        // Check if value is a number
        if (typeof value == "number") {
            // Emit as double, then bitcast to i64
            let tmpReg = allocReg(emitter);
            let dblStr = formatDouble(value);
            emit(emitter, "  " + tmpReg + " = call i64 @tscl_box_number(double " + dblStr + ")");
            setRegForValue(emitter, dest, tmpReg);
        } else if (typeof value == "boolean") {
            // Boolean constant
            if (value) {
                emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");
            } else {
                emit(emitter, "  " + reg + " = add i64 0, 9221120237041090560");
            }
            setRegForValue(emitter, dest, reg);
        } else if (value == null) {
            // Undefined constant
            emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");
            setRegForValue(emitter, dest, reg);
        } else {
            // String or other - just use undefined for now
            emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");
            setRegForValue(emitter, dest, reg);
        }
        return;
    }

    // ADD
    if (opcode == 1) {  // IrOpCode.ADD
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_add_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // SUB
    if (opcode == 2) {  // IrOpCode.SUB
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_sub_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // MUL
    if (opcode == 3) {  // IrOpCode.MUL
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_mul_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // DIV
    if (opcode == 4) {  // IrOpCode.DIV
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_div_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // MOD
    if (opcode == 5) {  // IrOpCode.MOD
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_mod_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NEG
    if (opcode == 6) {  // IrOpCode.NEG
        let dest = inst.dest;
        let srcReg = getRegForValue(emitter, inst.args[0]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_neg(i64 " + srcReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NOT
    if (opcode == 7) {  // IrOpCode.NOT
        let dest = inst.dest;
        let srcReg = getRegForValue(emitter, inst.args[0]);
        let resultReg = allocReg(emitter);
        // NOT: check if value is falsy and return inverted boolean
        let tmp1 = allocReg(emitter);
        let tmp2 = allocReg(emitter);
        emit(emitter, "  " + tmp1 + " = and i64 " + srcReg + ", 1");
        emit(emitter, "  " + tmp2 + " = icmp eq i64 " + tmp1 + ", 0");
        emit(emitter, "  " + resultReg + " = select i1 " + tmp2 + ", i64 9221120237041090561, i64 9221120237041090560");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // EQ
    if (opcode == 8) {  // IrOpCode.EQ
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_eq_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NE
    if (opcode == 9) {  // IrOpCode.NE
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_ne_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // LT
    if (opcode == 10) {  // IrOpCode.LT
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_lt_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // GT
    if (opcode == 11) {  // IrOpCode.GT
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_gt_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // LE
    if (opcode == 12) {  // IrOpCode.LE
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_le_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // GE
    if (opcode == 13) {  // IrOpCode.GE
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = call i64 @tscl_ge_any(i64 " + leftReg + ", i64 " + rightReg + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // AND (logical)
    if (opcode == 14) {  // IrOpCode.AND
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        // For AND, return left if falsy, else return right
        emit(emitter, "  " + resultReg + " = and i64 " + leftReg + ", " + rightReg);
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // OR (logical)
    if (opcode == 15) {  // IrOpCode.OR
        let dest = inst.dest;
        let leftReg = getRegForValue(emitter, inst.args[0]);
        let rightReg = getRegForValue(emitter, inst.args[1]);
        let resultReg = allocReg(emitter);
        // For OR, return left if truthy, else return right
        emit(emitter, "  " + resultReg + " = or i64 " + leftReg + ", " + rightReg);
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // LOAD (global)
    if (opcode == 16) {  // IrOpCode.LOAD
        let dest = inst.dest;
        let resultReg = allocReg(emitter);
        // Global loads return undefined for now
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE (global)
    if (opcode == 17) {  // IrOpCode.STORE
        // Global stores are no-ops for now
        return;
    }

    // LOAD_LOCAL
    if (opcode == 18) {  // IrOpCode.LOAD_LOCAL
        let dest = inst.dest;
        let slot = inst.args[0];
        let slotReg = emitter.localSlots[slot];
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = load i64, i64* " + slotReg);
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE_LOCAL
    if (opcode == 19) {  // IrOpCode.STORE_LOCAL
        let slot = inst.args[0];
        let valueReg = getRegForValue(emitter, inst.args[1]);
        let slotReg = emitter.localSlots[slot];
        emit(emitter, "  store i64 " + valueReg + ", i64* " + slotReg);
        return;
    }

    // LOAD_PROP
    if (opcode == 20) {  // IrOpCode.LOAD_PROP
        let dest = inst.dest;
        let objReg = getRegForValue(emitter, inst.args[0]);
        let resultReg = allocReg(emitter);
        // For now, return undefined - actual property access needs runtime support
        emit(emitter, "  ; LOAD_PROP from " + objReg);
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE_PROP
    if (opcode == 21) {  // IrOpCode.STORE_PROP
        // Property stores are no-ops for now
        emit(emitter, "  ; STORE_PROP (no-op)");
        return;
    }

    // LOAD_ELEMENT
    if (opcode == 22) {  // IrOpCode.LOAD_ELEMENT
        let dest = inst.dest;
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // STORE_ELEMENT
    if (opcode == 23) {  // IrOpCode.STORE_ELEMENT
        emit(emitter, "  ; STORE_ELEMENT (no-op)");
        return;
    }

    // JUMP
    if (opcode == 24) {  // IrOpCode.JUMP
        let targetLabel = inst.label;
        emit(emitter, "  br label %" + targetLabel);
        return;
    }

    // JUMP_IF_FALSE (BRANCH)
    if (opcode == 25) {  // IrOpCode.JUMP_IF_FALSE
        let condReg = getRegForValue(emitter, inst.args[0]);
        let targetLabel = inst.label;
        // Extract boolean from NaN-boxed value
        let tmp1 = allocReg(emitter);
        let tmp2 = allocReg(emitter);
        emit(emitter, "  " + tmp1 + " = and i64 " + condReg + ", 1");
        emit(emitter, "  " + tmp2 + " = icmp eq i64 " + tmp1 + ", 0");
        // Note: we need to know the fall-through block for a proper branch
        // For now, assume the next block is the fall-through
        emit(emitter, "  br i1 " + tmp2 + ", label %" + targetLabel + ", label %fallthrough_" + String(emitter.blockCounter));
        emitter.blockCounter = emitter.blockCounter + 1;
        return;
    }

    // CALL
    if (opcode == 26) {  // IrOpCode.CALL
        let dest = inst.dest;
        let funcReg = getRegForValue(emitter, inst.args[0]);
        let argc = inst.args[1];
        let resultReg = allocReg(emitter);
        // Build call with arguments
        let args = "";
        let i = 2;
        while (i < inst.args.length) {
            if (i > 2) {
                args = args + ", ";
            }
            args = args + "i64 " + getRegForValue(emitter, inst.args[i]);
            i = i + 1;
        }
        // For now, call the function pointer directly (simple case)
        emit(emitter, "  " + resultReg + " = call i64 " + funcReg + "(" + args + ")");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // CALL_METHOD
    if (opcode == 27) {  // IrOpCode.CALL_METHOD
        // Format: args = [argc, arg0, arg1, ...], immediate = "object.method"
        let dest = inst.dest;
        let methodPath = inst.immediate;
        let argc = inst.args[0];
        let resultReg = allocReg(emitter);

        // Handle console.log
        if (methodPath == "console.log") {
            if (argc >= 1) {
                let argReg = getRegForValue(emitter, inst.args[1]);
                emit(emitter, "  " + resultReg + " = call i64 @tscl_console_log(i64 " + argReg + ")");
            } else {
                emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
            }
            setRegForValue(emitter, dest, resultReg);
            return;
        }

        // Unknown method - return undefined
        emit(emitter, "  ; Unknown method: " + String(methodPath));
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // RETURN
    if (opcode == 28) {  // IrOpCode.RETURN
        if (inst.args.length > 0) {
            let valueReg = getRegForValue(emitter, inst.args[0]);
            emit(emitter, "  ret i64 " + valueReg);
        } else {
            emit(emitter, "  ret i64 9221120237041090561");  // undefined
        }
        return;
    }

    // PHI
    if (opcode == 29) {  // IrOpCode.PHI
        // PHI nodes need special handling - for now skip
        let dest = inst.dest;
        let reg = allocReg(emitter);
        emit(emitter, "  " + reg + " = add i64 0, 9221120237041090561");  // undefined placeholder
        setRegForValue(emitter, dest, reg);
        return;
    }

    // NEW_OBJECT
    if (opcode == 30) {  // IrOpCode.NEW_OBJECT
        let dest = inst.dest;
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");  // placeholder
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // NEW_ARRAY
    if (opcode == 31) {  // IrOpCode.NEW_ARRAY
        let dest = inst.dest;
        let resultReg = allocReg(emitter);
        emit(emitter, "  " + resultReg + " = add i64 0, 9221120237041090561");  // placeholder
        setRegForValue(emitter, dest, resultReg);
        return;
    }

    // Unknown opcode - emit placeholder
    emit(emitter, "  ; Unknown opcode: " + String(opcode));
    return;
}

// ============================================================================
// Main Wrapper
// ============================================================================

function emitMainWrapper(emitter: LlvmEmitter): void {
    emit(emitter, "; ============================================================");
    emit(emitter, "; Main entry point");
    emit(emitter, "; ============================================================");

    // tscl_box_number helper
    emit(emitter, "define i64 @tscl_box_number(double %val) {");
    emit(emitter, "entry:");
    emit(emitter, "  %result = bitcast double %val to i64");
    emit(emitter, "  ret i64 %result");
    emit(emitter, "}");
    emit(emitter, "");

    // Main wrapper that calls script_main (or main if it exists)
    emit(emitter, "define i32 @main() {");
    emit(emitter, "entry:");
    emit(emitter, "  call i64 @script_main()");
    emit(emitter, "  ret i32 0");
    emit(emitter, "}");
    emit(emitter, "");
    return;
}

console.log("LLVM emitter module loaded");
