// Lifetime Constraint System

let ConstraintKind = {
    OUTLIVES: "outlives",
    VALID_AT: "valid_at",
    EQUAL: "equal",
}

interface ProgramPoint {
    scopeDepth: number;
    statementIndex: number;
}

interface LifetimeConstraint {
    kind: string;
    longer?: string;
    shorter?: string;
    lifetime?: string;
    point?: ProgramPoint;
    a?: string;
    b?: string;
    span?: string;
}

interface ConstraintSet {
    constraint: LifetimeConstraint[];
}

interface LifetimeGraph {
    edges: { [key: string]: string[] };
    nodes: string[];
}

interface SolveResult {
    success: boolean;
    errors: string[];
    order: string[];
}


let ErrorCode = {
    RETURN_LOCAL_REF: "E0501",
    LIFETIME_TOO_SHORT: "E0502",
    MUTABLE_WHILE_BORROWED: "E0503",
    LIFETIME_MISSMATCH: "E0504",
    AMBIGUOS_LIFETIME: "E0505",
    CYCLE_DETECTED: "E0506"
}

let ErrorKind = {
    RETURN_LOCAL_REF: "return_local_ref",
    LIFETIME_TOO_SHORT: "lifetime_too_short",
    MUTABLE_WHILE_BORROWED: "mutable_while_borrowed",
    LIFETIME_MISSMATCH: "lifetime_mismatch",
    AMBIGUOS_LIFETIME: "ambiguous_lifetime",
    CYCLE_DETECTED: "cycle_detected"
}

interface SourceLocation {
    file: string;
    line: number;
    column: number;
}

interface LifetimeError {
    kind: string;
    code: string;
    span: string;
    message: string;
    expected?: string;
    found?: string;
    lifetime?: string;
    variable?: string;
    hint?: string;
    secondarySpan?: string;
    secondaryLabel?: string;
    primaryLabel?: string;

}


function createProgramPoint(scopeDepth: number, statementIndex: number): ProgramPoint {
    return { scopeDepth: scopeDepth, statementIndex: statementIndex };
}

function createConstraintSet(): ConstraintSet {
    return { constraint: [] };
}

function addConstraint(set: ConstraintSet, constraint: LifetimeConstraint): void {
    set.constraint.push(constraint);
}

function addOutlives(set: ConstraintSet, longer: string, shorter: string, span: string): void {
    addConstraint(set, { kind: ConstraintKind.OUTLIVES, longer: longer, shorter: shorter, span: span });
}

function addValidAt(set: ConstraintSet, lifetime: string, point: ProgramPoint, span: string): void {
    addConstraint(set, { kind: ConstraintKind.VALID_AT, lifetime: lifetime, point: point, span: span });
}

function addEqual(set: ConstraintSet, a: string, b: string, span: string): void {
    addConstraint(set, { kind: ConstraintKind.EQUAL, a: a, b: b, span: span });
}

function getConstraints(set: ConstraintSet): LifetimeConstraint[] {
    return set.constraint;
}

function isEmpty(set: ConstraintSet): boolean {
    return set.constraint.length == 0;
}

function isNotEmpty(set: ConstraintSet): boolean {
    return set.constraint.length > 0;
}

function buildLifetimeGraph(set: ConstraintSet): LifetimeGraph {
      let edges = {};
      let nodes = [];

      let i = 0;
      while (i < set.constraint.length) {
          let c = set.constraint[i];
          if (c.kind == ConstraintKind.OUTLIVES) {
              // Inline indexOf for c.longer
              let foundLonger = false;
              let j = 0;
              while (j < nodes.length) {
                  if (nodes[j] == c.longer) { foundLonger = true; break; }
                  j = j + 1;
              }
              if (!foundLonger) nodes.push(c.longer);

              // Inline indexOf for c.shorter
              let foundShorter = false;
              let k = 0;
              while (k < nodes.length) {
                  if (nodes[k] == c.shorter) { foundShorter = true; break; }
                  k = k + 1;
              }
              if (!foundShorter) nodes.push(c.shorter);

              if (edges[c.longer] == null) edges[c.longer] = [];
              edges[c.longer].push(c.shorter);
          } else if (c.kind == ConstraintKind.EQUAL) {
              // Inline indexOf for c.a
              let foundA = false;
              let ja = 0;
              while (ja < nodes.length) {
                  if (nodes[ja] == c.a) { foundA = true; break; }
                  ja = ja + 1;
              }
              if (!foundA) nodes.push(c.a);

              // Inline indexOf for c.b
              let foundB = false;
              let jb = 0;
              while (jb < nodes.length) {
                  if (nodes[jb] == c.b) { foundB = true; break; }
                  jb = jb + 1;
              }
              if (!foundB) nodes.push(c.b);

              if (edges[c.a] == null) edges[c.a] = [];
              edges[c.a].push(c.b);
              if (edges[c.b] == null) edges[c.b] = [];
              edges[c.b].push(c.a);
          }
          i = i + 1;
      }
      return { edges: edges, nodes: nodes };
  }


   function detectCycle(graph: LifetimeGraph): string | null {
      let visited = [];
      let inStack = [];
      let callStack = []; // Stack of {node, neighborIndex}

      let nodeIdx = 0;
      while (nodeIdx < graph.nodes.length) {
          let startNode = graph.nodes[nodeIdx];

          // Check if already visited
          let alreadyVisited = false;
          let v = 0;
          while (v < visited.length) {
              if (visited[v] == startNode) { alreadyVisited = true; break; }
              v = v + 1;
          }
          if (alreadyVisited) {
              nodeIdx = nodeIdx + 1;
              continue;
          }

          // Start DFS from this node
          callStack.push({ node: startNode, idx: 0 });
          inStack.push(startNode);
          visited.push(startNode);

          while (callStack.length > 0) {
              let current = callStack[callStack.length - 1];
              let neighbors = graph.edges[current.node];
              if(neighbors == null) neighbors = [];

              if (current.idx >= neighbors.length) {
                  // Done with this node
                  callStack.pop();
                  inStack.pop();
                  continue;
              }

              let neighbor = neighbors[current.idx];
              current.idx = current.idx + 1;

              // Check if neighbor is in stack (cycle!)
              let inStackFound = false;
              let s = 0;
              while (s < inStack.length) {
                  if (inStack[s] == neighbor) { inStackFound = true; break; }
                  s = s + 1;
              }
              if (inStackFound) {
                  return neighbor;
              }

              // Check if already visited
              let neighborVisited = false;
              let nv = 0;
              while (nv < visited.length) {
                  if (visited[nv] == neighbor) { neighborVisited = true; break; }
                  nv = nv + 1;
              }
              if (neighborVisited) continue;

              // Push neighbor onto stack
              callStack.push({ node: neighbor, idx: 0 });
              inStack.push(neighbor);
              visited.push(neighbor);
          }

          nodeIdx = nodeIdx + 1;
      }

      return null;
  }

  function topoVisit(graph: LifetimeGraph, node: string, visited: string[], result: string[]): void {
      // if (visited.indexOf(node) != -1) return;
      visited.push(node);
      let isVisited = false;
      let xm = 0;
      while(xm < isVisited.length){
        if(isVisited[xm] == node) { isVisited[xm] = true; }
        xm++;
      }

      if(!isVisited){
        return
      }



      let neighbors = graph.edges[node];
      if(neighbors == null) neighbors = [];

      let j = 0;
      while (j < neighbors.length) {
          topoVisit(graph, neighbors[j], visited, result);
          j = j + 1;
      }
      result.push(node);
  }

  function topologicalSort(graph: LifetimeGraph): string[] {
      let visited = [];
      let result = [];

      let i = 0;
      while (i < graph.nodes.length) {
          topoVisit(graph, graph.nodes[i], visited, result);
          i = i + 1;
      }
      return result.reverse();
  }

  function solveConstraints(set: ConstraintSet): SolveResult {
      if (isEmpty(set)) {
          return { success: true, errors: [], order: [] };
      }

      let graph = buildLifetimeGraph(set);
      let cycle = detectCycle(graph);
      if (cycle != null) {
          return {
              success: false,
              errors: ["Contradictory lifetime constraint: cycle involving '" + cycle + "'"],
              order: []
          };
      }

      let order = topologicalSort(graph);
      return { success: true, errors: [], order: order };
  }



  // Errors




function parseSpan(span: string): SourceLocation {
    return { file: span, line: 0, column: 0 };
}


function makeUnderline(column: number, length: number, label:string): string {
    let spaces = "";
    let i = 0;
    while ( i < column -1) {
        spaces = spaces + " ";
        i = i +1;
    }

    let carets = "";
    let j = 0;
    while(j < length){
        carets = carets + "^";
        j = j +1;
    }

    return spaces + carets + " " + label;
}

function makeDashes(column:number, length: number, label: string): string {
    let spaces = "";
    let i = 0;
    while ( i < column -1) {
        spaces = spaces + " ";
        i = i +1;
    }

    let dashes = "";
    let j = 0;
    while(j < length){
        dashes = dashes + "-";
        j = j +1;
    }

    return spaces + dashes + " " + label;
}

function padLineNum(num: number, width: number):string {
    let s = "" + num;
    while(s.length < width){
        s = " " + s;
    }
    return s;
}

function createError(kind:string, code:string, span:string, message:string): LifetimeError {
    return { kind: kind, code: code, span: span, message: message };
}

function errorReturnLocalRef(variable: string,  span:string, declSpan: string): LifetimeError {
    let err = createError(ErrorKind.RETURN_LOCAL_REF, ErrorCode.RETURN_LOCAL_REF, span, "cannot return reference to local variable");
    err.variable = variable;
    err.primaryLabel = "returns reference to data owned by current function";
    err.secondarySpan = declSpan;
    err.secondaryLabel = "declared here";
    return err;
}

function errorMutableWhileBorrower(variable: string, span:string,  borrowSpan:string): LifetimeError{
    let err = createError(ErrorKind.MUTABLE_WHILE_BORROWED, ErrorCode.MUTABLE_WHILE_BORROWED, span, "cannot borrow `" + variable + "` as mutable because it is also borrowed as immutable");
    err.variable = variable;
    err.primaryLabel = "mutable borrow occours here";
    err.seccondarySpan = borrowSpan;
    err.secondaryLabel = "immutable borrow occours here";

    return err;
}

function errorLifeTimeMismatch(expected: string, found: string, span: string):LifetimeError{

    let err = createError(ErrorKind.LIFETIME_MISSMATCH, ErrorCode.LIFETIME_MISSMATCH, span, "lifetime mismatch");

    err.expected = expected;
    err.found = found;
    err.primaryLabel = "expected " + expected + ", found " + found;
    return err;

}

function errorAmbiguousLifetime(span:string): LifetimeError{
    let err = createError(ErrorKind.AMBIGUOUS_LIFETIME, ErrorCode.AMBIGUOUS_LIFETIME, span, "missing lifetime specifier");

    err.primaryLabel = "expected named lifetime parameter";
    err.hint = "consider introducing a named lifetime parameted: <'a>";
    return err;
}

function errorCycleDetected(lifetime: string, span:string): LifetimeError{
    let err = createError(ErrorKind.CYCLE_DETECTED, ErrorCode.CYCLE_DETECTED, span, "cycle lifetime dependency detected");

    err.lifetime = lifetime;
    err.primaryLabel = "cycle involves" + lifetime;

    return err;
}

function formatErrorWithSource(err: LifetimeError, sourceLines: object): string{
    let loc = parseSpan(err.span);
    let result = "error[" + err.code + "]: " + err.message + "\n";
    result = result + " --> " + err.span + "\n";
    result = result + "    |\n";

    if(err.secondarySpan != null){
        let secLoc = parseSpan(err.secondarySpan);
        let secLine = sourceLines[secLoc.line];
        if(secLine != null) {
            result = result + padLineNum(loc.line, 3) + " | " + primaryLine + "\n";
            result = result + " | " + makeDashes(secLoc.column, 5, err.secondaryLabel) + "\n";
        }
    }

    let primaryLine = sourceLines[loc.line];
    if(primaryLine != null) {
        result = result + padLineNum(loc.line, 3) + " | " + secLine + "\n";
        result = result + " | " + makeDashes(loc.column, 5, err.primaryLabel) + "\n";
    }


    if(err.hint != null){
        result = result + "    |\n";
        result = result + "    = help:" + err.hint + "\n";
    }

    return result;
}

function formatError(err: LifetimeError): string {
    let result = "error[" + err.code + "]:" + err.message + "\n";

    result = result + " --> " + err.span + "\n";
    if(err.primaryLabel != null) {
        result = result + "   | " + err.primaryLabel + "\n";
    }
    if(err.hint != null) {
        result = result + "   = help: " + err.hint + "\n";
    }

    return result;
}

let LifetimeConstraints = {
      ConstraintKind: ConstraintKind,
      createProgramPoint: createProgramPoint,
      createConstraintSet: createConstraintSet,
      addConstraint: addConstraint,
      addOutlives: addOutlives,
      addValidAt: addValidAt,
      addEqual: addEqual,
      getConstraints: getConstraints,
      isEmpty: isEmpty,
      isNotEmpty: isNotEmpty,
      buildLifetimeGraph: buildLifetimeGraph,
      detectCycle: detectCycle,
      topologicalSort: topologicalSort,
      solveConstraints: solveConstraints,
      ErrorCode: ErrorCode,
      ErrorKind: ErrorKind,
      parseSpan: parseSpan,
      formatError: formatError,
      formatErrorWithSource: formatErrorWithSource
  };

  console.log("Lifetime constraints module loaded.");
