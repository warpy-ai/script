// ============================================================================
// tscl Compiler - Main Entry Point
// ============================================================================

require ./lexer/mod;
require ./ast/types;
require ./parser/mod;
require ./ir/mod;
require ./ir/builder;
require ./codegen/mod;
require ./codegen/emitter;
require ./passes/mod;
require ./stdlib/builtins;

// ============================================================================
// Command Line Interface
// ============================================================================

interface CliArgs {
    command: string;
    inputFile: string;
    outputFile: string;
    emitIr: boolean;
    emitAst: boolean;
    verbose: boolean;
}

function parseArgs(args: string[]): CliArgs {
    let result: CliArgs = {
        command: "run",
        inputFile: "",
        outputFile: "",
        emitIr: false,
        emitAst: false,
        verbose: false
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];
        if (arg == "run" || arg == "build" || arg == "ir" || arg == "ast" || arg == "check") {
            result.command = arg;
        } else if (arg == "-o" || arg == "--output") {
            i = i + 1;
            if (i < args.length) {
                result.outputFile = args[i];
            }
        } else if (arg == "--emit-ir") {
            result.emitIr = true;
        } else if (arg == "--emit-ast") {
            result.emitAst = true;
        } else if (arg == "-v" || arg == "--verbose") {
            result.verbose = true;
        } else if (arg != "") {
            result.inputFile = arg;
        }
        i = i + 1;
    }

    return result;
}

function printUsage() {
    console.log("tscl - TypeScript Compiler");
    console.log("");
    console.log("Usage: tscl <command> [options] <input>");
    console.log("");
    console.log("Commands:");
    console.log("  run <file>      Run the file");
    console.log("  build <file>    Compile to native binary");
    console.log("  check <file>    Type check and borrow check");
    console.log("  ir <file>       Output IR");
    console.log("  ast <file>      Output AST");
    console.log("");
    console.log("Options:");
    console.log("  -o, --output    Output file");
    console.log("  --emit-ir       Emit IR to file");
    console.log("  --emit-ast      Emit AST to file");
    console.log("  -v, --verbose   Verbose output");
    console.log("  --help          Show this help");
}

function logVerbose(verbose: boolean, message: string) {
    if (verbose) {
        console.log(message);
    }
}

// ============================================================================
// Compiler Pipeline
// ============================================================================

function compileSource(source: string, verbose: boolean): any {
    logVerbose(verbose, "Tokenizing...");
    let tokens = tokenize(source);
    logVerbose(verbose, "  " + tokens.length + " tokens");

    logVerbose(verbose, "Parsing...");
    let ast = parseSource(source);
    if (ast == null) {
        console.log("Parse error");
        return null;
    }
    logVerbose(verbose, "  " + ast.body.length + " statements");

    logVerbose(verbose, "Lowering to IR...");
    let irModule = lowerProgramToIr(ast);
    if (irModule == null) {
        console.log("IR lowering error");
        return null;
    }
    logVerbose(verbose, "  " + irModule.functions.length + " functions");

    logVerbose(verbose, "Verifying IR...");
    if (!verifyIrModule(irModule)) {
        console.log("IR verification failed");
        return null;
    }

    logVerbose(verbose, "Compilation complete");
    return irModule;
}

// lowerProgramToIr is now defined in ./ir/builder.tscl
// It provides complete AST â†’ IR lowering for all statement and expression types

// ============================================================================
// Main Entry Point
// ============================================================================

function main(args: string[]) {
    if (args.length < 2) {
        printUsage();
        return;
    }

    let parsed = parseArgs(args);

    if (parsed.inputFile == "") {
        console.log("Error: No input file specified");
        return;
    }

    if (!fs.existsSync(parsed.inputFile)) {
        console.log("Error: File not found: " + parsed.inputFile);
        return;
    }

    let source = fs.readFileSync(parsed.inputFile, "utf8");

    if (parsed.command == "ast") {
        let ast = parseSource(source);
        if (ast != null) {
            console.log(JSON.stringify(ast, null, 2));
        }
        return;
    }

    if (parsed.command == "check") {
        logVerbose(parsed.verbose, "Checking source...");

        let ast = parseSource(source);
        if (ast == null) {
            console.log("Parse error");
            return;
        }
        logVerbose(parsed.verbose, "  Parsed " + ast.body.length + " statements");

        // Run AST-level borrow checking
        let astResult = Passes.checkAst(ast);
        if (astResult.errors.length > 0) {
            console.log("Borrow check errors:");
            let i = 0;
            while (i < astResult.errors.length) {
                console.log("  " + BorrowCheck.formatError(astResult.errors[i]));
                i = i + 1;
            }
            return;
        }

        // Lower to IR and run additional passes
        let irModule = lowerProgramToIr(ast);
        if (irModule == null) {
            console.log("IR lowering error");
            return;
        }

        // Run type checking
        Passes.typecheck(irModule);
        logVerbose(parsed.verbose, "  Type check passed");

        // Run optimization (optional for check, but useful to verify IR is valid)
        Passes.optimize(irModule);
        logVerbose(parsed.verbose, "  Optimization passed");

        // Verify IR
        console.log("  Verifying IR...");
        if (!verifyIrModule(irModule)) {
            console.log("IR verification failed");
            return;
        }
        console.log("  IR verified");

        console.log("Check passed: " + parsed.inputFile);
        return;
    }

    if (parsed.command == "ir") {
        let irModule = compileSource(source, parsed.verbose);
        if (irModule != null) {
            let irText = serializeIrModule(irModule);
            if (parsed.outputFile != "") {
                fs.writeFileSync(parsed.outputFile, irText);
            } else {
                console.log(irText);
            }
        }
        return;
    }

    if (parsed.command == "build") {
        logVerbose(parsed.verbose, "Compiling to bytecode...");

        let ast = parseSource(source);
        if (ast == null) {
            console.log("Parse error");
            return;
        }
        logVerbose(parsed.verbose, "  Parsed " + ast.body.length + " statements");

        // Use direct emitter for VM-compatible bytecode
        let result = Emitter.compileAst(ast);
        if (result == null) {
            console.log("Bytecode generation failed");
            return;
        }
        logVerbose(parsed.verbose, "  Generated " + result.length + " bytes");

        let outputFile = parsed.outputFile;
        if (outputFile == "") {
            outputFile = parsed.inputFile + ".bc";
        }

        // fs.writeBinaryFile expects a ByteStream object directly
        fs.writeBinaryFile(outputFile, result.bytecode);
        console.log("Compiled: " + parsed.inputFile + " -> " + outputFile + " (" + result.length + " bytes)");
        return;
    }

    // Default: run command - compile and execute
    logVerbose(parsed.verbose, "Compiling for execution...");

    let ast = parseSource(source);
    if (ast == null) {
        console.log("Parse error");
        return;
    }

    // Generate bytecode
    let result = Emitter.compileAst(ast);
    if (result == null) {
        console.log("Bytecode generation failed");
        return;
    }

    console.log("Bytecode generated (" + result.length + " bytes)");
    console.log("To run, use the VM: ./target/release/script --run-binary <file.bc>");
    return;
}

// Export for external use
let Compiler = {
    compile: compileSource,
    compileToBytecode: function(source) {
        let ast = parseSource(source);
        if (ast == null) return null;
        return Emitter.compileAst(ast);
    },
    parse: parseSource,
    tokenize: tokenize,
    lowerToIr: lowerProgramToIr,
    verifyIr: verifyIrModule,
    serializeIr: serializeIrModule,
    codegenIr: codegenIrModule,
    Emitter: Emitter,
    Passes: Passes,
    TypeCheck: TypeCheck,
    Optimizer: Optimizer,
    BorrowCheck: BorrowCheck,
    version: "0.3.0"
};

console.log("tscl compiler loaded (v" + Compiler.version + ")");

// ============================================================================
// Auto-invoke main() with command-line arguments
// ============================================================================

// The runtime provides __args__ as command-line arguments after the script name
if (typeof __args__ !== "undefined" && __args__.length > 0) {
    main(__args__);
}
// Note: we don't show usage for no-args case since the compiler is typically invoked with args
