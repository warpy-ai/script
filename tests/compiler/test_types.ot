// Test file to verify type annotations work in .ot
// This file uses type annotations that are now supported

// Function with typed parameters and return type
function add(a: number, b: number): number {
    return a + b;
}

// Arrow function with type annotations
const multiply = (x: number, y: number): number => x * y;

// Variable with type annotation
let message: string = "Hello, TypeScript-style types!";
let count: number = 42;
let isActive: boolean = true;

// Array with type annotation
let numbers: number[] = [1, 2, 3, 4, 5];

// Function with async (Promise type)
async function fetchData(): Promise<string> {
    return "data";
}

// Higher-order function with typed parameters
const apply = (fn: (x: number) => number, value: number): number => {
    return fn(value);
};

// Test the functions
console.log("Type Annotation Test");
console.log("====================");
console.log("add(2, 3) = " + add(2, 3));
console.log("multiply(4, 5) = " + multiply(4, 5));
console.log("message = " + message);
console.log("count = " + count);
console.log("isActive = " + isActive);
console.log("numbers[0] = " + numbers[0]);
console.log("apply(double, 10) = " + apply((x: number): number => x * 2, 10));


console.log("");
console.log("=== Struct Lifetime Tests ===");

console.log("");
console.log("Test: Interface with valid lifetime params");
let testInterface = {
    name: "StringView",
    fields: [
        { name: "data", type: { kind: "ref", innerType: { kind: "primitive", name: "string" }, lifetime: "'a" }, optional: false }
    ],
    extends: [],
    genericParams: [],
    lifetimeParams: [{ name: "'a", bounds: [] }]
};
let errors1 = Types.validateStructLifetimes(null, testInterface);
if (errors1.length == 0) {
    console.log("  PASS: Valid struct lifetimes accepted");
} else {
    console.log("  FAIL: Expected no errors, got: " + errors1[0]);
}

console.log("");
console.log("Test: Interface with undeclared lifetime");
let badInterface = {
    name: "BadView",
    fields: [
        { name: "data", type: { kind: "ref", innerType: { kind: "primitive", name: "string" }, lifetime: "'b" }, optional: false }
    ],
    extends: [],
    genericParams: [],
    lifetimeParams: [{ name: "'a", bounds: [] }]
};
let errors2 = Types.validateStructLifetimes(null, badInterface);
if (errors2.length > 0) {
    console.log("  PASS: Undeclared lifetime detected");
    console.log("  Error: " + errors2[0]);
} else {
    console.log("  FAIL: Should have detected undeclared lifetime");
}

console.log("");
console.log("Test: Interface with static lifetime (always valid)");
let staticInterface = {
    name: "StaticView",
    fields: [
        { name: "data", type: { kind: "ref", innerType: { kind: "primitive", name: "string" }, lifetime: "static" }, optional: false }
    ],
    extends: [],
    genericParams: [],
    lifetimeParams: []
};
let errors3 = Types.validateStructLifetimes(null, staticInterface);
if (errors3.length == 0) {
    console.log("  PASS: Static lifetime accepted without declaration");
} else {
    console.log("  FAIL: Static lifetime should always be valid");
}

console.log("");
console.log("=== Lifetime Variance Tests ===");

console.log("");
console.log("Test: Immutable ref is covariant");
let refType = { kind: "ref", innerType: { kind: "primitive", name: "string" }, lifetime: "'a" };
let refVariance = Types.computeTypeVariance(refType, "'a");
if (refVariance == Types.Variance.COVARIANT) {
    console.log("  PASS: &'a T is covariant in 'a");
} else {
    console.log("  FAIL: Expected covariant, got " + refVariance);
}

console.log("");
console.log("Test: Mutable ref is invariant");
let mutRefType = { kind: "mutref", innerType: { kind: "primitive", name: "string" }, lifetime: "'a" };
let mutVariance = Types.computeTypeVariance(mutRefType, "'a");
if (mutVariance == Types.Variance.INVARIANT) {
    console.log("  PASS: &'a mut T is invariant in 'a");
} else {
    console.log("  FAIL: Expected invariant, got " + mutVariance);
}

console.log("");
console.log("Test: Struct variance from fields");
let covariantStruct = {
    name: "CovariantView",
    fields: [
        { name: "data", type: { kind: "ref", innerType: { kind: "primitive", name: "string" }, lifetime: "'a" }, optional: false }
    ],
    lifetimeParams: [{ name: "'a" }]
};
console.log("  fields.length: " + covariantStruct.fields.length);
console.log("  field type kind: " + covariantStruct.fields[0].type.kind);
console.log("  field type lifetime: " + covariantStruct.fields[0].type.lifetime);
let structVar = Types.computeStructVariance(covariantStruct, "'a");
console.log("  Direct type variance: " + Types.computeTypeVariance(covariantStruct.fields[0].type, "'a"));
if (structVar == Types.Variance.COVARIANT) {
    console.log("  PASS: Struct with &'a field is covariant");
} else {
    console.log("  FAIL: Expected covariant, got " + structVar);
}

console.log("");
console.log("Test: Lifetime substitution with covariance");
let outlives = { "'long": ["'short"] };
let canSub1 = Types.canSubstituteLifetime("'long", "'short", Types.Variance.COVARIANT, outlives);
if (canSub1) {
    console.log("  PASS: 'long -> 'short OK (covariant)");
} else {
    console.log("  FAIL: Should allow longer to shorter");
}

console.log("");
console.log("Test: Debug variance value");
console.log("  Variance.INVARIANT = " + Types.Variance.INVARIANT);


console.log("");
console.log("Test: Lifetime substitution blocked by invariance");
let testVariance = Types.Variance.INVARIANT;
console.log("  Using variance: " + testVariance);
let canSub2 = Types.canSubstituteLifetime("'long", "'short", testVariance, outlives);
console.log("  Result: " + canSub2);
if (!canSub2) {
    console.log("  PASS: 'long -> 'short blocked (invariant)");
} else {
    console.log("  FAIL: Invariant should block substitution");
}



console.log("");
console.log("Test: Static outlives everything");
let canSubStatic = Types.canSubstituteLifetime("static", "'any", Types.Variance.COVARIANT, {});
if (canSubStatic) {
    console.log("  PASS: 'static outlives any lifetime");
} else {
    console.log("  FAIL: Static should outlive everything");
}

console.log("");
console.log("Lifetime variance tests complete!");

console.log("");
console.log("Struct lifetime tests complete!");

console.log("");
console.log("All type annotations compiled successfully!");
