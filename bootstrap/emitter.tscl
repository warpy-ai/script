// ============================================================================
// Bootstrap Emitter for tscl
// Transforms AST to bytecode using ByteStream
// Requires: std/prelude.tscl to be loaded first
// ============================================================================

// ============================================================================
// Emitter State
// ============================================================================

function createEmitter() {
    return {
        stream: ByteStream.create(),
        // For tracking function addresses and backpatching jumps
        functions: {},
        // Pending jump patches (for forward jumps)
        patches: [],
        // Break/continue stack for loops
        loopStack: [],
        // Current compilation scope (null = global)
        scope: null
    };
}

// ============================================================================
// ByteStream Helpers
// ============================================================================

function emitU8(emitter, byte) {
    ByteStream.writeU8(emitter.stream, byte);
}

function emitU32(emitter, value) {
    ByteStream.writeU32(emitter.stream, value);
}

function emitF64(emitter, value) {
    ByteStream.writeF64(emitter.stream, value);
}

function emitVarint(emitter, value) {
    ByteStream.writeVarint(emitter.stream, value);
}

function emitString(emitter, str) {
    ByteStream.writeString(emitter.stream, str);
}

function currentOffset(emitter) {
    return ByteStream.length(emitter.stream);
}

function patchU32(emitter, offset, value) {
    ByteStream.patchU32(emitter.stream, offset, value);
}

// ============================================================================
// Loop Stack Management (for break/continue)
// ============================================================================

function pushLoop(emitter) {
    emitter.loopStack.push({
        breakPatches: [],
        continueTarget: -1
    });
}

function popLoop(emitter) {
    return emitter.loopStack.pop();
}

function currentLoop(emitter) {
    if (emitter.loopStack.length == 0) {
        return null;
    }
    return emitter.loopStack[emitter.loopStack.length - 1];
}

// ============================================================================
// Scope Management for Local Variables
// ============================================================================

function createScope(parent) {
    return {
        parent: parent,
        locals: [],        // Array of {name, slot} pairs
        nextSlot: 0
    };
}

function scopeDefine(scope, name) {
    let slot = scope.nextSlot;
    // Store as array entry to work around VM object property issues
    scope.locals.push({ name: name, slot: slot });
    scope.nextSlot = scope.nextSlot + 1;
    return slot;
}

function scopeResolve(scope, name) {
    // Search through array of locals
    let i = 0;
    while (i < scope.locals.length) {
        let entry = scope.locals[i];
        if (entry.name == name) {
            return entry.slot;
        }
        i = i + 1;
    }
    return -1;  // Not a local
}

// ============================================================================
// Local Variable Emission Helpers
// ============================================================================

function emitStoreLocal(emitter, slot) {
    emitU8(emitter, OP.STORE_LOCAL);
    emitU32(emitter, slot);
}

function emitLoadLocal(emitter, slot) {
    emitU8(emitter, OP.LOAD_LOCAL);
    emitU32(emitter, slot);
}

// ============================================================================
// Main Emit Function (AST Visitor)
// ============================================================================

function emit(emitter, node) {
    if (node == null) {
        return;
    }

    if (node.type == "Program") {
        emitProgram(emitter, node);
    } else if (node.type == "VariableDeclaration") {
        emitVariableDeclaration(emitter, node);
    } else if (node.type == "FunctionDeclaration") {
        emitFunctionDeclaration(emitter, node);
    } else if (node.type == "ReturnStatement") {
        emitReturnStatement(emitter, node);
    } else if (node.type == "IfStatement") {
        emitIfStatement(emitter, node);
    } else if (node.type == "WhileStatement") {
        emitWhileStatement(emitter, node);
    } else if (node.type == "BlockStatement") {
        emitBlockStatement(emitter, node);
    } else if (node.type == "ExpressionStatement") {
        emitExpressionStatement(emitter, node);
    } else if (node.type == "BinaryExpression") {
        emitBinaryExpression(emitter, node);
    } else if (node.type == "UnaryExpression") {
        emitUnaryExpression(emitter, node);
    } else if (node.type == "AssignmentExpression") {
        emitAssignmentExpression(emitter, node);
    } else if (node.type == "CallExpression") {
        emitCallExpression(emitter, node);
    } else if (node.type == "MemberExpression") {
        emitMemberExpression(emitter, node);
    } else if (node.type == "Identifier") {
        emitIdentifier(emitter, node);
    } else if (node.type == "Literal") {
        emitLiteral(emitter, node);
    } else if (node.type == "ArrayExpression") {
        emitArrayExpression(emitter, node);
    } else if (node.type == "ObjectExpression") {
        emitObjectExpression(emitter, node);
    } else if (node.type == "NewExpression") {
        emitNewExpression(emitter, node);
    } else if (node.type == "ThisExpression") {
        emitThisExpression(emitter, node);
    } else if (node.type == "ArrowFunctionExpression" || node.type == "FunctionExpression") {
        emitFunctionExpression(emitter, node);
    } else if (node.type == "BreakStatement") {
        emitBreakStatement(emitter, node);
    } else if (node.type == "ContinueStatement") {
        emitContinueStatement(emitter, node);
    } else {
        console.log("Unknown node type:", node.type);
    }
}

// ============================================================================
// Statement Emitters
// ============================================================================

function emitProgram(emitter, node) {
    let i = 0;
    while (i < node.body.length) {
        emit(emitter, node.body[i]);
        i = i + 1;
    }
    // End program with HALT
    emitU8(emitter, OP.HALT);
}

function emitBlockStatement(emitter, node) {
    let i = 0;
    while (i < node.body.length) {
        emit(emitter, node.body[i]);
        i = i + 1;
    }
}

function emitExpressionStatement(emitter, node) {
    emit(emitter, node.expression);
    // Pop the result (expression statements don't keep their value)
    emitU8(emitter, OP.POP);
}

function emitVariableDeclaration(emitter, node) {
    if (node.init != null) {
        // Emit the initializer
        emit(emitter, node.init);
    } else {
        // Push undefined
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.UNDEFINED);
    }
    // Store in variable (local or global)
    if (emitter.scope != null) {
        // Inside function - define and store as indexed local
        let slot = scopeDefine(emitter.scope, node.name);
        emitStoreLocal(emitter, slot);
    } else {
        // Global scope - use string-based store
        emitU8(emitter, OP.STORE);
        emitString(emitter, node.name);
    }
}

function emitFunctionDeclaration(emitter, node) {
    // Jump over the function body
    emitU8(emitter, OP.JUMP);
    let jumpPatch = currentOffset(emitter);
    emitU32(emitter, 0); // placeholder

    // Record function start address
    let funcAddr = currentOffset(emitter);

    // Create new scope for function
    let outerScope = emitter.scope;
    emitter.scope = createScope(null);

    // Register parameters as locals 0, 1, 2, ...
    let i = 0;
    while (i < node.params.length) {
        scopeDefine(emitter.scope, node.params[i]);
        i = i + 1;
    }

    // Emit prologue: pop args into local slots (reverse order)
    // Args are on stack in order: arg0, arg1, arg2, ...
    // We pop them in reverse order into their slots
    i = node.params.length - 1;
    while (i >= 0) {
        emitStoreLocal(emitter, i);
        i = i - 1;
    }

    // Emit function body (with scope active)
    emit(emitter, node.body);

    // Restore outer scope
    emitter.scope = outerScope;

    // Ensure function returns (implicit return undefined)
    emitU8(emitter, OP.PUSH);
    emitU8(emitter, TYPE.UNDEFINED);
    emitU8(emitter, OP.RETURN);

    // Patch the jump
    patchU32(emitter, jumpPatch, currentOffset(emitter));

    // Push empty environment object for closure (required by VM)
    emitU8(emitter, OP.NEW_OBJECT);

    // Create closure and store
    emitU8(emitter, OP.MAKE_CLOSURE);
    emitU32(emitter, funcAddr);
    emitU8(emitter, node.params.length);
    // Emit parameter names
    i = 0;
    while (i < node.params.length) {
        emitString(emitter, node.params[i]);
        i = i + 1;
    }

    // Store in variable
    emitU8(emitter, OP.STORE);
    emitString(emitter, node.name);
}

function emitReturnStatement(emitter, node) {
    if (node.argument != null) {
        emit(emitter, node.argument);
    } else {
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.UNDEFINED);
    }
    emitU8(emitter, OP.RETURN);
}

function emitIfStatement(emitter, node) {
    // Emit test expression
    emit(emitter, node.test);

    // Jump if false to else/end
    emitU8(emitter, OP.JUMP_IF_FALSE);
    let falsePatch = currentOffset(emitter);
    emitU32(emitter, 0); // placeholder

    // Emit consequent
    emit(emitter, node.consequent);

    if (node.alternate != null) {
        // Jump over else
        emitU8(emitter, OP.JUMP);
        let endPatch = currentOffset(emitter);
        emitU32(emitter, 0); // placeholder

        // Patch false jump to here
        patchU32(emitter, falsePatch, currentOffset(emitter));

        // Emit alternate
        emit(emitter, node.alternate);

        // Patch end jump
        patchU32(emitter, endPatch, currentOffset(emitter));
    } else {
        // Patch false jump to here
        patchU32(emitter, falsePatch, currentOffset(emitter));
    }
}

function emitWhileStatement(emitter, node) {
    // Push loop context
    pushLoop(emitter);

    // Record loop start
    let loopStart = currentOffset(emitter);

    // Set continue target
    currentLoop(emitter).continueTarget = loopStart;

    // Emit test
    emit(emitter, node.test);

    // Jump if false to end
    emitU8(emitter, OP.JUMP_IF_FALSE);
    let endPatch = currentOffset(emitter);
    emitU32(emitter, 0); // placeholder

    // Emit body
    emit(emitter, node.body);

    // Jump back to start
    emitU8(emitter, OP.JUMP);
    emitU32(emitter, loopStart);

    // Patch end jump
    patchU32(emitter, endPatch, currentOffset(emitter));

    // Patch all break statements
    let loop = popLoop(emitter);
    let i = 0;
    while (i < loop.breakPatches.length) {
        patchU32(emitter, loop.breakPatches[i], currentOffset(emitter));
        i = i + 1;
    }
}

function emitBreakStatement(emitter, node) {
    let loop = currentLoop(emitter);
    if (loop == null) {
        console.log("Error: break outside of loop");
        return;
    }
    emitU8(emitter, OP.JUMP);
    loop.breakPatches.push(currentOffset(emitter));
    emitU32(emitter, 0); // placeholder
}

function emitContinueStatement(emitter, node) {
    let loop = currentLoop(emitter);
    if (loop == null) {
        console.log("Error: continue outside of loop");
        return;
    }
    emitU8(emitter, OP.JUMP);
    emitU32(emitter, loop.continueTarget);
}

// ============================================================================
// Expression Emitters
// ============================================================================

function emitBinaryExpression(emitter, node) {
    // Save properties FIRST before any recursive calls
    let operator = node.operator;
    let left = node.left;
    let right = node.right;

    // Emit left operand
    emit(emitter, left);
    // Emit right operand
    emit(emitter, right);
    // Emit operator
    let opcode = getOpCodeForBinaryOp(operator);
    if (opcode == -1) {
        console.log("Unknown binary operator:", operator);
        return;
    }
    emitU8(emitter, opcode);
}

function emitUnaryExpression(emitter, node) {
    // Save before recursive calls
    let operator = node.operator;
    let argument = node.argument;

    emit(emitter, argument);
    let opcode = getOpCodeForUnaryOp(operator);
    if (opcode == -1) {
        console.log("Unknown unary operator:", operator);
        return;
    }
    emitU8(emitter, opcode);
}

function emitAssignmentExpression(emitter, node) {
    // Handle different assignment targets
    if (node.left.type == "Identifier") {
        // Simple variable assignment: x = value
        emit(emitter, node.right);        // Push value
        emitU8(emitter, OP.DUP);          // DUP for expression result

        // Check if variable is a local in current scope
        let isLocal = false;
        let slot = -1;
        if (emitter.scope != null) {
            slot = scopeResolve(emitter.scope, node.left.name);
            if (slot != -1) {
                isLocal = true;
            }
        }

        if (isLocal) {
            emitStoreLocal(emitter, slot);
        } else {
            emitU8(emitter, OP.STORE);
            emitString(emitter, node.left.name);
        }
    } else if (node.left.type == "MemberExpression") {
        // Property assignment: obj.prop = value or obj[key] = value
        // SET_PROP(name) pops: value, obj; sets obj[name] = value
        // Stack should end with: value (the expression result)

        emit(emitter, node.left.object);  // Push obj
        emit(emitter, node.right);        // Push value
        emitU8(emitter, OP.DUP);          // Stack: obj, value, value

        if (node.left.computed) {
            // obj[key] = value - STORE_ELEMENT pops: index, value, array
            emit(emitter, node.left.property);  // Push key
            emitU8(emitter, OP.STORE_ELEMENT);
        } else {
            // obj.prop = value - SET_PROP pops: value, obj
            emitU8(emitter, OP.SET_PROP);
            emitString(emitter, node.left.property.name);
        }
        // Stack now: value (the expression result)
    } else {
        console.log("Invalid assignment target:", node.left.type);
    }
}

function emitCallExpression(emitter, node) {
    if (node.callee.type == "MemberExpression") {
        // Method call: obj.method(args)
        // Emit arguments FIRST (they go on stack before receiver)
        let i = 0;
        while (i < node.arguments.length) {
            emit(emitter, node.arguments[i]);
            i = i + 1;
        }
        // Emit object/receiver LAST (CallMethod pops receiver first)
        emit(emitter, node.callee.object);
        // Call method
        emitU8(emitter, OP.CALL_METHOD);
        if (node.callee.computed) {
            // Dynamic method name - need different handling
            console.log("TODO: computed method calls");
        } else {
            emitString(emitter, node.callee.property.name);
        }
        emitU8(emitter, node.arguments.length);
    } else {
        // Regular function call
        // Emit arguments first
        let i = 0;
        while (i < node.arguments.length) {
            emit(emitter, node.arguments[i]);
            i = i + 1;
        }
        // Emit callee
        emit(emitter, node.callee);
        // Call
        emitU8(emitter, OP.CALL);
        emitU8(emitter, node.arguments.length);
    }
}

function emitMemberExpression(emitter, node) {
    // Emit object
    emit(emitter, node.object);

    if (node.computed) {
        // Computed: obj[expr]
        emit(emitter, node.property);
        emitU8(emitter, OP.LOAD_ELEMENT);
    } else {
        // Non-computed: obj.prop
        emitU8(emitter, OP.GET_PROP);
        emitString(emitter, node.property.name);
    }
}

function emitIdentifier(emitter, node) {
    // Check if variable is a local in current scope
    let isLocal = false;
    let slot = -1;

    if (emitter.scope != null) {
        slot = scopeResolve(emitter.scope, node.name);
        if (slot != -1) {
            isLocal = true;
        }
    }

    if (isLocal) {
        // Local variable - use indexed access
        emitLoadLocal(emitter, slot);
    } else {
        // Global or not found locally - use string-based load
        emitU8(emitter, OP.LOAD);
        emitString(emitter, node.name);
    }
}

function emitLiteral(emitter, node) {
    // Save node properties before any operations
    let literalType = node.literalType;
    let value = node.value;

    emitU8(emitter, OP.PUSH);

    if (literalType == "null") {
        emitU8(emitter, TYPE.NULL);
    } else if (literalType == "boolean") {
        if (value == true) {
            emitU8(emitter, TYPE.TRUE);
        } else {
            emitU8(emitter, TYPE.FALSE);
        }
    } else if (literalType == "number") {
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, value);
    } else if (literalType == "string") {
        emitU8(emitter, TYPE.STRING);
        emitString(emitter, value);
    } else {
        // Fallback: treat as string
        console.log("Warning: unknown literal type:", literalType);
        emitU8(emitter, TYPE.STRING);
        emitString(emitter, value);
    }
}

function emitArrayExpression(emitter, node) {
    // Create new array
    emitU8(emitter, OP.NEW_ARRAY);

    // Add elements
    let i = 0;
    while (i < node.elements.length) {
        emitU8(emitter, OP.DUP); // Keep array on stack
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, i); // Index
        emit(emitter, node.elements[i]); // Value
        emitU8(emitter, OP.STORE_ELEMENT);
        i = i + 1;
    }
}

function emitObjectExpression(emitter, node) {
    // Create new object
    emitU8(emitter, OP.NEW_OBJECT);

    // Add properties
    let i = 0;
    while (i < node.properties.length) {
        let prop = node.properties[i];
        emitU8(emitter, OP.DUP); // Keep object on stack

        // Property value (emit first, will be popped by SET_PROP)
        emit(emitter, prop.value);

        // SET_PROP expects property name in bytecode, not on stack
        emitU8(emitter, OP.SET_PROP);
        if (prop.key.type == "Identifier") {
            emitString(emitter, prop.key.name);
        } else if (prop.key.type == "Literal") {
            emitString(emitter, prop.key.value);
        }

        i = i + 1;
    }
}

function emitNewExpression(emitter, node) {
    // Emit arguments
    let i = 0;
    while (i < node.arguments.length) {
        emit(emitter, node.arguments[i]);
        i = i + 1;
    }
    // Emit constructor
    emit(emitter, node.callee);
    // Construct
    emitU8(emitter, OP.CONSTRUCT);
    emitU8(emitter, node.arguments.length);
}

function emitThisExpression(emitter, node) {
    emitU8(emitter, OP.LOAD_THIS);
}

function emitFunctionExpression(emitter, node) {
    // Jump over the function body
    emitU8(emitter, OP.JUMP);
    let jumpPatch = currentOffset(emitter);
    emitU32(emitter, 0); // placeholder

    // Record function start address
    let funcAddr = currentOffset(emitter);

    // Create new scope for function
    let outerScope = emitter.scope;
    emitter.scope = createScope(null);

    // Register parameters as locals 0, 1, 2, ...
    let i = 0;
    while (i < node.params.length) {
        scopeDefine(emitter.scope, node.params[i]);
        i = i + 1;
    }

    // Emit prologue: pop args into local slots (reverse order)
    i = node.params.length - 1;
    while (i >= 0) {
        emitStoreLocal(emitter, i);
        i = i - 1;
    }

    // Emit function body (with scope active)
    if (node.body.type == "BlockStatement") {
        emit(emitter, node.body);
    } else {
        // Arrow function with expression body
        emit(emitter, node.body);
        emitU8(emitter, OP.RETURN);
    }

    // Restore outer scope
    emitter.scope = outerScope;

    // Ensure function returns (implicit return undefined)
    emitU8(emitter, OP.PUSH);
    emitU8(emitter, TYPE.UNDEFINED);
    emitU8(emitter, OP.RETURN);

    // Patch the jump
    patchU32(emitter, jumpPatch, currentOffset(emitter));

    // Push empty environment object for closure (required by VM)
    emitU8(emitter, OP.NEW_OBJECT);

    // Create closure
    emitU8(emitter, OP.MAKE_CLOSURE);
    emitU32(emitter, funcAddr);
    emitU8(emitter, node.params.length);
    // Emit parameter names
    i = 0;
    while (i < node.params.length) {
        emitString(emitter, node.params[i]);
        i = i + 1;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

function compile(source) {
    // Parse source to AST
    let ast = parseSource(source);
    if (ast == null) {
        console.log("Parse error");
        return null;
    }

    // Create emitter
    let emitter = createEmitter();

    // Emit header: "TSCL" (4 bytes) + version (1 byte) + reserved (3 bytes)
    emitU8(emitter, 0x54); // 'T'
    emitU8(emitter, 0x53); // 'S'
    emitU8(emitter, 0x43); // 'C'
    emitU8(emitter, 0x4C); // 'L'
    emitU8(emitter, 0x01); // Version 1
    emitU8(emitter, 0x00); // Reserved
    emitU8(emitter, 0x00); // Reserved
    emitU8(emitter, 0x00); // Reserved

    // Emit bytecode
    emit(emitter, ast);

    return emitter.stream;
}

function compileToFile(source, outputPath) {
    let bytecode = compile(source);
    if (bytecode == null) {
        return false;
    }
    File.writeBinarySync(outputPath, bytecode);
    return true;
}
