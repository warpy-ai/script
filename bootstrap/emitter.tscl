// ============================================================================
// Bootstrap Emitter for tscl
// Transforms AST to bytecode using ByteStream
// Requires: std/prelude.tscl, bootstrap/lexer.tscl, and bootstrap/parser.tscl
// ============================================================================

// ============================================================================
// Emitter State
// ============================================================================

function createEmitter() {
    return {
        stream: ByteStream.create(),
        functions: {},
        patches: [],
        loopStack: [],
        scope: null
    };
}

// ============================================================================
// ByteStream Helpers
// ============================================================================

function emitU8(emitter, byte) {
    ByteStream.writeU8(emitter.stream, byte);
}

function emitU32(emitter, value) {
    ByteStream.writeU32(emitter.stream, value);
}

function emitF64(emitter, value) {
    ByteStream.writeF64(emitter.stream, value);
}

function emitVarint(emitter, value) {
    ByteStream.writeVarint(emitter.stream, value);
}

function emitString(emitter, str) {
    ByteStream.writeString(emitter.stream, str);
}

function currentOffset(emitter) {
    return ByteStream.length(emitter.stream);
}

function patchU32(emitter, offset, value) {
    ByteStream.patchU32(emitter.stream, offset, value);
}

// ============================================================================
// Loop Stack Management (for break/continue)
// ============================================================================

function pushLoop(emitter) {
    emitter.loopStack.push({
        breakPatches: [],
        continueTarget: -1
    });
}

function popLoop(emitter) {
    return emitter.loopStack.pop();
}

function currentLoop(emitter) {
    if (emitter.loopStack.length == 0) {
        return null;
    }
    return emitter.loopStack[emitter.loopStack.length - 1];
}

// ============================================================================
// Scope Management for Local Variables
// ============================================================================

function createScope(parent) {
    return {
        parent: parent,
        locals: [],
        nextSlot: 0
    };
}

function scopeDefine(scope, name) {
    let slot = scope.nextSlot;
    scope.locals.push({ name: name, slot: slot });
    scope.nextSlot = scope.nextSlot + 1;
    return slot;
}

function scopeResolve(scope, name) {
    let i = 0;
    while (i < scope.locals.length) {
        let entry = scope.locals[i];
        if (entry.name == name) {
            return entry.slot;
        }
        i = i + 1;
    }
    return -1;
}

// ============================================================================
// Local Variable Emission Helpers
// ============================================================================

function emitStoreLocal(emitter, slot) {
    emitU8(emitter, OP.STORE_LOCAL);
    emitU32(emitter, slot);
}

function emitLoadLocal(emitter, slot) {
    emitU8(emitter, OP.LOAD_LOCAL);
    emitU32(emitter, slot);
}

// ============================================================================
// Operator Code Mapping
// ============================================================================

function getOpCodeForBinaryOp(operator) {
    if (operator == "+") { return 2; }
    if (operator == "-") { return 3; }
    if (operator == "*") { return 4; }
    if (operator == "/") { return 5; }
    if (operator == "%") { return 36; }
    if (operator == "**") { return 37; }
    if (operator == "===") { return 38; }
    if (operator == "==") { return 39; }
    if (operator == "!==") { return 40; }
    if (operator == "!=") { return 41; }
    if (operator == "<") { return 22; }
    if (operator == "<=") { return 23; }
    if (operator == ">") { return 24; }
    if (operator == ">=") { return 25; }
    if (operator == "<<") { return 46; }
    if (operator == ">>") { return 47; }
    if (operator == ">>>") { return 48; }
    if (operator == "&") { return 49; }
    if (operator == "^") { return 50; }
    if (operator == "|") { return 51; }
    if (operator == "&&") { return 27; }
    if (operator == "||") { return 28; }
    return -1;
}

function getOpCodeForUnaryOp(operator) {
    if (operator == "-") { return 30; }
    if (operator == "!") { return 29; }
    if (operator == "~") { return 66; }
    if (operator == "+") { return 67; }
    return -1;
}

// ============================================================================
// Main Emit Function (AST Visitor)
// ============================================================================

function emit(emitter, node) {
    if (node == null) {
        return;
    }

    let type = node.type;

    if (type == "Program") {
        emitProgram(emitter, node);
        return;
    }
    if (type == "VariableDeclaration") {
        emitVariableDeclaration(emitter, node);
        return;
    }
    if (type == "FunctionDeclaration") {
        emitFunctionDeclaration(emitter, node);
        return;
    }
    if (type == "ReturnStatement") {
        emitReturnStatement(emitter, node);
        return;
    }
    if (type == "IfStatement") {
        emitIfStatement(emitter, node);
        return;
    }
    if (type == "WhileStatement") {
        emitWhileStatement(emitter, node);
        return;
    }
    if (type == "BlockStatement") {
        emitBlockStatement(emitter, node);
        return;
    }
    if (type == "ExpressionStatement") {
        emitExpressionStatement(emitter, node);
        return;
    }
    if (type == "BinaryExpression") {
        emitBinaryExpression(emitter, node);
        return;
    }
    if (type == "UnaryExpression") {
        emitUnaryExpression(emitter, node);
        return;
    }
    if (type == "AssignmentExpression") {
        emitAssignmentExpression(emitter, node);
        return;
    }
    if (type == "CallExpression") {
        emitCallExpression(emitter, node);
        return;
    }
    if (type == "MemberExpression") {
        emitMemberExpression(emitter, node);
        return;
    }
    if (type == "Identifier") {
        emitIdentifier(emitter, node);
        return;
    }
    if (type == "Literal") {
        emitLiteral(emitter, node);
        return;
    }
    if (type == "ArrayExpression") {
        emitArrayExpression(emitter, node);
        return;
    }
    if (type == "ObjectExpression") {
        emitObjectExpression(emitter, node);
        return;
    }
    if (type == "NewExpression") {
        emitNewExpression(emitter, node);
        return;
    }
    if (type == "ThisExpression") {
        emitThisExpression(emitter, node);
        return;
    }
    if (type == "ArrowFunctionExpression" || type == "FunctionExpression") {
        emitFunctionExpression(emitter, node);
        return;
    }
    if (type == "BreakStatement") {
        emitBreakStatement(emitter, node);
        return;
    }
    if (type == "ContinueStatement") {
        emitContinueStatement(emitter, node);
        return;
    }
    if (type == "EmptyStatement") {
        return;
    }
    if (type == "ForStatement") {
        emitForStatement(emitter, node);
        return;
    }
    console.log("Unknown node type:", type);
}

// ============================================================================
// Statement Emitters
// ============================================================================

function emitProgram(emitter, node) {
    let i = 0;
    while (i < node.body.length) {
        emit(emitter, node.body[i]);
        i = i + 1;
    }
    emitU8(emitter, OP.HALT);
}

function emitBlockStatement(emitter, node) {
    let i = 0;
    while (i < node.body.length) {
        emit(emitter, node.body[i]);
        i = i + 1;
    }
}

function emitExpressionStatement(emitter, node) {
    emit(emitter, node.expression);
    emitU8(emitter, OP.POP);
}

function emitVariableDeclaration(emitter, node) {
    if (node.init != null) {
        emit(emitter, node.init);
    } else {
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.UNDEFINED);
    }
    if (emitter.scope != null) {
        let slot = scopeDefine(emitter.scope, node.name);
        emitStoreLocal(emitter, slot);
    } else {
        emitU8(emitter, OP.STORE);
        emitString(emitter, node.name);
    }
}

function emitFunctionDeclaration(emitter, node) {
    emitU8(emitter, OP.JUMP);
    let jumpPatch = currentOffset(emitter);
    emitU32(emitter, 0);

    let funcAddr = currentOffset(emitter);

    let outerScope = emitter.scope;
    emitter.scope = createScope(null);

    let i = 0;
    while (i < node.params.length) {
        scopeDefine(emitter.scope, node.params[i]);
        i = i + 1;
    }

    i = node.params.length - 1;
    while (i >= 0) {
        emitStoreLocal(emitter, i);
        i = i - 1;
    }

    emit(emitter, node.body);

    emitter.scope = outerScope;

    emitU8(emitter, OP.PUSH);
    emitU8(emitter, TYPE.UNDEFINED);
    emitU8(emitter, OP.RETURN);

    patchU32(emitter, jumpPatch, currentOffset(emitter));

    emitU8(emitter, OP.NEW_OBJECT);

    emitU8(emitter, OP.MAKE_CLOSURE);
    emitU32(emitter, funcAddr);
    emitU8(emitter, node.params.length);

    i = 0;
    while (i < node.params.length) {
        emitString(emitter, node.params[i]);
        i = i + 1;
    }

    emitU8(emitter, OP.STORE);
    emitString(emitter, node.name);
}

function emitReturnStatement(emitter, node) {
    if (node.argument != null) {
        emit(emitter, node.argument);
    } else {
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.UNDEFINED);
    }
    emitU8(emitter, OP.RETURN);
}

function emitIfStatement(emitter, node) {
    emit(emitter, node.test);

    emitU8(emitter, OP.JUMP_IF_FALSE);
    let falsePatch = currentOffset(emitter);
    emitU32(emitter, 0);

    emit(emitter, node.consequent);

    if (node.alternate != null) {
        emitU8(emitter, OP.JUMP);
        let endPatch = currentOffset(emitter);
        emitU32(emitter, 0);

        patchU32(emitter, falsePatch, currentOffset(emitter));

        emit(emitter, node.alternate);

        patchU32(emitter, endPatch, currentOffset(emitter));
    } else {
        patchU32(emitter, falsePatch, currentOffset(emitter));
    }
}

function emitWhileStatement(emitter, node) {
    pushLoop(emitter);

    let loopStart = currentOffset(emitter);
    let loop = currentLoop(emitter);
    if (loop != null) {
        loop.continueTarget = loopStart;
    }

    emit(emitter, node.test);

    emitU8(emitter, OP.JUMP_IF_FALSE);
    let endPatch = currentOffset(emitter);
    emitU32(emitter, 0);

    emit(emitter, node.body);

    emitU8(emitter, OP.JUMP);
    emitU32(emitter, loopStart);

    patchU32(emitter, endPatch, currentOffset(emitter));

    let loopInfo = popLoop(emitter);
    if (loopInfo != null) {
        let j = 0;
        while (j < loopInfo.breakPatches.length) {
            patchU32(emitter, loopInfo.breakPatches[j], currentOffset(emitter));
            j = j + 1;
        }
    }
}

function emitForStatement(emitter, node) {
    let forNode = node;

    if (forNode.init != null) {
        emit(emitter, forNode.init);
    }

    let loopStart = currentOffset(emitter);

    if (forNode.test != null) {
        emit(emitter, forNode.test);
        emitU8(emitter, OP.JUMP_IF_FALSE);
        let endPatch = currentOffset(emitter);
        emitU32(emitter, 0);

        emit(emitter, forNode.body);

        if (forNode.update != null) {
            emit(emitter, forNode.update);
            emitU8(emitter, OP.POP);
        }

        emitU8(emitter, OP.JUMP);
        emitU32(emitter, loopStart);

        patchU32(emitter, endPatch, currentOffset(emitter));
    }
}

function emitBreakStatement(emitter, node) {
    let loop = currentLoop(emitter);
    if (loop == null) {
        console.log("Error: break outside of loop");
        return;
    }
    emitU8(emitter, OP.JUMP);
    loop.breakPatches.push(currentOffset(emitter));
    emitU32(emitter, 0);
}

function emitContinueStatement(emitter, node) {
    let loop = currentLoop(emitter);
    if (loop == null) {
        console.log("Error: continue outside of loop");
        return;
    }
    emitU8(emitter, OP.JUMP);
    emitU32(emitter, loop.continueTarget);
}

// ============================================================================
// Expression Emitters
// ============================================================================

function emitBinaryExpression(emitter, node) {
    let operator = node.operator;
    let left = node.left;
    let right = node.right;

    emit(emitter, left);
    emit(emitter, right);

    let opcode = getOpCodeForBinaryOp(operator);
    if (opcode == -1) {
        console.log("Unknown binary operator:", operator);
        return;
    }
    emitU8(emitter, opcode);
    return;
}

function emitUnaryExpression(emitter, node) {
    let operator = node.operator;
    let argument = node.argument;

    emit(emitter, argument);

    let opcode = getOpCodeForUnaryOp(operator);
    if (opcode == -1) {
        console.log("Unknown unary operator:", operator);
        return;
    }
    emitU8(emitter, opcode);
    return;
}

function emitAssignmentExpression(emitter, node) {
    let left = node.left;
    let right = node.right;

    if (left.type == "Identifier") {
        emit(emitter, right);
        emitU8(emitter, OP.DUP);

        let isLocal = false;
        let slot = -1;
        if (emitter.scope != null) {
            slot = scopeResolve(emitter.scope, left.name);
            if (slot != -1) {
                isLocal = true;
            }
        }

        if (isLocal) {
            emitStoreLocal(emitter, slot);
        } else {
            emitU8(emitter, OP.STORE);
            emitString(emitter, left.name);
        }
    } else if (left.type == "MemberExpression") {
        emit(emitter, left.object);
        emit(emitter, right);
        emitU8(emitter, OP.DUP);

        if (left.computed) {
            emit(emitter, left.property);
            emitU8(emitter, OP.STORE_ELEMENT);
        } else {
            emitU8(emitter, OP.SET_PROP);
            let propName = "";
            if (left.property.type == "Identifier") {
                propName = left.property.name;
            }
            emitString(emitter, propName);
        }
    } else {
        console.log("Invalid assignment target:", left.type);
    }
    return;
}

function emitCallExpression(emitter, node) {
    let callee = node.callee;
    let arguments = node.arguments;

    if (callee.type == "MemberExpression") {
        let i = 0;
        while (i < arguments.length) {
            emit(emitter, arguments[i]);
            i = i + 1;
        }
        emit(emitter, callee.object);
        emitU8(emitter, OP.CALL_METHOD);
        if (!callee.computed) {
            let methodName = "";
            if (callee.property.type == "Identifier") {
                methodName = callee.property.name;
            }
            emitString(emitter, methodName);
        }
        emitU8(emitter, arguments.length);
    } else {
        let i = 0;
        while (i < arguments.length) {
            emit(emitter, arguments[i]);
            i = i + 1;
        }
        emit(emitter, callee);
        emitU8(emitter, OP.CALL);
        emitU8(emitter, arguments.length);
    }
    return;
}

function emitMemberExpression(emitter, node) {
    emit(emitter, node.object);

    if (node.computed) {
        emit(emitter, node.property);
        emitU8(emitter, OP.LOAD_ELEMENT);
    } else {
        emitU8(emitter, OP.GET_PROP);
        let propName = "";
        if (node.property.type == "Identifier") {
            propName = node.property.name;
        }
        emitString(emitter, propName);
    }
    return;
}

function emitIdentifier(emitter, node) {
    let isLocal = false;
    let slot = -1;

    if (emitter.scope != null) {
        slot = scopeResolve(emitter.scope, node.name);
        if (slot != -1) {
            isLocal = true;
        }
    }

    if (isLocal) {
        emitLoadLocal(emitter, slot);
    } else {
        emitU8(emitter, OP.LOAD);
        emitString(emitter, node.name);
    }
    return;
}

function emitLiteral(emitter, node) {
    let literalType = node.literalType;
    let value = node.value;

    emitU8(emitter, OP.PUSH);

    if (literalType == "null") {
        emitU8(emitter, TYPE.NULL);
    } else if (literalType == "boolean") {
        if (value == true) {
            emitU8(emitter, TYPE.TRUE);
        } else {
            emitU8(emitter, TYPE.FALSE);
        }
    } else if (literalType == "number") {
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, value);
    } else if (literalType == "string") {
        emitU8(emitter, TYPE.STRING);
        emitString(emitter, value);
    } else {
        console.log("Warning: unknown literal type:", literalType);
        emitU8(emitter, TYPE.STRING);
        emitString(emitter, value);
    }
    return;
}

function emitArrayExpression(emitter, node) {
    emitU8(emitter, OP.NEW_ARRAY);

    let i = 0;
    while (i < node.elements.length) {
        emitU8(emitter, OP.DUP);
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, i);
        let element = node.elements[i];
        if (element != null) {
            emit(emitter, element);
        }
        emitU8(emitter, OP.STORE_ELEMENT);
        i = i + 1;
    }
    return;
}

function emitObjectExpression(emitter, node) {
    emitU8(emitter, OP.NEW_OBJECT);

    let i = 0;
    while (i < node.properties.length) {
        let prop = node.properties[i];
        emitU8(emitter, OP.DUP);
        emit(emitter, prop.value);
        emitU8(emitter, OP.SET_PROP);
        let keyName = "";
        if (prop.key.type == "Identifier") {
            keyName = prop.key.name;
        } else if (prop.key.type == "Literal") {
            keyName = prop.key.value;
        }
        emitString(emitter, keyName);
        i = i + 1;
    }
    return;
}

function emitNewExpression(emitter, node) {
    let i = 0;
    while (i < node.arguments.length) {
        emit(emitter, node.arguments[i]);
        i = i + 1;
    }
    emit(emitter, node.callee);
    emitU8(emitter, OP.CONSTRUCT);
    emitU8(emitter, node.arguments.length);
    return;
}

function emitThisExpression(emitter, node) {
    emitU8(emitter, OP.LOAD_THIS);
    return;
}

function emitFunctionExpression(emitter, node) {
    let funcNode = node;

    emitU8(emitter, OP.JUMP);
    let jumpPatch = currentOffset(emitter);
    emitU32(emitter, 0);

    let funcAddr = currentOffset(emitter);

    let outerScope = emitter.scope;
    emitter.scope = createScope(null);

    let i = 0;
    while (i < funcNode.params.length) {
        scopeDefine(emitter.scope, funcNode.params[i]);
        i = i + 1;
    }

    i = funcNode.params.length - 1;
    while (i >= 0) {
        emitStoreLocal(emitter, i);
        i = i - 1;
    }

    if (funcNode.body.type == "BlockStatement") {
        emit(emitter, funcNode.body);
    } else {
        emit(emitter, funcNode.body);
        emitU8(emitter, OP.RETURN);
    }

    emitter.scope = outerScope;

    emitU8(emitter, OP.PUSH);
    emitU8(emitter, TYPE.UNDEFINED);
    emitU8(emitter, OP.RETURN);

    patchU32(emitter, jumpPatch, currentOffset(emitter));

    emitU8(emitter, OP.NEW_OBJECT);

    emitU8(emitter, OP.MAKE_CLOSURE);
    emitU32(emitter, funcAddr);
    emitU8(emitter, funcNode.params.length);

    i = 0;
    while (i < funcNode.params.length) {
        emitString(emitter, funcNode.params[i]);
        i = i + 1;
    }
    return;
}

// ============================================================================
// Main Entry Point
// ============================================================================

function compile(source) {
    let ast = parseSource(source);
    if (ast == null) {
        console.log("Parse error");
        return null;
    }

    let emitter = createEmitter();

    emitU8(emitter, 84);
    emitU8(emitter, 83);
    emitU8(emitter, 67);
    emitU8(emitter, 76);
    emitU8(emitter, 1);
    emitU8(emitter, 0);
    emitU8(emitter, 0);
    emitU8(emitter, 0);

    emit(emitter, ast);

    console.log("Compilation complete");
    return emitter.stream;
}

function compileToFile(source, outputPath) {
    let bytecode = compile(source);
    if (bytecode == null) {
        return false;
    }
    fs.writeBinaryFile(outputPath, bytecode);
    return true;
}
