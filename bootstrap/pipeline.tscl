// ============================================================================
// Bootstrap Compiler Pipeline
// Unified compilation: Source → Lexer → Parser → IR → Bytecode
// ============================================================================

require ./lexer;
require ./parser;
require ./ir;
require ./ir_builder;
require ./codegen;

// ============================================================================
// Compilation Pipeline
// ============================================================================

function compileToBytecode(source: string): { bytecode: ByteStream, length: number } | null {
    let tokens: Array<Token> = tokenize(source);
    if (tokens == null) {
        console.log("Error: Lexing failed");
        return null;
    }

    let ast: Program = parseSource(source);
    if (ast == null) {
        console.log("Error: Parsing failed");
        return null;
    }

    let module: IrModule = lowerProgramToIr(ast);
    if (module == null) {
        console.log("Error: IR lowering failed");
        return null;
    }

    let result: { bytecode: ByteStream, length: number } = codegenIrModule(module);
    return result;
}

function compileAndVerify(source: string): { bytecode: ByteStream, length: number } | null {
    let result: { bytecode: ByteStream, length: number } | null = compileToBytecode(source);
    if (result == null) {
        return null;
    }
    return result;
}

// ============================================================================
// Module Compilation
// ============================================================================

function compileModule(source: string): { bytecode: ByteStream, length: number } | null {
    let bytecode: { bytecode: ByteStream, length: number } | null = compileToBytecode(source);
    if (bytecode == null) {
        return null;
    }
    return bytecode;
}

function compileFile(filePath: string): { bytecode: ByteStream, length: number } | null {
    if (!fs.existsSync(filePath)) {
        console.log("Error: File not found: " + filePath);
        return null;
    }
    let source: string = fs.readFileSync(filePath, "utf8");
    return compileToBytecode(source);
}

function saveBytecode(filePath: string, bytecode: { bytecode: ByteStream, length: number } | ByteStream): number {
    let stream: ByteStream = bytecode;
    if (typeof bytecode === "object" && bytecode.bytecode != null) {
        stream = bytecode.bytecode;
    }
    let bytes: Array<number> = ByteStream.toArray(stream);
    let outStream: ByteStream = ByteStream.create();
    let i: number = 0;
    while (i < bytes.length) {
        ByteStream.writeU8(outStream, bytes[i]);
        i = i + 1;
    }
    let length: number = ByteStream.length(outStream);
    fs.writeFileSync(filePath, "bytecode_length:" + length);
    return length;
}

function loadBytecode(filePath: string): Array<number> | null {
    if (!fs.existsSync(filePath)) {
        console.log("Error: Bytecode file not found: " + filePath);
        return null;
    }
    let data: string = fs.readFileSync(filePath);
    let bytes: Array<number> = [];
    let len: number = data.length;
    let i: number = 0;
    while (i < len) {
        bytes[i] = data.charCodeAt(i) & 0xFF;
        i = i + 1;
    }
    return bytes;
}

function compileToFile(inputPath: string, outputPath: string): { bytecode: ByteStream, length: number } | null {
    let bytecode: { bytecode: ByteStream, length: number } | null = compileFile(inputPath);
    if (bytecode == null) {
        console.log("Error: Compilation failed for " + inputPath);
        return null;
    }
    let bytesWritten: number = saveBytecode(outputPath, bytecode);
    console.log("Compiled: " + inputPath + " -> " + outputPath + " (" + bytesWritten + " bytes)");
    return bytecode;
}

// ============================================================================
// Hash Functions for Determinism Verification
// ============================================================================

function computeByteHash(bytes: Array<number> | ByteStream | { bytecode: ByteStream }): number {
    let data: Array<number> = bytes;
    if (typeof bytes === "object" && (bytes as any).toArray != null) {
        data = ByteStream.toArray(bytes);
    } else if (typeof bytes === "object" && (bytes as any).bytecode != null) {
        data = ByteStream.toArray((bytes as any).bytecode);
    }
    let h: number = 0;
    let len: number = data.length;
    let i: number = 0;
    while (i < len) {
        h = ((h << 5) - h) + data[i];
        h = h & 0xFFFFFFFF;
        i = i + 1;
    }
    return h;
}

function computeStringHash(str: string): number {
    let h: number = 0;
    let len: number = str.length;
    let i: number = 0;
    while (i < len) {
        h = ((h << 5) - h) + str.charCodeAt(i);
        h = h & 0xFFFFFFFF;
        i = i + 1;
    }
    return h;
}

function computeFileHash(filePath: string): number | null {
    if (!fs.existsSync(filePath)) {
        return null;
    }
    let data: string = fs.readFileSync(filePath);
    let len: number = data.length;
    let bytes: Array<number> = [];
    let i: number = 0;
    while (i < len) {
        bytes[i] = data.charCodeAt(i) & 0xFF;
        i = i + 1;
    }
    return computeByteHash(bytes);
}

function computeBytecodeHash(code: ByteStream | { bytecode: ByteStream }): number {
    let stream: ByteStream = code;
    if (typeof code === "object" && (code as any).bytecode != null) {
        stream = (code as any).bytecode;
    }
    let bytes: Array<number> = ByteStream.toArray(stream);
    let h: number = 0;
    let len: number = bytes.length;
    let i: number = 0;
    while (i < len) {
        h = ((h << 5) - h) + bytes[i];
        h = h & 0xFFFFFFFF;
        i = i + 1;
    }
    return h;
}

// ============================================================================
// Performance Metrics
// ============================================================================

function measureCompilation(source: string): { lexerTime: number, parserTime: number, irTime: number, codegenTime: number, totalTime: number, bytecodeSize: number } {
    let metrics: { lexerTime: number, parserTime: number, irTime: number, codegenTime: number, totalTime: number, bytecodeSize: number };

    let t0: number = Date.now();
    let tokens: Array<Token> = tokenize(source);
    metrics.lexerTime = Date.now() - t0;

    let t1: number = Date.now();
    let ast: Program = parseSource(source);
    metrics.parserTime = Date.now() - t1;

    let t2: number = Date.now();
    let module: IrModule = lowerProgramToIr(ast);
    metrics.irTime = Date.now() - t2;

    let t3: number = Date.now();
    let result: { bytecode: ByteStream, length: number } = codegenIrModule(module);
    metrics.codegenTime = Date.now() - t3;

    metrics.totalTime = metrics.lexerTime + metrics.parserTime + metrics.irTime + metrics.codegenTime;
    metrics.bytecodeSize = result.length;

    return metrics;
}

// ============================================================================
// Export for external use
// ============================================================================

let BootstrapCompiler = {
    compile: compileToBytecode,
    compileModule: compileModule,
    compileAndVerify: compileAndVerify,
    compileFile: compileFile,
    saveBytecode: saveBytecode,
    loadBytecode: loadBytecode,
    compileToFile: compileToFile,
    computeByteHash: computeByteHash,
    computeStringHash: computeStringHash,
    computeFileHash: computeFileHash,
    version: "0.1.0",
    pipeline: "lexer -> parser -> ir -> codegen"
};

console.log("Bootstrap Compiler Pipeline loaded");
console.log("Version: " + BootstrapCompiler.version);
console.log("Pipeline: " + BootstrapCompiler.pipeline);
