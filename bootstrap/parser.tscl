// ============================================================================
// Bootstrap Parser for tscl
// Recursive descent parser - consumes tokens, produces AST
// Requires: std/prelude.tscl, bootstrap/types.tscl, and bootstrap/lexer.tscl
// ============================================================================

// ============================================================================
// Parser State
// ============================================================================

function createParser(tokens) {
    return {
        tokens: tokens,
        pos: 0
    };
}

// ============================================================================
// Utility Functions
// ============================================================================

function parserPeek(parser) {
    if (parser.pos >= parser.tokens.length) {
        return null;
    }
    return parser.tokens[parser.pos];
}

function peekType(parser) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return TOKEN.EOF;
    }
    return tok.type;
}

function peekValue(parser) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return "";
    }
    return tok.value;
}

function parserAdvance(parser) {
    let tok =  parserPeek(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

function check(parser, type, value) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return false;
    }
    if (tok.type != type) {
        return false;
    }
    if (value != null && tok.value != value) {
        return false;
    }
    return true;
}

function match(parser, type, value) {
    if (check(parser, type, value)) {
        parserAdvance(parser);
        return true;
    }
    return false;
}

function expect(parser, type, value) {
    if (check(parser, type, value)) {
        return parserAdvance(parser);
    }
    let tok =  parserPeek(parser);
    let tokVal =  "";
    let tokType =  TOKEN.EOF;
    if (tok != null) {
        tokVal = tok.value;
        tokType = tok.type;
    }
    console.log("Parse error: expected", type, value, "but got", tokType, tokVal);
    return null;
}

function isAtEnd(parser) {
    return peekType(parser) == TOKEN.EOF;
}

// ============================================================================
// Statement Parsers
// ============================================================================

function parseProgram(parser) {
    let programBody =  [];

    while (!isAtEnd(parser)) {
        let stmt =  parseStatement(parser);
        if (stmt != null) {
            programBody.push(stmt);
        } else {
            parserAdvance(parser);
        }
    }

    return {
        type: "Program",
        body: programBody
    };
}

function parseStatement(parser) {
    let type =  peekType(parser);

    if (type == TOKEN.KEYWORD) {
        let value =  peekValue(parser);
        if (value == "let" || value == "const" || value == "var") {
            return parseVariableDeclaration(parser);
        }
        if (value == "function") {
            return parseFunctionDeclaration(parser);
        }
        if (value == "return") {
            return parseReturnStatement(parser);
        }
        if (value == "if") {
            return parseIfStatement(parser);
        }
        if (value == "while") {
            return parseWhileStatement(parser);
        }
        if (value == "for") {
            return parseForStatement(parser);
        }
        if (value == "break") {
            return parseBreakStatement(parser);
        }
        if (value == "continue") {
            return parseContinueStatement(parser);
        }
    }

    if (type == TOKEN.DELIMITER) {
        let value =  peekValue(parser);
        if (value == "{") {
            return parseBlockStatement(parser);
        }
    }

    // Try to parse as expression statement
    let expr =  parseExpression(parser, 0);
    if (expr != null) {
        // Check for semicolon
        match(parser, TOKEN.DELIMITER, ";");
        return {
            type: "ExpressionStatement",
            expression: expr
        };
    }

    return null;
}

function parseBlockStatement(parser) {
    expect(parser, TOKEN.DELIMITER, "{");

    let body =  [];

    while (!check(parser, TOKEN.DELIMITER, "}")) {
        if (isAtEnd(parser)) {
            console.log("Parse error: unclosed block");
            break;
        }
        let stmt =  parseStatement(parser);
        if (stmt != null) {
            body.push(stmt);
        } else {
            parserAdvance(parser);
        }
    }

    expect(parser, TOKEN.DELIMITER, "}");

    return {
        type: "BlockStatement",
        body: body
    };
}

function parseVariableDeclaration(parser) {
    let kind =  peekValue(parser);
    parserAdvance(parser);

    let name =  "";
    let nameTok =  expect(parser, TOKEN.IDENTIFIER, null);
    if (nameTok != null) {
        name = nameTok.value;
    }

    let init =  null;
    if (match(parser, TOKEN.OPERATOR, "=")) {
        init = parseExpression(parser, 0);
    }

    match(parser, TOKEN.DELIMITER, ";");

    return {
        type: "VariableDeclaration",
        name: name,
        init: init,
        kind: kind
    };
}

function parseFunctionDeclaration(parser) {
    expect(parser, TOKEN.KEYWORD, "function");

    let name =  "";
    let nameTok =  expect(parser, TOKEN.IDENTIFIER, null);
    if (nameTok != null) {
        name = nameTok.value;
    }

    expect(parser, TOKEN.DELIMITER, "(");

    let params =  [];
    while (!check(parser, TOKEN.DELIMITER, ")")) {
        if (params.length > 0) {
            expect(parser, TOKEN.DELIMITER, ",");
        }
        let paramTok =  expect(parser, TOKEN.IDENTIFIER, null);
        if (paramTok != null) {
            params.push(paramTok.value);
        }
    }

    expect(parser, TOKEN.DELIMITER, ")");

    let body =  parseBlockStatement(parser);

    return {
        type: "FunctionDeclaration",
        name: name,
        params: params,
        body: body
    };
}

function parseReturnStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "return");

    let argument =  null;
    if (!check(parser, TOKEN.DELIMITER, ";") && !isAtEnd(parser)) {
        argument = parseExpression(parser, 0);
    }

    match(parser, TOKEN.DELIMITER, ";");

    return {
        type: "ReturnStatement",
        argument: argument
    };
}

function parseIfStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "if");
    expect(parser, TOKEN.DELIMITER, "(");

    let test =  parseExpression(parser, 0);

    expect(parser, TOKEN.DELIMITER, ")");

    let consequent: Statement;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        consequent = parseBlockStatement(parser);
    } else {
        let stmt =  parseStatement(parser);
        if (stmt == null) {
            consequent = { type: "EmptyStatement" };
        } else {
            consequent = stmt;
        }
    }

    let alternate =  null;
    if (match(parser, TOKEN.KEYWORD, "else")) {
        if (check(parser, TOKEN.KEYWORD, "if")) {
            alternate = parseIfStatement(parser);
        } else if (check(parser, TOKEN.DELIMITER, "{")) {
            alternate = parseBlockStatement(parser);
        } else {
            let stmt =  parseStatement(parser);
            alternate = stmt;
        }
    }

    return {
        type: "IfStatement",
        test: test,
        consequent: consequent,
        alternate: alternate
    };
}

function parseWhileStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "while");
    expect(parser, TOKEN.DELIMITER, "(");

    let test =  parseExpression(parser, 0);

    expect(parser, TOKEN.DELIMITER, ")");

    let body: Statement;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        body = parseBlockStatement(parser);
    } else {
        let stmt =  parseStatement(parser);
        if (stmt == null) {
            body = { type: "EmptyStatement" };
        } else {
            body = stmt;
        }
    }

    return {
        type: "WhileStatement",
        test: test,
        body: body
    };
}

function parseForStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "for");
    expect(parser, TOKEN.DELIMITER, "(");

    let init =  null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        if (peekType(parser) == TOKEN.KEYWORD) {
            let value =  peekValue(parser);
            if (value == "let" || value == "const" || value == "var") {
                init = parseVariableDeclaration(parser);
            }
        } else {
            init = {
                type: "ExpressionStatement",
                expression: parseExpression(parser, 0)
            };
        }
    }

    let test =  null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        test = parseExpression(parser, 0);
    }

    expect(parser, TOKEN.DELIMITER, ";");

    let update =  null;
    if (!check(parser, TOKEN.DELIMITER, ")")) {
        update = parseExpression(parser, 0);
    }

    expect(parser, TOKEN.DELIMITER, ")");

    let body: Statement;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        body = parseBlockStatement(parser);
    } else {
        let stmt =  parseStatement(parser);
        body = stmt;
    }

    return {
        type: "ForStatement",
        init: init,
        test: test,
        update: update,
        body: body
    };
}

function parseBreakStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "break");
    match(parser, TOKEN.DELIMITER, ";");
    return { type: "BreakStatement" };
}

function parseContinueStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "continue");
    match(parser, TOKEN.DELIMITER, ";");
    return { type: "ContinueStatement" };
}

// ============================================================================
// Expression Parsers (Pratt Parser)
// ============================================================================

const PRECEDENCE =  {
    "=": 1,
    "||": 2,
    "&&": 3,
    "|": 4,
    "^": 5,
    "&": 6,
    "==": 7, "!=": 7, "===": 7, "!==": 7,
    "<": 8, "<=": 8, ">": 8, ">=": 8,
    "<<": 9, ">>": 9, ">>>": 9,
    "+": 10, "-": 10,
    "*": 11, "/": 11, "%": 11, "**": 12,
    ".": 14,
    "[": 14,
    "(": 15
};

function parseExpression(parser, minPrec) {
    let tok =  parserPeek(parser);
    if (tok == null) {
        return null;
    }

    let left: Expression | null;

    // Prefix operators
    if (tok.type == TOKEN.OPERATOR) {
        let op =  tok.value;
        if (op == "!" || op == "-" || op == "+" || op == "~" || op == "typeof" || op == "void" || op == "delete") {
            parserAdvance(parser);
            let argument =  parseExpression(parser, 13);
            if (argument == null) {
                return null;
            }
            left = {
                type: "UnaryExpression",
                operator: op,
                argument: argument
            };
        } else {
            return null;
        }
    } else if (tok.type == TOKEN.NUMBER) {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "number",
            value: parseFloat(tok.value)
        };
    } else if (tok.type == TOKEN.STRING) {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "string",
            value: tok.value
        };
    } else if (tok.type == TOKEN.KEYWORD && tok.value == "null") {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "null",
            value: null
        };
    } else if (tok.type == TOKEN.KEYWORD && (tok.value == "true" || tok.value == "false")) {
        parserAdvance(parser);
        left = {
            type: "Literal",
            literalType: "boolean",
            value: tok.value == "true"
        };
    } else if (tok.type == TOKEN.IDENTIFIER) {
        parserAdvance(parser);
        left = {
            type: "Identifier",
            name: tok.value
        };
    } else if (tok.type == TOKEN.KEYWORD && tok.value == "this") {
        parserAdvance(parser);
        left = { type: "ThisExpression" };
    } else if (match(parser, TOKEN.DELIMITER, "(")) {
        // Parenthesized expression or arrow function
        if (peekType(parser) == TOKEN.IDENTIFIER) {
            // Check for arrow function
            let nextToken =  parser.tokens[parser.pos + 1];
            if (nextToken != null && nextToken.value == "=>") {
                // Arrow function: (param) => body
                let params =  [];
                params.push(tok.value);

                parserAdvance(parser); // Consume identifier
                parserAdvance(parser); // Consume "=>"

                let body: BlockStatement | Expression;
                if (check(parser, TOKEN.DELIMITER, "{")) {
                    body = parseBlockStatement(parser);
                } else {
                    let expr =  parseExpression(parser, 0);
                    if (expr == null) {
                        body = { type: "BlockStatement", body: [] };
                    } else {
                        body = expr;
                    }
                }

                left = {
                    type: "ArrowFunctionExpression",
                    params: params,
                    body: body
                };
            } else {
                // Parenthesized expression
                let expr =  parseExpression(parser, 0);
                expect(parser, TOKEN.DELIMITER, ")");
                left = expr;
            }
        } else {
            let expr =  parseExpression(parser, 0);
            expect(parser, TOKEN.DELIMITER, ")");
            left = expr;
        }
    } else if (match(parser, TOKEN.DELIMITER, "{")) {
        // Object literal
        let properties =  [];

        while (!check(parser, TOKEN.DELIMITER, "}")) {
            if (properties.length > 0) {
                expect(parser, TOKEN.DELIMITER, ",");
            }

            let keyTok =  expect(parser, TOKEN.IDENTIFIER, null);
            if (keyTok == null) {
                break;
            }

            let key: Identifier | Literal = {
                type: "Identifier",
                name: keyTok.value
            };

            expect(parser, TOKEN.DELIMITER, ":");

            let value =  parseExpression(parser, 0);

            properties.push({
                key: key,
                value: value,
                kind: "init"
            });
        }

        expect(parser, TOKEN.DELIMITER, "}");

        left = {
            type: "ObjectExpression",
            properties: properties
        };
    } else if (match(parser, TOKEN.DELIMITER, "[")) {
        // Array literal
        let elements: Array<Expression | null> = [];

        while (!check(parser, TOKEN.DELIMITER, "]")) {
            if (elements.length > 0) {
                expect(parser, TOKEN.DELIMITER, ",");
            }

            if (check(parser, TOKEN.DELIMITER, "]")) {
                break;
            }

            let element =  parseExpression(parser, 0);
            elements.push(element);
        }

        expect(parser, TOKEN.DELIMITER, "]");

        left = {
            type: "ArrayExpression",
            elements: elements
        };
    } else {
        return null;
    }

    // Parse postfix operators and binary operators
    while (true) {
        let nextPrec =  0;
        let op =  "";

        if (match(parser, TOKEN.DELIMITER, "(")) {
            // Function call
            let callee =  left;

            let arguments =  [];
            while (!check(parser, TOKEN.DELIMITER, ")")) {
                if (arguments.length > 0) {
                    expect(parser, TOKEN.DELIMITER, ",");
                }

                let arg =  parseExpression(parser, 0);
                if (arg != null) {
                    arguments.push(arg);
                }
            }

            expect(parser, TOKEN.DELIMITER, ")");

            left = {
                type: "CallExpression",
                callee: callee,
                arguments: arguments
            };
        } else if (match(parser, TOKEN.DELIMITER, ".")) {
            // Property access
            let propertyTok =  expect(parser, TOKEN.IDENTIFIER, null);
            if (propertyTok == null) {
                break;
            }

            left = {
                type: "MemberExpression",
                object: left,
                property: {
                    type: "Identifier",
                    name: propertyTok.value
                },
                computed: false
            };
        } else if (match(parser, TOKEN.DELIMITER, "[")) {
            // Computed property access
            let property =  parseExpression(parser, 0);
            expect(parser, TOKEN.DELIMITER, "]");

            left = {
                type: "MemberExpression",
                object: left,
                property: property,
                computed: true
            };
        } else if (peekType(parser) == TOKEN.OPERATOR) {
            let opTok =  parserPeek(parser);
            op = opTok.value;

            if (op == "=>") {
                // Arrow function
                parserAdvance(parser);

                let params =  [];
                if (left.type == "Identifier") {
                    params.push(left.name);
                } else if (left.type == "CallExpression") {
                    console.log("ERROR: Function call not allowed before arrow");
                    break;
                }

                let body: BlockStatement | Expression;
                if (check(parser, TOKEN.DELIMITER, "{")) {
                    body = parseBlockStatement(parser);
                } else {
                    let expr =  parseExpression(parser, 0);
                    if (expr == null) {
                        body = { type: "BlockStatement", body: [] };
                    } else {
                        body = expr;
                    }
                }

                left = {
                    type: "ArrowFunctionExpression",
                    params: params,
                    body: body
                };
            } else if (PRECEDENCE[op] != null) {
                nextPrec = PRECEDENCE[op];

                if (nextPrec <= minPrec) {
                    break;
                }

                parserAdvance(parser);

                let right =  parseExpression(parser, nextPrec);

                if (right == null) {
                    break;
                }

                if (op == "=") {
                    // Assignment
                    if (left.type == "Identifier" || left.type == "MemberExpression") {
                        left = {
                            type: "AssignmentExpression",
                            operator: op,
                            left: left,
                            right: right
                        };
                    } else {
                        console.log("ERROR: Invalid assignment target");
                    }
                } else {
                    // Binary operation
                    left = {
                        type: "BinaryExpression",
                        operator: op,
                        left: left,
                        right: right
                    };
                }
            } else {
                break;
            }
        } else {
            break;
        }
    }

    return left;
}

// ============================================================================
// Source Code Entry Point
// ============================================================================

function parseSource(source) {
    let tokens =  tokenize(source);
    let parser =  createParser(tokens);
    return parseProgram(parser);
}
