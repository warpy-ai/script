// ============================================================================
// Bootstrap Parser for tscl
// Recursive descent parser - consumes tokens, produces AST
// Requires: std/prelude.tscl, bootstrap/types.tscl, and bootstrap/lexer.tscl
// ============================================================================

// ============================================================================
// Parser State
// ============================================================================

function createParser(tokens: Array<Token>): Parser {
    return {
        tokens: tokens,
        pos: 0
    };
}

// ============================================================================
// Utility Functions
// ============================================================================

function parserPeek(parser: Parser): Token | null {
    if (parser.pos >= parser.tokens.length) {
        return null;
    }
    return parser.tokens[parser.pos];
}

function peekType(parser: Parser): TOKEN | string {
    let tok: Token | null = parserPeek(parser);
    if (tok == null) {
        return TOKEN.EOF;
    }
    return tok.type;
}

function peekValue(parser: Parser): string {
    let tok: Token | null = parserPeek(parser);
    if (tok == null) {
        return "";
    }
    return tok.value;
}

function parserAdvance(parser: Parser): Token | null {
    let tok: Token | null = parserPeek(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

function check(parser: Parser, typeVal: TOKEN | string, value: string | null): boolean {
    let tok: Token | null = parserPeek(parser);
    if (tok == null) {
        return false;
    }
    if (tok.type != typeVal) {
        return false;
    }
    if (value != null && tok.value != value) {
        return false;
    }
    return true;
}

function match(parser: Parser, typeVal: TOKEN | string, value: string | null): boolean {
    if (check(parser, typeVal, value)) {
        parserAdvance(parser);
        return true;
    }
    return false;
}

function expect(parser: Parser, typeVal: TOKEN | string, value: string | null): Token | null {
    if (check(parser, typeVal, value)) {
        return parserAdvance(parser);
    }
    let tok: Token | null = parserPeek(parser);
    let tokVal: string = "";
    let tokType: TOKEN | string = TOKEN.EOF;
    if (tok != null) {
        tokVal = tok.value;
        tokType = tok.type;
    }
    console.log("Parse error: expected", typeVal, value, "but got", tokType, tokVal);
    return null;
}

function isAtEnd(parser: Parser): boolean {
    return peekType(parser) == TOKEN.EOF;
}

// ============================================================================
// Type Annotation Parsers
// ============================================================================

// Parse a type annotation after ':'
// Examples: number, string, boolean, any, void, Array<T>, T[], Promise<T>, A | B
function parseTypeAnnotation(parser: Parser): TypeAnnotation | null {
    let baseType: TypeAnnotation | null = parseBaseType(parser);
    if (baseType == null) {
        return null;
    }
    return baseType;
}

function parseBaseType(parser: Parser): TypeAnnotation | null {
    let typeVal: TOKEN | string = peekType(parser);
    let value: string = peekValue(parser);

    if (typeVal == TOKEN.KEYWORD) {
        if (value == "number" || value == "string" || value == "boolean" ||
            value == "any" || value == "void" || value == "never" ||
            value == "null" || value == "undefined") {
            parserAdvance(parser);
            return {
                type: "TypeAnnotation",
                typeKind: value,
                isArray: false,
                elementType: null,
                unionTypes: null,
                genericParams: null
            };
        }
    }

    if (typeVal == TOKEN.IDENTIFIER) {
        parserAdvance(parser);
        let typeName: string = value;
        let genericParams: Array<TypeAnnotation> | null = null;

        if (match(parser, TOKEN.OPERATOR, "<")) {
            genericParams = [];
            while (!check(parser, TOKEN.DELIMITER, ">") && !isAtEnd(parser)) {
                let param: TypeAnnotation | null = parseTypeAnnotation(parser);
                if (param != null) {
                    genericParams.push(param);
                }
                if (!match(parser, TOKEN.DELIMITER, ",")) {
                    break;
                }
            }
            expect(parser, TOKEN.DELIMITER, ">");
        }

        return {
            type: "TypeAnnotation",
            typeKind: typeName,
            isArray: false,
            elementType: null,
            unionTypes: null,
            genericParams: genericParams
        };
    }

    return null;
}

function parseTypedParam(parser: Parser): TypedParam | null {
    if (check(parser, TOKEN.IDENTIFIER, null)) {
        let name: string = peekValue(parser);
        parserAdvance(parser);

        let typeAnnotation: TypeAnnotation | null = null;
        if (match(parser, TOKEN.OPERATOR, ":")) {
            typeAnnotation = parseTypeAnnotation(parser);
        }

        return {
            name: name,
            typeAnnotation: typeAnnotation
        };
    }
    return null;
}

// ============================================================================
// Main Parse Function
// ============================================================================

function parseSource(source: string): Program {
    let tokens: Array<Token> = tokenize(source);
    let parser: Parser = createParser(tokens);
    return parseProgram(parser);
}

function parseProgram(parser: Parser): Program {
    let body: Array<Statement> = [];

    while (!isAtEnd(parser)) {
        let stmt: Statement | null = parseStatement(parser);
        if (stmt != null) {
            body.push(stmt);
        }
    }

    return {
        type: "Program",
        body: body
    };
}

// ============================================================================
// Statement Parsers
// ============================================================================

function parseStatement(parser: Parser): Statement | null {
    let typeVal: TOKEN | string = peekType(parser);

    if (typeVal == TOKEN.KEYWORD) {
        let value: string = peekValue(parser);

        if (value == "let" || value == "const" || value == "var") {
            return parseVariableDeclaration(parser);
        }
        if (value == "function") {
            return parseFunctionDeclaration(parser);
        }
        if (value == "return") {
            return parseReturnStatement(parser);
        }
        if (value == "if") {
            return parseIfStatement(parser);
        }
        if (value == "while") {
            return parseWhileStatement(parser);
        }
        if (value == "for") {
            return parseForStatement(parser);
        }
        if (value == "break") {
            return parseBreakStatement(parser);
        }
        if (value == "continue") {
            return parseContinueStatement(parser);
        }
        if (value == "import") {
            return parseImportDeclaration(parser);
        }
        if (value == "export") {
            return parseExportDeclaration(parser);
        }
    }

    return parseExpressionStatement(parser);
}

function parseVariableDeclaration(parser: Parser): VariableDeclaration | null {
    let kind: string = peekValue(parser);
    parserAdvance(parser);

    if (!check(parser, TOKEN.IDENTIFIER, null)) {
        console.log("Expected variable name");
        return null;
    }

    let name: string = peekValue(parser);
    parserAdvance(parser);

    let typeAnnotation: TypeAnnotation | null = null;
    if (match(parser, TOKEN.OPERATOR, ":")) {
        typeAnnotation = parseTypeAnnotation(parser);
    }

    let init: Expression | null = null;
    if (match(parser, TOKEN.OPERATOR, "=")) {
        init = parseExpression(parser);
    }

    expect(parser, TOKEN.DELIMITER, ";");

    return {
        type: "VariableDeclaration",
        name: name,
        typeAnnotation: typeAnnotation,
        init: init,
        kind: kind
    };
}

function parseFunctionDeclaration(parser: Parser): FunctionDeclaration | null {
    parserAdvance(parser);

    if (!check(parser, TOKEN.IDENTIFIER, null) && !check(parser, TOKEN.DELIMITER, "(")) {
        console.log("Expected function name or (");
        return null;
    }

    let name: string = "";
    if (check(parser, TOKEN.IDENTIFIER, null)) {
        name = peekValue(parser);
        parserAdvance(parser);
    }

    expect(parser, TOKEN.DELIMITER, "(");

    let params: Array<string | TypedParam> = [];
    if (!check(parser, TOKEN.DELIMITER, ")")) {
        while (true) {
            let param: string | TypedParam | null = null;

            if (check(parser, TOKEN.IDENTIFIER, null)) {
                param = peekValue(parser);
                parserAdvance(parser);

                if (match(parser, TOKEN.OPERATOR, ":")) {
                    let typeAnn: TypeAnnotation | null = parseTypeAnnotation(parser);
                    param = {
                        name: param,
                        typeAnnotation: typeAnn
                    };
                }
            } else {
                let typedParam: TypedParam | null = parseTypedParam(parser);
                if (typedParam != null) {
                    param = typedParam;
                }
            }

            if (param != null) {
                params.push(param);
            }

            if (!match(parser, TOKEN.DELIMITER, ",")) {
                break;
            }
        }
    }

    expect(parser, TOKEN.DELIMITER, ")");

    let returnType: TypeAnnotation | null = null;
    if (match(parser, TOKEN.OPERATOR, ":")) {
        returnType = parseTypeAnnotation(parser);
    }

    let body: BlockStatement | null = parseBlockStatement(parser);

    return {
        type: "FunctionDeclaration",
        name: name,
        params: params,
        returnType: returnType,
        body: body,
        isAsync: false
    };
}

function parseReturnStatement(parser: Parser): ReturnStatement | null {
    parserAdvance(parser);

    let argument: Expression | null = null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        argument = parseExpression(parser);
    }

    expect(parser, TOKEN.DELIMITER, ";");

    return {
        type: "ReturnStatement",
        argument: argument
    };
}

function parseIfStatement(parser: Parser): IfStatement | null {
    parserAdvance(parser);
    expect(parser, TOKEN.DELIMITER, "(");

    let test: Expression | null = parseExpression(parser);

    expect(parser, TOKEN.DELIMITER, ")");

    let consequent: Statement | null = parseStatement(parser);

    let alternate: Statement | null = null;
    if (check(parser, TOKEN.KEYWORD, "else")) {
        parserAdvance(parser);
        alternate = parseStatement(parser);
    }

    return {
        type: "IfStatement",
        test: test,
        consequent: consequent,
        alternate: alternate
    };
}

function parseWhileStatement(parser: Parser): WhileStatement | null {
    parserAdvance(parser);
    expect(parser, TOKEN.DELIMITER, "(");

    let test: Expression | null = parseExpression(parser);

    expect(parser, TOKEN.DELIMITER, ")");

    let body: Statement | null = parseStatement(parser);

    return {
        type: "WhileStatement",
        test: test,
        body: body
    };
}

function parseForStatement(parser: Parser): ForStatement | null {
    parserAdvance(parser);
    expect(parser, TOKEN.DELIMITER, "(");

    let init: Statement | null = null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        init = parseStatement(parser);
    }

    let test: Expression | null = null;
    if (!check(parser, TOKEN.DELIMITER, ";")) {
        test = parseExpression(parser);
    }

    expect(parser, TOKEN.DELIMITER, ";");

    let update: Expression | null = null;
    if (!check(parser, TOKEN.DELIMITER, ")")) {
        update = parseExpression(parser);
    }

    expect(parser, TOKEN.DELIMITER, ")");

    let body: Statement | null = parseStatement(parser);

    return {
        type: "ForStatement",
        init: init,
        test: test,
        update: update,
        body: body
    };
}

function parseBreakStatement(parser: Parser): BreakStatement | null {
    parserAdvance(parser);
    expect(parser, TOKEN.DELIMITER, ";");
    return { type: "BreakStatement" };
}

function parseContinueStatement(parser: Parser): ContinueStatement | null {
    parserAdvance(parser);
    expect(parser, TOKEN.DELIMITER, ";");
    return { type: "ContinueStatement" };
}

function parseBlockStatement(parser: Parser): BlockStatement | null {
    if (!check(parser, TOKEN.DELIMITER, "{")) {
        console.log("Expected {");
        return null;
    }
    parserAdvance(parser);

    let body: Array<Statement> = [];
    while (!check(parser, TOKEN.DELIMITER, "}") && !isAtEnd(parser)) {
        let stmt: Statement | null = parseStatement(parser);
        if (stmt != null) {
            body.push(stmt);
        }
    }

    expect(parser, TOKEN.DELIMITER, "}");

    return {
        type: "BlockStatement",
        body: body
    };
}

function parseExpressionStatement(parser: Parser): ExpressionStatement | null {
    let expr: Expression | null = parseExpression(parser);
    expect(parser, TOKEN.DELIMITER, ";");
    return {
        type: "ExpressionStatement",
        expression: expr
    };
}

function parseImportDeclaration(parser: Parser): ImportDeclaration | null {
    parserAdvance(parser);

    let specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier> = [];
    let source: string = "";

    if (check(parser, TOKEN.DELIMITER, "{")) {
        parserAdvance(parser);
        while (!check(parser, TOKEN.DELIMITER, "}")) {
            if (check(parser, TOKEN.IDENTIFIER, null)) {
                let imported: string = peekValue(parser);
                parserAdvance(parser);

                let local: string = imported;
                if (check(parser, TOKEN.KEYWORD, "as")) {
                    parserAdvance(parser);
                    local = peekValue(parser);
                    parserAdvance(parser);
                }

                specifiers.push({
                    type: "ImportSpecifier",
                    imported: imported,
                    local: local
                });

                match(parser, TOKEN.DELIMITER, ",");
            }
            if (check(parser, TOKEN.OPERATOR, "*")) {
                parserAdvance(parser);
                expect(parser, TOKEN.KEYWORD, "as");
                let local: string = peekValue(parser);
                parserAdvance(parser);

                specifiers.push({
                    type: "ImportNamespaceSpecifier",
                    local: local
                });
            }
            if (check(parser, TOKEN.IDENTIFIER, null)) {
                let local: string = peekValue(parser);
                parserAdvance(parser);

                specifiers.push({
                    type: "ImportDefaultSpecifier",
                    local: local
                });
            }
        }
        expect(parser, TOKEN.DELIMITER, "}");
    }

    expect(parser, TOKEN.KEYWORD, "from");

    let tok: Token | null = parserPeek(parser);
    if (tok != null && tok.type == TOKEN.STRING) {
        source = tok.value;
        parserAdvance(parser);
    }

    expect(parser, TOKEN.DELIMITER, ";");

    return {
        type: "ImportDeclaration",
        specifiers: specifiers,
        source: source
    };
}

function parseExportDeclaration(parser: Parser): Statement | null {
    parserAdvance(parser);

    if (check(parser, TOKEN.KEYWORD, "default")) {
        parserAdvance(parser);

        if (check(parser, TOKEN.KEYWORD, "function")) {
            let decl: FunctionDeclaration | null = parseFunctionDeclaration(parser);
            if (decl != null) {
                return {
                    type: "ExportDefaultDeclaration",
                    declaration: decl
                };
            }
        }

        let expr: Expression | null = parseExpression(parser);
        expect(parser, TOKEN.DELIMITER, ";");

        return {
            type: "ExportDefaultDeclaration",
            declaration: expr
        };
    }

    if (check(parser, TOKEN.OPERATOR, "{")) {
        parserAdvance(parser);

        let specifiers: Array<ExportSpecifier> = [];
        while (!check(parser, TOKEN.DELIMITER, "}")) {
            if (check(parser, TOKEN.IDENTIFIER, null)) {
                let local: string = peekValue(parser);
                parserAdvance(parser);

                let exported: string = local;
                if (check(parser, TOKEN.KEYWORD, "as")) {
                    parserAdvance(parser);
                    exported = peekValue(parser);
                    parserAdvance(parser);
                }

                specifiers.push({
                    type: "ExportSpecifier",
                    local: local,
                    exported: exported
                });

                match(parser, TOKEN.DELIMITER, ",");
            }
        }
        expect(parser, TOKEN.DELIMITER, "}");

        let source: string | null = null;
        if (check(parser, TOKEN.KEYWORD, "from")) {
            parserAdvance(parser);
            let tok: Token | null = parserPeek(parser);
            if (tok != null && tok.type == TOKEN.STRING) {
                source = tok.value;
                parserAdvance(parser);
            }
        }
        expect(parser, TOKEN.DELIMITER, ";");

        return {
            type: "ExportNamedDeclaration",
            specifiers: specifiers,
            source: source,
            declaration: null
        };
    }

    if (check(parser, TOKEN.OPERATOR, "*")) {
        parserAdvance(parser);
        expect(parser, TOKEN.KEYWORD, "from");

        let tok: Token | null = parserPeek(parser);
        let source: string = "";
        if (tok != null && tok.type == TOKEN.STRING) {
            source = tok.value;
            parserAdvance(parser);
        }
        expect(parser, TOKEN.DELIMITER, ";");

        return {
            type: "ExportAllDeclaration",
            source: source
        };
    }

    let decl: Statement | null = parseStatement(parser);
    if (decl != null) {
        return {
            type: "ExportNamedDeclaration",
            specifiers: [],
            source: null,
            declaration: decl
        };
    }

    return null;
}

// ============================================================================
// Expression Parsers
// ============================================================================

function parseExpression(parser: Parser): Expression | null {
    return parseAssignment(parser);
}

function parseAssignment(parser: Parser): Expression | null {
    let left: Expression | null = parseConditional(parser);

    if (left == null) {
        return null;
    }

    if (check(parser, TOKEN.OPERATOR, "=") ||
        check(parser, TOKEN.OPERATOR, "+=") ||
        check(parser, TOKEN.OPERATOR, "-=") ||
        check(parser, TOKEN.OPERATOR, "*=") ||
        check(parser, TOKEN.OPERATOR, "/=")) {

        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseAssignment(parser);
        if (right == null) {
            return null;
        }

        return {
            type: "AssignmentExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseConditional(parser: Parser): Expression | null {
    let test: Expression | null = parseLogicalOr(parser);

    if (test == null) {
        return null;
    }

    if (check(parser, TOKEN.OPERATOR, "?")) {
        parserAdvance(parser);

        let consequent: Expression | null = parseExpression(parser);
        expect(parser, TOKEN.DELIMITER, ":");

        let alternate: Expression | null = parseConditional(parser);

        return {
            type: "ConditionalExpression",
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }

    return test;
}

function parseLogicalOr(parser: Parser): Expression | null {
    let left: Expression | null = parseLogicalAnd(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "||")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseLogicalAnd(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseLogicalAnd(parser: Parser): Expression | null {
    let left: Expression | null = parseBitwiseOr(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "&&")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseBitwiseOr(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseBitwiseOr(parser: Parser): Expression | null {
    let left: Expression | null = parseBitwiseXor(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "|")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseBitwiseXor(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseBitwiseXor(parser: Parser): Expression | null {
    let left: Expression | null = parseBitwiseAnd(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "^")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseBitwiseAnd(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseBitwiseAnd(parser: Parser): Expression | null {
    let left: Expression | null = parseEquality(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "&")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseEquality(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseEquality(parser: Parser): Expression | null {
    let left: Expression | null = parseComparison(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "===") ||
           check(parser, TOKEN.OPERATOR, "!==") ||
           check(parser, TOKEN.OPERATOR, "==") ||
           check(parser, TOKEN.OPERATOR, "!=")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseComparison(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseComparison(parser: Parser): Expression | null {
    let left: Expression | null = parseShift(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "<") ||
           check(parser, TOKEN.OPERATOR, "<=") ||
           check(parser, TOKEN.OPERATOR, ">") ||
           check(parser, TOKEN.OPERATOR, ">=") ||
           check(parser, TOKEN.KEYWORD, "instanceof")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseShift(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseShift(parser: Parser): Expression | null {
    let left: Expression | null = parseAdditive(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "<<") ||
           check(parser, TOKEN.OPERATOR, ">>") ||
           check(parser, TOKEN.OPERATOR, ">>>")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseAdditive(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseAdditive(parser: Parser): Expression | null {
    let left: Expression | null = parseMultiplicative(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "+") || check(parser, TOKEN.OPERATOR, "-")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseMultiplicative(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseMultiplicative(parser: Parser): Expression | null {
    let left: Expression | null = parseUnary(parser);
    if (left == null) {
        return null;
    }

    while (check(parser, TOKEN.OPERATOR, "*") ||
           check(parser, TOKEN.OPERATOR, "/") ||
           check(parser, TOKEN.OPERATOR, "%") ||
           check(parser, TOKEN.OPERATOR, "**")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let right: Expression | null = parseUnary(parser);
        if (right == null) {
            break;
        }

        left = {
            type: "BinaryExpression",
            operator: operator,
            left: left,
            right: right
        };
    }

    return left;
}

function parseUnary(parser: Parser): Expression | null {
    if (check(parser, TOKEN.OPERATOR, "-") ||
        check(parser, TOKEN.OPERATOR, "+") ||
        check(parser, TOKEN.OPERATOR, "!") ||
        check(parser, TOKEN.OPERATOR, "~") ||
        check(parser, TOKEN.OPERATOR, "++") ||
        check(parser, TOKEN.OPERATOR, "--")) {

        let operator: string = peekValue(parser);
        parserAdvance(parser);

        let argument: Expression | null = parseUnary(parser);
        if (argument == null) {
            return null;
        }

        return {
            type: "UnaryExpression",
            operator: operator,
            argument: argument
        };
    }

    return parsePostfix(parser);
}

function parsePostfix(parser: Parser): Expression | null {
    let expr: Expression | null = parseCallMember(parser);
    if (expr == null) {
        return null;
    }

    if (check(parser, TOKEN.OPERATOR, "++") || check(parser, TOKEN.OPERATOR, "--")) {
        let operator: string = peekValue(parser);
        parserAdvance(parser);

        return {
            type: "UnaryExpression",
            operator: operator,
            argument: expr
        };
    }

    return expr;
}

function parseCallMember(parser: Parser): Expression | null {
    let expr: Expression | null = parsePrimary(parser);
    if (expr == null) {
        return null;
    }

    while (true) {
        if (check(parser, TOKEN.DELIMITER, ".")) {
            parserAdvance(parser);

            if (check(parser, TOKEN.IDENTIFIER, null)) {
                let property: Identifier = {
                    type: "Identifier",
                    name: peekValue(parser)
                };
                parserAdvance(parser);

                expr = {
                    type: "MemberExpression",
                    object: expr,
                    property: property,
                    computed: false
                };
            } else {
                break;
            }
        } else if (check(parser, TOKEN.DELIMITER, "[")) {
            parserAdvance(parser);

            let property: Expression | null = parseExpression(parser);

            expect(parser, TOKEN.DELIMITER, "]");

            expr = {
                type: "MemberExpression",
                object: expr,
                property: property,
                computed: true
            };
        } else if (check(parser, TOKEN.DELIMITER, "(")) {
            parserAdvance(parser);

            let args: Array<Expression> = [];
            if (!check(parser, TOKEN.DELIMITER, ")")) {
                while (true) {
                    let arg: Expression | null = parseAssignment(parser);
                    if (arg != null) {
                        args.push(arg);
                    }
                    if (!match(parser, TOKEN.DELIMITER, ",")) {
                        break;
                    }
                }
            }

            expect(parser, TOKEN.DELIMITER, ")");

            expr = {
                type: "CallExpression",
                callee: expr,
                arguments: args
            };
        } else {
            break;
        }
    }

    return expr;
}

function parsePrimary(parser: Parser): Expression | null {
    let typeVal: TOKEN | string = peekType(parser);
    let value: string = peekValue(parser);

    if (typeVal == TOKEN.NUMBER) {
        parserAdvance(parser);
        return {
            type: "Literal",
            literalType: "number",
            value: parseFloat(value)
        };
    }

    if (typeVal == TOKEN.STRING) {
        parserAdvance(parser);
        return {
            type: "Literal",
            literalType: "string",
            value: value
        };
    }

    if (typeVal == TOKEN.KEYWORD) {
        if (value == "null") {
            parserAdvance(parser);
            return {
                type: "Literal",
                literalType: "null",
                value: null
            };
        }
        if (value == "true" || value == "false") {
            parserAdvance(parser);
            return {
                type: "Literal",
                literalType: "boolean",
                value: value == "true"
            };
        }
        if (value == "this") {
            parserAdvance(parser);
            return {
                type: "ThisExpression"
            };
        }
        if (value == "new") {
            return parseNewExpression(parser);
        }
        if (value == "function") {
            return parseFunctionExpression(parser);
        }
        if (value == "class") {
            return parseClassExpression(parser);
        }
        if (value == "if") {
            return parseConditionalExpression(parser);
        }
    }

    if (typeVal == TOKEN.IDENTIFIER) {
        parserAdvance(parser);
        return {
            type: "Identifier",
            name: value
        };
    }

    if (check(parser, TOKEN.DELIMITER, "[")) {
        return parseArrayExpression(parser);
    }

    if (check(parser, TOKEN.DELIMITER, "{")) {
        return parseObjectExpression(parser);
    }

    if (check(parser, TOKEN.DELIMITER, "(")) {
        parserAdvance(parser);

        let inner: Expression | null = parseExpression(parser);

        expect(parser, TOKEN.DELIMITER, ")");

        return inner;
    }

    console.log("Unexpected token:", typeVal, value);
    return null;
}

function parseNewExpression(parser: Parser): NewExpression | null {
    parserAdvance(parser);

    let callee: Expression | null = parseCallMember(parser);
    if (callee == null) {
        return null;
    }

    let args: Array<Expression> = [];
    if (check(parser, TOKEN.DELIMITER, "(")) {
        parserAdvance(parser);

        if (!check(parser, TOKEN.DELIMITER, ")")) {
            while (true) {
                let arg: Expression | null = parseAssignment(parser);
                if (arg != null) {
                    args.push(arg);
                }
                if (!match(parser, TOKEN.DELIMITER, ",")) {
                    break;
                }
            }
        }

        expect(parser, TOKEN.DELIMITER, ")");
    }

    return {
        type: "NewExpression",
        callee: callee,
        arguments: args
    };
}

function parseFunctionExpression(parser: Parser): FunctionExpression | null {
    parserAdvance(parser);

    let name: string = "";
    if (check(parser, TOKEN.IDENTIFIER, null)) {
        name = peekValue(parser);
        parserAdvance(parser);
    }

    expect(parser, TOKEN.DELIMITER, "(");

    let params: Array<string | TypedParam> = [];
    if (!check(parser, TOKEN.DELIMITER, ")")) {
        while (true) {
            let param: string | TypedParam | null = null;

            if (check(parser, TOKEN.IDENTIFIER, null)) {
                param = peekValue(parser);
                parserAdvance(parser);

                if (match(parser, TOKEN.OPERATOR, ":")) {
                    let typeAnn: TypeAnnotation | null = parseTypeAnnotation(parser);
                    param = {
                        name: param,
                        typeAnnotation: typeAnn
                    };
                }
            } else {
                let typedParam: TypedParam | null = parseTypedParam(parser);
                if (typedParam != null) {
                    param = typedParam;
                }
            }

            if (param != null) {
                params.push(param);
            }

            if (!match(parser, TOKEN.DELIMITER, ",")) {
                break;
            }
        }
    }

    expect(parser, TOKEN.DELIMITER, ")");

    let returnType: TypeAnnotation | null = null;
    if (match(parser, TOKEN.OPERATOR, ":")) {
        returnType = parseTypeAnnotation(parser);
    }

    let body: BlockStatement | Expression | null = null;
    if (check(parser, TOKEN.DELIMITER, "{")) {
        body = parseBlockStatement(parser);
    } else if (check(parser, TOKEN.OPERATOR, "=>")) {
        parserAdvance(parser);

        if (check(parser, TOKEN.DELIMITER, "{")) {
            body = parseBlockStatement(parser);
        } else {
            body = parseAssignment(parser);
        }

        return {
            type: "ArrowFunctionExpression",
            params: params,
            body: body,
            returnType: returnType
        };
    }

    return {
        type: "FunctionExpression",
        name: name,
        params: params,
        body: body,
        returnType: returnType
    };
}

function parseClassExpression(parser: Parser): Expression | null {
    console.log("Class expression parsing not fully implemented");
    return parsePrimary(parser);
}

function parseConditionalExpression(parser: Parser): Expression | null {
    parserAdvance(parser);
    expect(parser, TOKEN.DELIMITER, "(");

    let test: Expression | null = parseExpression(parser);

    expect(parser, TOKEN.DELIMITER, ")");

    let consequent: Expression | null = parseExpression(parser);

    expect(parser, TOKEN.DELIMITER, ":");

    let alternate: Expression | null = parseExpression(parser);

    return {
        type: "ConditionalExpression",
        test: test,
        consequent: consequent,
        alternate: alternate
    };
}

function parseArrayExpression(parser: Parser): ArrayExpression | null {
    parserAdvance(parser);

    let elements: Array<Expression | null> = [];
    if (!check(parser, TOKEN.DELIMITER, "]")) {
        while (true) {
            if (check(parser, TOKEN.DELIMITER, ",")) {
                elements.push(null);
            } else if (check(parser, TOKEN.DELIMITER, "]")) {
                break;
            } else {
                let elem: Expression | null = parseAssignment(parser);
                if (elem != null) {
                    elements.push(elem);
                }
            }
            if (!match(parser, TOKEN.DELIMITER, ",")) {
                break;
            }
        }
    }

    expect(parser, TOKEN.DELIMITER, "]");

    return {
        type: "ArrayExpression",
        elements: elements
    };
}

function parseObjectExpression(parser: Parser): ObjectExpression | null {
    parserAdvance(parser);

    let properties: Array<ObjectProperty> = [];
    if (!check(parser, TOKEN.DELIMITER, "}")) {
        while (true) {
            let key: Identifier | Literal | null = null;
            let keyName: string = "";
            let computedKey: boolean = false;

            if (check(parser, TOKEN.IDENTIFIER, null)) {
                keyName = peekValue(parser);
                key = {
                    type: "Identifier",
                    name: keyName
                };
                parserAdvance(parser);
            } else if (check(parser, TOKEN.NUMBER, null)) {
                let numVal: string = peekValue(parser);
                keyName = numVal;
                key = {
                    type: "Literal",
                    literalType: "number",
                    value: parseFloat(numVal)
                };
                parserAdvance(parser);
            } else if (check(parser, TOKEN.STRING, null)) {
                keyName = peekValue(parser);
                key = {
                    type: "Literal",
                    literalType: "string",
                    value: keyName
                };
                parserAdvance(parser);
            } else if (check(parser, TOKEN.DELIMITER, "[")) {
                parserAdvance(parser);
                let exprKey: Expression | null = parseExpression(parser);
                expect(parser, TOKEN.DELIMITER, "]");
                computedKey = true;
                key = exprKey;
            }

            expect(parser, TOKEN.DELIMITER, ":");

            let value: Expression | null = parseAssignment(parser);

            properties.push({
                key: key,
                value: value,
                kind: "init"
            });

            if (!match(parser, TOKEN.DELIMITER, ",")) {
                break;
            }
        }
    }

    expect(parser, TOKEN.DELIMITER, "}");

    return {
        type: "ObjectExpression",
        properties: properties
    };
}
