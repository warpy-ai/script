// ============================================================================
// Bootstrap Parser for tscl
// Recursive descent parser - consumes tokens, produces AST
// Requires: std/prelude.tscl and bootstrap/lexer.tscl to be loaded first
// ============================================================================

// ============================================================================
// Parser State
// ============================================================================

function createParser(tokens) {
    return {
        tokens: tokens,
        pos: 0
    };
}

// ============================================================================
// Utility Functions
// ============================================================================

function parserPeek(parser) {
    if (parser.pos >= parser.tokens.length) {
        return null;
    }
    return parser.tokens[parser.pos];
}

function peekType(parser) {
    let tok = parserPeek(parser);
    if (tok == null) {
        return TOKEN.EOF;
    }
    return tok.type;
}

function peekValue(parser) {
    let tok = parserPeek(parser);
    if (tok == null) {
        return "";
    }
    return tok.value;
}

function parserAdvance(parser) {
    let tok = parserPeek(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

function check(parser, type, value) {
    let tok = parserPeek(parser);
    if (tok == null) {
        return false;
    }
    if (tok.type != type) {
        return false;
    }
    if (value != null && tok.value != value) {
        return false;
    }
    return true;
}

function match(parser, type, value) {
    if (check(parser, type, value)) {
        parserAdvance(parser);
        return true;
    }
    return false;
}

function expect(parser, type, value) {
    if (check(parser, type, value)) {
        return parserAdvance(parser);
    }
    let tok = parserPeek(parser);
    let tokVal = "";
    let tokType = TOKEN.EOF;
    if (tok != null) {
        tokVal = tok.value;
        tokType = tok.type;
    }
    console.log("Parse error: expected", type, value, "but got", tokType, tokVal);
    return null;
}

function isAtEnd(parser) {
    return peekType(parser) == TOKEN.EOF;
}

// ============================================================================
// Statement Parsers
// ============================================================================

function parseProgram(parser) {
    let programBody = [];

    while (!isAtEnd(parser)) {
        let stmt = parseStatement(parser);
        if (stmt != null) {
            programBody.push(stmt);
        }
    }

    return new Program(programBody);
}

function parseStatement(parser) {
    // Check for keyword statements
    if (check(parser, TOKEN.KEYWORD, "let") || check(parser, TOKEN.KEYWORD, "const")) {
        return parseVariableDeclaration(parser);
    }

    if (check(parser, TOKEN.KEYWORD, "function")) {
        return parseFunctionDeclaration(parser);
    }

    if (check(parser, TOKEN.KEYWORD, "return")) {
        return parseReturnStatement(parser);
    }

    if (check(parser, TOKEN.KEYWORD, "if")) {
        return parseIfStatement(parser);
    }

    if (check(parser, TOKEN.KEYWORD, "while")) {
        return parseWhileStatement(parser);
    }

    if (check(parser, TOKEN.KEYWORD, "break")) {
        parserAdvance(parser);
        match(parser, TOKEN.DELIMITER, ";");
        return new BreakStatement();
    }

    if (check(parser, TOKEN.KEYWORD, "continue")) {
        parserAdvance(parser);
        match(parser, TOKEN.DELIMITER, ";");
        return new ContinueStatement();
    }

    if (check(parser, TOKEN.DELIMITER, "{")) {
        return parseBlockStatement(parser);
    }

    // Expression statement
    return parseExpressionStatement(parser);
}

function parseVariableDeclaration(parser) {
    let kindTok = parserAdvance(parser);
    let kind = kindTok.value;

    let nameTok = expect(parser, TOKEN.IDENTIFIER, null);
    if (nameTok == null) {
        return null;
    }
    let name = nameTok.value;

    let init = null;
    if (match(parser, TOKEN.OPERATOR, "=")) {
        init = parseExpression(parser);
    }

    match(parser, TOKEN.DELIMITER, ";");

    return new VariableDeclaration(kind, name, init);
}

function parseFunctionDeclaration(parser) {
    expect(parser, TOKEN.KEYWORD, "function");

    let nameTok = expect(parser, TOKEN.IDENTIFIER, null);
    if (nameTok == null) {
        return null;
    }
    let name = nameTok.value;

    expect(parser, TOKEN.DELIMITER, "(");
    let params = parseParameterList(parser);
    expect(parser, TOKEN.DELIMITER, ")");

    let body = parseBlockStatement(parser);

    return new FunctionDeclaration(name, params, body);
}

function parseParameterList(parser) {
    let params = [];

    if (!check(parser, TOKEN.DELIMITER, ")")) {
        let firstParam = expect(parser, TOKEN.IDENTIFIER, null);
        if (firstParam != null) {
            params.push(firstParam.value);
        }

        while (match(parser, TOKEN.DELIMITER, ",")) {
            let param = expect(parser, TOKEN.IDENTIFIER, null);
            if (param != null) {
                params.push(param.value);
            }
        }
    }

    return params;
}

function parseReturnStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "return");

    let argument = null;
    if (!check(parser, TOKEN.DELIMITER, ";") && !check(parser, TOKEN.DELIMITER, "}")) {
        argument = parseExpression(parser);
    }

    match(parser, TOKEN.DELIMITER, ";");

    return new ReturnStatement(argument);
}

function parseIfStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "if");
    expect(parser, TOKEN.DELIMITER, "(");
    let test = parseExpression(parser);
    expect(parser, TOKEN.DELIMITER, ")");

    let consequent = parseStatement(parser);

    let alternate = null;
    if (match(parser, TOKEN.KEYWORD, "else")) {
        alternate = parseStatement(parser);
    }

    return new IfStatement(test, consequent, alternate);
}

function parseWhileStatement(parser) {
    expect(parser, TOKEN.KEYWORD, "while");
    expect(parser, TOKEN.DELIMITER, "(");
    let test = parseExpression(parser);
    expect(parser, TOKEN.DELIMITER, ")");

    let body = parseStatement(parser);

    return new WhileStatement(test, body);
}

function parseBlockStatement(parser) {
    expect(parser, TOKEN.DELIMITER, "{");

    let blockBody = [];
    while (!check(parser, TOKEN.DELIMITER, "}") && !isAtEnd(parser)) {
        let stmt = parseStatement(parser);
        if (stmt != null) {
            blockBody.push(stmt);
        }
    }

    expect(parser, TOKEN.DELIMITER, "}");

    return new BlockStatement(blockBody);
}

function parseExpressionStatement(parser) {
    let expr = parseExpression(parser);
    match(parser, TOKEN.DELIMITER, ";");
    return new ExpressionStatement(expr);
}

// ============================================================================
// Expression Parsers (Precedence Climbing)
// ============================================================================

function parseExpression(parser) {
    return parseAssignment(parser);
}

function parseAssignment(parser) {
    let left = parseLogicalOr(parser);

    if (check(parser, TOKEN.OPERATOR, "=")) {
        parserAdvance(parser);
        let right = parseAssignment(parser);
        return new AssignmentExpression("=", left, right);
    }

    return left;
}

function parseLogicalOr(parser) {
    let left = parseLogicalAnd(parser);

    while (check(parser, TOKEN.OPERATOR, "||")) {
        let op = parserAdvance(parser).value;
        let right = parseLogicalAnd(parser);
        left = new BinaryExpression(op, left, right);
    }

    return left;
}

function parseLogicalAnd(parser) {
    let left = parseEquality(parser);

    while (check(parser, TOKEN.OPERATOR, "&&")) {
        let op = parserAdvance(parser).value;
        let right = parseEquality(parser);
        left = new BinaryExpression(op, left, right);
    }

    return left;
}

function parseEquality(parser) {
    let left = parseComparison(parser);

    while (check(parser, TOKEN.OPERATOR, "==") || check(parser, TOKEN.OPERATOR, "!=")) {
        let op = parserAdvance(parser).value;
        let right = parseComparison(parser);
        left = new BinaryExpression(op, left, right);
    }

    return left;
}

function parseComparison(parser) {
    let left = parseAdditive(parser);

    while (check(parser, TOKEN.OPERATOR, "<") || check(parser, TOKEN.OPERATOR, ">") ||
           check(parser, TOKEN.OPERATOR, "<=") || check(parser, TOKEN.OPERATOR, ">=")) {
        let op = parserAdvance(parser).value;
        let right = parseAdditive(parser);
        left = new BinaryExpression(op, left, right);
    }

    return left;
}

function parseAdditive(parser) {
    let left = parseMultiplicative(parser);
    if (left.type == "Literal" && left.literalType == "number") {
        console.log("DEBUG parseAdditive: after parsing left, value =", left.value);
    }

    while (check(parser, TOKEN.OPERATOR, "+") || check(parser, TOKEN.OPERATOR, "-")) {
        let op = parserAdvance(parser).value;
        if (left.type == "Literal" && left.literalType == "number") {
            console.log("DEBUG parseAdditive: before parsing right, left.value =", left.value);
        }
        let right = parseMultiplicative(parser);
        if (left.type == "Literal" && left.literalType == "number") {
            console.log("DEBUG parseAdditive: after parsing right, left.value =", left.value);
        }
        if (right.type == "Literal" && right.literalType == "number") {
            console.log("DEBUG parseAdditive: right.value =", right.value);
        }
        let binExpr = new BinaryExpression(op, left, right);
        console.log("DEBUG parseAdditive: binExpr.left.value =", binExpr.left.value);
        console.log("DEBUG parseAdditive: binExpr.right.value =", binExpr.right.value);
        left = binExpr;
    }

    return left;
}

function parseMultiplicative(parser) {
    let left = parseUnary(parser);

    while (check(parser, TOKEN.OPERATOR, "*") || check(parser, TOKEN.OPERATOR, "/") ||
           check(parser, TOKEN.OPERATOR, "%")) {
        let op = parserAdvance(parser).value;
        let right = parseUnary(parser);
        left = new BinaryExpression(op, left, right);
    }

    return left;
}

function parseUnary(parser) {
    if (check(parser, TOKEN.OPERATOR, "!") || check(parser, TOKEN.OPERATOR, "-")) {
        let op = parserAdvance(parser).value;
        let argument = parseUnary(parser);
        return new UnaryExpression(op, argument);
    }

    return parseCallMember(parser);
}

function parseCallMember(parser) {
    let expr = parsePrimary(parser);

    while (true) {
        if (check(parser, TOKEN.DELIMITER, "(")) {
            // Function call
            parserAdvance(parser);
            let args = parseArgumentList(parser);
            expect(parser, TOKEN.DELIMITER, ")");
            expr = new CallExpression(expr, args);
        } else if (check(parser, TOKEN.DELIMITER, ".")) {
            // Member access: obj.prop
            parserAdvance(parser);
            let propTok = expect(parser, TOKEN.IDENTIFIER, null);
            if (propTok != null) {
                let prop = new Identifier(propTok.value);
                expr = new MemberExpression(expr, prop, false);
            }
        } else if (check(parser, TOKEN.DELIMITER, "[")) {
            // Computed member access: obj[expr]
            parserAdvance(parser);
            let prop = parseExpression(parser);
            expect(parser, TOKEN.DELIMITER, "]");
            expr = new MemberExpression(expr, prop, true);
        } else {
            break;
        }
    }

    return expr;
}

function parseArgumentList(parser) {
    let args = [];

    if (!check(parser, TOKEN.DELIMITER, ")")) {
        args.push(parseExpression(parser));

        while (match(parser, TOKEN.DELIMITER, ",")) {
            args.push(parseExpression(parser));
        }
    }

    return args;
}

function parsePrimary(parser) {
    // new expression
    if (check(parser, TOKEN.KEYWORD, "new")) {
        return parseNewExpression(parser);
    }

    // this
    if (check(parser, TOKEN.KEYWORD, "this")) {
        parserAdvance(parser);
        return new ThisExpression();
    }

    // true/false
    if (check(parser, TOKEN.KEYWORD, "true")) {
        parserAdvance(parser);
        return new Literal(true, "true", "boolean");
    }
    if (check(parser, TOKEN.KEYWORD, "false")) {
        parserAdvance(parser);
        return new Literal(false, "false", "boolean");
    }

    // null
    if (check(parser, TOKEN.KEYWORD, "null")) {
        parserAdvance(parser);
        return new Literal(null, "null", "null");
    }

    // number
    if (check(parser, TOKEN.NUMBER, null)) {
        let tok = parserAdvance(parser);
        let numVal = parseFloat(tok.value);
        console.log("DEBUG parser: creating Literal with numVal =", numVal);
        let lit = new Literal(numVal, tok.value, "number");
        console.log("DEBUG parser: Literal.value =", lit.value);
        return lit;
    }

    // string
    if (check(parser, TOKEN.STRING, null)) {
        let tok = parserAdvance(parser);
        return new Literal(tok.value, tok.value, "string");
    }

    // identifier (might be start of arrow function)
    if (check(parser, TOKEN.IDENTIFIER, null)) {
        let tok = parserAdvance(parser);

        // Check for arrow function: ident => ...
        if (check(parser, TOKEN.OPERATOR, "=>")) {
            parserAdvance(parser);
            let body = parseArrowBody(parser);
            return new ArrowFunctionExpression([tok.value], body);
        }

        return new Identifier(tok.value);
    }

    // Parenthesized expression or arrow function params
    if (check(parser, TOKEN.DELIMITER, "(")) {
        parserAdvance(parser);

        // Check for empty parens: () => ...
        if (check(parser, TOKEN.DELIMITER, ")")) {
            parserAdvance(parser);
            if (check(parser, TOKEN.OPERATOR, "=>")) {
                parserAdvance(parser);
                let body = parseArrowBody(parser);
                return new ArrowFunctionExpression([], body);
            }
            console.log("Parse error: unexpected ()");
            return null;
        }

        // Could be (expr) or (param, param) => ...
        let first = parseExpression(parser);

        // Check if it's a parameter list
        if (check(parser, TOKEN.DELIMITER, ",")) {
            let params = [];
            if (first.type == "Identifier") {
                params.push(first.name);
            }

            while (match(parser, TOKEN.DELIMITER, ",")) {
                let paramTok = expect(parser, TOKEN.IDENTIFIER, null);
                if (paramTok != null) {
                    params.push(paramTok.value);
                }
            }

            expect(parser, TOKEN.DELIMITER, ")");
            expect(parser, TOKEN.OPERATOR, "=>");
            let body = parseArrowBody(parser);
            return new ArrowFunctionExpression(params, body);
        }

        expect(parser, TOKEN.DELIMITER, ")");

        // Check for single-param arrow: (x) => ...
        if (check(parser, TOKEN.OPERATOR, "=>")) {
            parserAdvance(parser);
            let params = [];
            if (first.type == "Identifier") {
                params.push(first.name);
            }
            let body = parseArrowBody(parser);
            return new ArrowFunctionExpression(params, body);
        }

        // Just a parenthesized expression
        return first;
    }

    // Array literal
    if (check(parser, TOKEN.DELIMITER, "[")) {
        return parseArrayLiteral(parser);
    }

    // Object literal
    if (check(parser, TOKEN.DELIMITER, "{")) {
        return parseObjectLiteral(parser);
    }

    // function expression
    if (check(parser, TOKEN.KEYWORD, "function")) {
        return parseFunctionExpression(parser);
    }

    console.log("Parse error: unexpected token", peekType(parser), peekValue(parser));
    parserAdvance(parser);
    return null;
}

function parseArrowBody(parser) {
    if (check(parser, TOKEN.DELIMITER, "{")) {
        return parseBlockStatement(parser);
    }
    // Expression body
    return parseExpression(parser);
}

function parseNewExpression(parser) {
    expect(parser, TOKEN.KEYWORD, "new");

    // Parse the constructor
    let callee = parsePrimary(parser);

    // Handle member access on constructor: new foo.Bar()
    while (check(parser, TOKEN.DELIMITER, ".")) {
        parserAdvance(parser);
        let propTok = expect(parser, TOKEN.IDENTIFIER, null);
        if (propTok != null) {
            let prop = new Identifier(propTok.value);
            callee = new MemberExpression(callee, prop, false);
        }
    }

    // Parse arguments if present
    let args = [];
    if (check(parser, TOKEN.DELIMITER, "(")) {
        parserAdvance(parser);
        args = parseArgumentList(parser);
        expect(parser, TOKEN.DELIMITER, ")");
    }

    return new NewExpression(callee, args);
}

function parseArrayLiteral(parser) {
    expect(parser, TOKEN.DELIMITER, "[");

    let elements = [];

    if (!check(parser, TOKEN.DELIMITER, "]")) {
        elements.push(parseExpression(parser));

        while (match(parser, TOKEN.DELIMITER, ",")) {
            if (check(parser, TOKEN.DELIMITER, "]")) {
                break;
            }
            elements.push(parseExpression(parser));
        }
    }

    expect(parser, TOKEN.DELIMITER, "]");

    return new ArrayExpression(elements);
}

function parseObjectLiteral(parser) {
    expect(parser, TOKEN.DELIMITER, "{");

    let properties = [];

    if (!check(parser, TOKEN.DELIMITER, "}")) {
        properties.push(parseProperty(parser));

        while (match(parser, TOKEN.DELIMITER, ",")) {
            if (check(parser, TOKEN.DELIMITER, "}")) {
                break;
            }
            properties.push(parseProperty(parser));
        }
    }

    expect(parser, TOKEN.DELIMITER, "}");

    return new ObjectExpression(properties);
}

function parseProperty(parser) {
    let key = null;

    if (check(parser, TOKEN.IDENTIFIER, null)) {
        let tok = parserAdvance(parser);
        key = new Identifier(tok.value);
    } else if (check(parser, TOKEN.STRING, null)) {
        let tok = parserAdvance(parser);
        key = new Literal(tok.value, tok.value);
    } else {
        console.log("Parse error: expected property key");
        return null;
    }

    expect(parser, TOKEN.DELIMITER, ":");
    let value = parseExpression(parser);

    return new Property(key, value);
}

function parseFunctionExpression(parser) {
    expect(parser, TOKEN.KEYWORD, "function");

    // Optional name
    let name = null;
    if (check(parser, TOKEN.IDENTIFIER, null)) {
        name = parserAdvance(parser).value;
    }

    expect(parser, TOKEN.DELIMITER, "(");
    let params = parseParameterList(parser);
    expect(parser, TOKEN.DELIMITER, ")");

    let body = parseBlockStatement(parser);

    let fn = new FunctionDeclaration(name, params, body);
    fn.type = "FunctionExpression";
    return fn;
}

// ============================================================================
// Main parse function
// ============================================================================

function parse(tokens) {
    let parser = createParser(tokens);
    return parseProgram(parser);
}

// ============================================================================
// Helper: parseSource - tokenize and parse in one call
// ============================================================================

function parseSource(source) {
    let tokens = tokenize(source);
    return parse(tokens);
}

// ============================================================================
// AST Printer (for debugging)
// ============================================================================

function printAST(node, indent) {
    if (node == null) {
        console.log(indent + "null");
        return;
    }

    let nextIndent = indent + "  ";

    if (node.type == "Program") {
        console.log(indent + "Program");
        let i = 0;
        while (i < node.body.length) {
            printAST(node.body[i], nextIndent);
            i = i + 1;
        }
    } else if (node.type == "VariableDeclaration") {
        console.log(indent + "VariableDeclaration", node.kind, node.name);
        if (node.init != null) {
            printAST(node.init, nextIndent);
        }
    } else if (node.type == "FunctionDeclaration" || node.type == "FunctionExpression") {
        console.log(indent + node.type, node.name, "params:", node.params.length);
        printAST(node.body, nextIndent);
    } else if (node.type == "ReturnStatement") {
        console.log(indent + "ReturnStatement");
        printAST(node.argument, nextIndent);
    } else if (node.type == "IfStatement") {
        console.log(indent + "IfStatement");
        console.log(nextIndent + "test:");
        printAST(node.test, nextIndent + "  ");
        console.log(nextIndent + "consequent:");
        printAST(node.consequent, nextIndent + "  ");
        if (node.alternate != null) {
            console.log(nextIndent + "alternate:");
            printAST(node.alternate, nextIndent + "  ");
        }
    } else if (node.type == "WhileStatement") {
        console.log(indent + "WhileStatement");
        console.log(nextIndent + "test:");
        printAST(node.test, nextIndent + "  ");
        console.log(nextIndent + "body:");
        printAST(node.body, nextIndent + "  ");
    } else if (node.type == "BlockStatement") {
        console.log(indent + "BlockStatement");
        let i = 0;
        while (i < node.body.length) {
            printAST(node.body[i], nextIndent);
            i = i + 1;
        }
    } else if (node.type == "ExpressionStatement") {
        console.log(indent + "ExpressionStatement");
        printAST(node.expression, nextIndent);
    } else if (node.type == "BinaryExpression") {
        console.log(indent + "BinaryExpression", node.operator);
        printAST(node.left, nextIndent);
        printAST(node.right, nextIndent);
    } else if (node.type == "UnaryExpression") {
        console.log(indent + "UnaryExpression", node.operator);
        printAST(node.argument, nextIndent);
    } else if (node.type == "AssignmentExpression") {
        console.log(indent + "AssignmentExpression", node.operator);
        printAST(node.left, nextIndent);
        printAST(node.right, nextIndent);
    } else if (node.type == "CallExpression") {
        console.log(indent + "CallExpression");
        console.log(nextIndent + "callee:");
        printAST(node.callee, nextIndent + "  ");
        console.log(nextIndent + "arguments:", node.arguments.length);
        let i = 0;
        while (i < node.arguments.length) {
            printAST(node.arguments[i], nextIndent + "  ");
            i = i + 1;
        }
    } else if (node.type == "MemberExpression") {
        console.log(indent + "MemberExpression", node.computed);
        console.log(nextIndent + "object:");
        printAST(node.object, nextIndent + "  ");
        console.log(nextIndent + "property:");
        printAST(node.property, nextIndent + "  ");
    } else if (node.type == "Identifier") {
        console.log(indent + "Identifier", node.name);
    } else if (node.type == "Literal") {
        console.log(indent + "Literal", node.value);
    } else if (node.type == "ArrayExpression") {
        console.log(indent + "ArrayExpression", node.elements.length, "elements");
        let i = 0;
        while (i < node.elements.length) {
            printAST(node.elements[i], nextIndent);
            i = i + 1;
        }
    } else if (node.type == "ObjectExpression") {
        console.log(indent + "ObjectExpression", node.properties.length, "properties");
        let i = 0;
        while (i < node.properties.length) {
            let prop = node.properties[i];
            console.log(nextIndent + "Property:");
            printAST(prop.key, nextIndent + "  ");
            printAST(prop.value, nextIndent + "  ");
            i = i + 1;
        }
    } else if (node.type == "NewExpression") {
        console.log(indent + "NewExpression");
        console.log(nextIndent + "callee:");
        printAST(node.callee, nextIndent + "  ");
        console.log(nextIndent + "arguments:", node.arguments.length);
    } else if (node.type == "ThisExpression") {
        console.log(indent + "ThisExpression");
    } else if (node.type == "ArrowFunctionExpression") {
        console.log(indent + "ArrowFunctionExpression params:", node.params.length);
        printAST(node.body, nextIndent);
    } else if (node.type == "BreakStatement") {
        console.log(indent + "BreakStatement");
    } else if (node.type == "ContinueStatement") {
        console.log(indent + "ContinueStatement");
    } else {
        console.log(indent + "Unknown node type:", node.type);
    }
}
