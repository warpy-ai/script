// ============================================================================
// Bootstrap Lexer for tscl
// Self-hosting lexer implementation
// Requires: std/prelude.tscl to be loaded first
// ============================================================================

// ============================================================================
// Lexer State
// ============================================================================

function createLexer(source) {
    return {
        source: source,
        pos: 0,
        line: 1,
        col: 1,
        tokens: []
    };
}

// ============================================================================
// Core Scanning Functions
// ============================================================================

function lexerPeek(lexer) {
    if (lexer.pos >= lexer.source.length) {
        return -1;
    }
    return lexer.source.charCodeAt(lexer.pos);
}

function lexerPeekNext(lexer) {
    if (lexer.pos + 1 >= lexer.source.length) {
        return -1;
    }
    return lexer.source.charCodeAt(lexer.pos + 1);
}

function lexerAdvance(lexer) {
    let code = lexerPeek(lexer);
    lexer.pos = lexer.pos + 1;
    if (code == 10) {
        lexer.line = lexer.line + 1;
        lexer.col = 1;
    } else {
        lexer.col = lexer.col + 1;
    }
    return code;
}

// ============================================================================
// Whitespace and Comments
// ============================================================================

function skipWhitespace(lexer) {
    while (lexer.pos < lexer.source.length) {
        let code = lexerPeek(lexer);

        if (isWhitespace(code)) {
            lexerAdvance(lexer);
            continue;
        }

        // Check for comment: // (47 is '/')
        if (code == 47) {
            let nextCode = lexerPeekNext(lexer);
            if (nextCode == 47) {
                // Single-line comment
                lexerAdvance(lexer);
                lexerAdvance(lexer);
                while (lexer.pos < lexer.source.length) {
                    if (lexerPeek(lexer) == 10) {
                        lexerAdvance(lexer);
                        break;
                    }
                    lexerAdvance(lexer);
                }
                continue;
            }
        }

        return;
    }
}

// ============================================================================
// Token Scanners
// ============================================================================

function scanIdentifier(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let start = lexer.pos;

    while (lexer.pos < lexer.source.length && isAlphaNumeric(lexerPeek(lexer))) {
        lexerAdvance(lexer);
    }

    let value = lexer.source.slice(start, lexer.pos);

    // Check if it's a keyword
    let type = TOKEN.IDENTIFIER;
    if (arrayIncludes(KEYWORDS, value)) {
        type = TOKEN.KEYWORD;
    }

    return makeToken(type, value, startLine, startCol);
}

function scanNumber(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let start = lexer.pos;

    // Check for hex literal: 0x or 0X
    if (lexerPeek(lexer) == 48) { // '0'
        let next = lexerPeekNext(lexer);
        if (next == 120 || next == 88) { // 'x' or 'X'
            lexerAdvance(lexer); // consume '0'
            lexerAdvance(lexer); // consume 'x'

            // Parse hex digits and compute value
            let hexValue = 0;
            while (lexer.pos < lexer.source.length && isHexDigit(lexerPeek(lexer))) {
                hexValue = hexValue * 16 + hexCharToValue(lexerPeek(lexer));
                lexerAdvance(lexer);
            }

            // Return the decimal string representation
            return makeToken(TOKEN.NUMBER, "" + hexValue, startLine, startCol);
        }
    }

    // Regular decimal number
    while (lexer.pos < lexer.source.length && isDigit(lexerPeek(lexer))) {
        lexerAdvance(lexer);
    }

    // Check for decimal point (46 = '.')
    if (lexerPeek(lexer) == 46 && isDigit(lexerPeekNext(lexer))) {
        lexerAdvance(lexer);
        while (lexer.pos < lexer.source.length && isDigit(lexerPeek(lexer))) {
            lexerAdvance(lexer);
        }
    }

    let value = lexer.source.slice(start, lexer.pos);
    return makeToken(TOKEN.NUMBER, value, startLine, startCol);
}

function scanString(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;
    let quote = lexerPeek(lexer); // 34 = " or 39 = '
    lexerAdvance(lexer);

    let value = "";

    while (lexer.pos < lexer.source.length) {
        let code = lexerPeek(lexer);

        if (code == quote) {
            lexerAdvance(lexer);
            return makeToken(TOKEN.STRING, value, startLine, startCol);
        }

        if (code == 92) {
            // backslash - escape sequence
            lexerAdvance(lexer);
            let nextCode = lexerPeek(lexer);
            if (nextCode == 110) { value = value + "\n"; }
            else if (nextCode == 116) { value = value + "\t"; }
            else if (nextCode == 34) { value = value + "\""; }
            else if (nextCode == 39) { value = value + "'"; }
            else if (nextCode == 92) { value = value + "\\"; }
            else if (nextCode != -1) {
                value = value + String.fromCharCode(nextCode);
            }
            lexerAdvance(lexer);
        } else if (code == 10) {
            return makeToken(TOKEN.ERROR, "Unterminated string", startLine, startCol);
        } else {
            value = value + lexer.source.slice(lexer.pos, lexer.pos + 1);
            lexerAdvance(lexer);
        }
    }

    return makeToken(TOKEN.ERROR, "Unterminated string", startLine, startCol);
}

function scanOperatorOrDelimiter(lexer) {
    let startLine = lexer.line;
    let startCol = lexer.col;

    if (lexer.pos >= lexer.source.length) {
        return makeToken(TOKEN.ERROR, "Unexpected end of file", startLine, startCol);
    }

    let code = lexerPeek(lexer);
    let char = String.fromCharCode(code);

    // Check for two-character operators first
    if (lexer.pos + 1 < lexer.source.length) {
        let twoChar = lexer.source.slice(lexer.pos, lexer.pos + 2);
        if (arrayIncludes(TWO_CHAR_OPS, twoChar)) {
            lexerAdvance(lexer);
            lexerAdvance(lexer);
            return makeToken(TOKEN.OPERATOR, twoChar, startLine, startCol);
        }
    }

    // Check single-character operators
    if (arrayIncludes(SINGLE_CHAR_OPS, char)) {
        lexerAdvance(lexer);
        return makeToken(TOKEN.OPERATOR, char, startLine, startCol);
    }

    // Check delimiters
    if (arrayIncludes(DELIMITERS, char)) {
        lexerAdvance(lexer);
        return makeToken(TOKEN.DELIMITER, char, startLine, startCol);
    }

    // Unknown character
    lexerAdvance(lexer);
    return makeToken(TOKEN.ERROR, "Unknown character: " + char, startLine, startCol);
}

// ============================================================================
// Main Tokenize Function
// ============================================================================

function tokenize(source) {
    let lexer = createLexer(source);

    while (lexer.pos < lexer.source.length) {
        skipWhitespace(lexer);

        if (lexer.pos >= lexer.source.length) {
            break;
        }

        let code = lexerPeek(lexer);
        if (code == -1) {
            break;
        }

        let token = null;

        if (isAlpha(code)) {
            token = scanIdentifier(lexer);
        } else if (isDigit(code)) {
            token = scanNumber(lexer);
        } else if (code == 34 || code == 39) {
            token = scanString(lexer);
        } else {
            token = scanOperatorOrDelimiter(lexer);
        }

        lexer.tokens.push(token);
    }

    // Add EOF token
    lexer.tokens.push(makeToken(TOKEN.EOF, "", lexer.line, lexer.col));

    return lexer.tokens;
}

// ============================================================================
// Debug Helper
// ============================================================================

function printTokens(tokens) {
    let i = 0;
    while (i < tokens.length) {
        let tok = tokens[i];
        console.log(tok.type, tok.value, "at line", tok.line, "col", tok.col);
        i = i + 1;
    }
}

