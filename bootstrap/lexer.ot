// ============================================================================
// Bootstrap Lexer for tscl
// Self-hosting lexer implementation
// Requires: std/prelude.tscl to be loaded first
// ============================================================================

// ============================================================================
// Lexer State
// ============================================================================

function createLexer(source: string): Lexer {
    return {
        source: source,
        pos: 0,
        line: 1,
        col: 1,
        tokens: []
    };
}

// ============================================================================
// Core Scanning Functions
// ============================================================================

function lexerPeek(lexer: Lexer): number {
    if (lexer.pos >= lexer.source.length) {
        return -1;
    }
    return lexer.source.charCodeAt(lexer.pos);
}

function lexerPeekNext(lexer: Lexer): number {
    if (lexer.pos + 1 >= lexer.source.length) {
        return -1;
    }
    return lexer.source.charCodeAt(lexer.pos + 1);
}

function lexerAdvance(lexer: Lexer): number {
    let code: number = lexerPeek(lexer);
    lexer.pos = lexer.pos + 1;
    if (code == 10) {
        lexer.line = lexer.line + 1;
        lexer.col = 1;
    } else {
        lexer.col = lexer.col + 1;
    }
    return code;
}

// ============================================================================
// Whitespace and Comments
// ============================================================================

function skipWhitespace(lexer: Lexer): void {
    while (lexer.pos < lexer.source.length) {
        let code: number = lexerPeek(lexer);

        if (isWhitespace(code)) {
            lexerAdvance(lexer);
            continue;
        }

        // Check for comment: // (47 is '/')
        if (code == 47) {
            let nextCode: number = lexerPeekNext(lexer);
            if (nextCode == 47) {
                // Single-line comment
                lexerAdvance(lexer);
                lexerAdvance(lexer);
                while (lexer.pos < lexer.source.length) {
                    if (lexerPeek(lexer) == 10) {
                        lexerAdvance(lexer);
                        break;
                    }
                    lexerAdvance(lexer);
                }
                continue;
            }
        }

        return;
    }
}

// ============================================================================
// Token Scanners
// ============================================================================

function isKeyword(value: string): boolean {
    return value == "let" || value == "const" || value == "var" ||
           value == "function" || value == "return" || value == "if" ||
           value == "else" || value == "while" || value == "for" ||
           value == "break" || value == "continue" || value == "this" ||
           value == "null" || value == "true" || value == "false" ||
           value == "new" || value == "class" || value == "extends" ||
           value == "super" || value == "import" || value == "export" ||
           value == "default" || value == "async" || value == "await" ||
           value == "yield" || value == "try" || value == "catch" ||
           value == "finally" || value == "throw" || value == "instanceof" ||
           value == "typeof" || value == "from" || value == "as" ||
           // TypeScript keywords
           value == "type" || value == "interface" || value == "enum" ||
           value == "implements" || value == "private" || value == "public" ||
           value == "protected" || value == "readonly" || value == "abstract" ||
           value == "declare" || value == "namespace" || value == "module" ||
           // Type keywords (for annotations)
           value == "number" || value == "string" || value == "boolean" ||
           value == "any" || value == "void" || value == "never" ||
           value == "undefined" || value == "unknown" || value == "object";
}

function scanIdentifierOrKeyword(lexer: Lexer): Token {
    let startLine: number = lexer.line;
    let startCol: number = lexer.col;
    let start: number = lexer.pos;

    while (lexer.pos < lexer.source.length && isAlphaNumeric(lexerPeek(lexer))) {
        lexerAdvance(lexer);
    }

    let value: string = lexer.source.slice(start, lexer.pos);
    if (isKeyword(value)) {
        return makeToken(TOKEN.KEYWORD, value, startLine, startCol);
    }
    return makeToken(TOKEN.IDENTIFIER, value, startLine, startCol);
}

function scanNumber(lexer: Lexer): Token {
    let startLine: number = lexer.line;
    let startCol: number = lexer.col;
    let start: number = lexer.pos;

    // Check for hex number (0x or 0X)
    if (lexerPeek(lexer) == 48) { // '0'
        lexerAdvance(lexer);
        if (lexerPeek(lexer) == 120 || lexerPeek(lexer) == 88) { // 'x' or 'X'
            lexerAdvance(lexer);
            // Scan hex digits
            while (lexer.pos < lexer.source.length && isHexDigit(lexerPeek(lexer))) {
                lexerAdvance(lexer);
            }
            let value: string = lexer.source.slice(start, lexer.pos);
            return makeToken(TOKEN.NUMBER, value, startLine, startCol);
        }
        // Not a hex number, continue with decimal
    }

    while (lexer.pos < lexer.source.length && isDigit(lexerPeek(lexer))) {
        lexerAdvance(lexer);
    }

    // Check for decimal point
    if (lexerPeek(lexer) == 46) { // '.'
        lexerAdvance(lexer);
        while (lexer.pos < lexer.source.length && isDigit(lexerPeek(lexer))) {
            lexerAdvance(lexer);
        }
    }

    let value: string = lexer.source.slice(start, lexer.pos);
    return makeToken(TOKEN.NUMBER, value, startLine, startCol);
}

function scanString(lexer: Lexer): Token {
    let startLine: number = lexer.line;
    let startCol: number = lexer.col;
    let quote: number = lexerPeek(lexer);
    lexerAdvance(lexer); // Skip opening quote

    let value: string = "";
    while (lexer.pos < lexer.source.length) {
        let code: number = lexerPeek(lexer);
        if (code == quote) {
            lexerAdvance(lexer);
            break;
        }
        if (code == 92) { // Backslash escape
            lexerAdvance(lexer);
            let nextCode: number = lexerPeek(lexer);
            if (nextCode == 110) { // 'n'
                value = value + "\n";
            } else if (nextCode == 116) { // 't'
                value = value + "\t";
            } else if (nextCode == 114) { // 'r'
                value = value + "\r";
            } else if (nextCode == 92) { // Backslash
                value = value + "\\";
            } else if (nextCode == 39) { // Single quote
                value = value + "'";
            } else if (nextCode == 34) { // Double quote
                value = value + "\"";
            } else if (nextCode == 96) { // Backtick
                value = value + "`";
            } else {
                value = value + String.fromCharCode(nextCode);
            }
            lexerAdvance(lexer);
        } else {
            value = value + String.fromCharCode(code);
            lexerAdvance(lexer);
        }
    }

    return makeToken(TOKEN.STRING, value, startLine, startCol);
}

function makeToken(typeVal: TOKEN | string, value: string, line: number, col: number): Token {
    return {
        type: typeVal,
        value: value,
        line: line,
        col: col
    };
}

// ============================================================================
// Main Tokenization Function
// ============================================================================

function tokenize(source: string): Array<Token> {
    let lexer: Lexer = createLexer(source);

    while (lexer.pos < lexer.source.length) {
        skipWhitespace(lexer);

        if (lexer.pos >= lexer.source.length) {
            break;
        }

        let code: number = lexerPeek(lexer);

        // Identifier or keyword
        if (isAlpha(code)) {
            let token: Token = scanIdentifierOrKeyword(lexer);
            lexer.tokens.push(token);
            continue;
        }

        // Number
        if (isDigit(code)) {
            let token: Token = scanNumber(lexer);
            lexer.tokens.push(token);
            continue;
        }

        // String
        if (code == 34 || code == 39 || code == 96) { // ", ', `
            let token: Token = scanString(lexer);
            lexer.tokens.push(token);
            continue;
        }

        // Operators and delimiters
        let startLine: number = lexer.line;
        let startCol: number = lexer.col;
        let value: string = String.fromCharCode(code);
        lexerAdvance(lexer);

        // Handle multi-character operators
        if (code == 61) { // =
            if (lexerPeek(lexer) == 61) { // ==
                value = "==";
                lexerAdvance(lexer);
                if (lexerPeek(lexer) == 61) { // ===
                    value = "===";
                    lexerAdvance(lexer);
                }
            } else if (lexerPeek(lexer) == 62) { // =>
                value = "=>";
                lexerAdvance(lexer);
            }
        } else if (code == 38) { // &
            if (lexerPeek(lexer) == 38) { // &&
                value = "&&";
                lexerAdvance(lexer);
            }
        } else if (code == 124) { // |
            if (lexerPeek(lexer) == 124) { // ||
                value = "||";
                lexerAdvance(lexer);
            }
        } else if (code == 33) { // !
            if (lexerPeek(lexer) == 61) { // !=
                value = "!=";
                lexerAdvance(lexer);
                if (lexerPeek(lexer) == 61) { // !==
                    value = "!==";
                    lexerAdvance(lexer);
                }
            }
        } else if (code == 60) { // <
            if (lexerPeek(lexer) == 61) { // <=
                value = "<=";
                lexerAdvance(lexer);
            } else if (lexerPeek(lexer) == 60) { // <<
                value = "<<";
                lexerAdvance(lexer);
            }
        } else if (code == 62) { // >
            if (lexerPeek(lexer) == 61) { // >=
                value = ">=";
                lexerAdvance(lexer);
            } else if (lexerPeek(lexer) == 62) { // >>
                value = ">>";
                lexerAdvance(lexer);
            }
        } else if (code == 43) { // +
            if (lexerPeek(lexer) == 43) { // ++
                value = "++";
                lexerAdvance(lexer);
            }
        } else if (code == 45) { // -
            if (lexerPeek(lexer) == 45) { // --
                value = "--";
                lexerAdvance(lexer);
            }
        } else if (code == 42) { // *
            if (lexerPeek(lexer) == 42) { // **
                value = "**";
                lexerAdvance(lexer);
            }
        } else if (code == 47) { // /
            if (lexerPeek(lexer) == 47) { // //
                value = "//";
                lexerAdvance(lexer);
            } else if (lexerPeek(lexer) == 42) { // /*
                value = "/*";
                lexerAdvance(lexer);
                while (lexer.pos < lexer.source.length) {
                    if (lexerPeek(lexer) == 42) {
                        lexerAdvance(lexer);
                        if (lexerPeek(lexer) == 47) {
                            lexerAdvance(lexer);
                            break;
                        }
                    } else {
                        lexerAdvance(lexer);
                    }
                }
                // Treat comments as tokens that will be skipped
                continue;
            }
        } else if (code == 46) { // .
            if (lexerPeek(lexer) == 46) {
                lexerAdvance(lexer);
                if (lexerPeek(lexer) == 46) { // ...
                    value = "...";
                    lexerAdvance(lexer);
                }
            }
        }

        // Check if it's an operator or delimiter
        if (value == "{" || value == "}" || value == "(" || value == ")" ||
            value == "[" || value == "]" || value == ";" || value == "," ||
            value == "." || value == "..." || value == ":") {
            lexer.tokens.push(makeToken(TOKEN.DELIMITER, value, startLine, startCol));
        } else {
            lexer.tokens.push(makeToken(TOKEN.OPERATOR, value, startLine, startCol));
        }
    }

    // Add EOF token
    lexer.tokens.push(makeToken(TOKEN.EOF, "", lexer.line, lexer.col));

    return lexer.tokens;
}
