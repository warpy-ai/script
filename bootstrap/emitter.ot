// ============================================================================
// Bootstrap Emitter for Oite
// Transforms AST to bytecode using ByteStream
// Requires: std/prelude.ot, bootstrap/lexer.ot, and bootstrap/parser.ot
// ============================================================================

// ============================================================================
// Emitter State
// ============================================================================

function createEmitter(): Emitter {
    return {
        stream: ByteStream.create(),
        functions: {},
        patches: [],
        loopStack: [],
        scope: null
    };
}

// ============================================================================
// ByteStream Helpers
// ============================================================================

function emitU8(emitter: Emitter, byte: number): void {
    ByteStream.writeU8(emitter.stream, byte);
}

function emitU32(emitter: Emitter, value: number): void {
    ByteStream.writeU32(emitter.stream, value);
}

function emitF64(emitter: Emitter, value: number): void {
    ByteStream.writeF64(emitter.stream, value);
}

function emitVarint(emitter: Emitter, value: number): void {
    ByteStream.writeVarint(emitter.stream, value);
}

function emitString(emitter: Emitter, str: string): void {
    ByteStream.writeString(emitter.stream, str);
}

function currentOffset(emitter: Emitter): number {
    return ByteStream.length(emitter.stream);
}

function patchU32(emitter: Emitter, offset: number, value: number): void {
    ByteStream.patchU32(emitter.stream, offset, value);
}

// ============================================================================
// Loop Stack Management (for break/continue)
// ============================================================================

function pushLoop(emitter: Emitter): void {
    emitter.loopStack.push({
        breakPatches: [],
        continueTarget: -1
    });
}

function popLoop(emitter: Emitter): LoopInfo | undefined {
    return emitter.loopStack.pop();
}

function currentLoop(emitter: Emitter): LoopInfo | null {
    if (emitter.loopStack.length == 0) {
        return null;
    }
    return emitter.loopStack[emitter.loopStack.length - 1];
}

// ============================================================================
// Scope Management for Local Variables
// ============================================================================

function createScope(parent: Scope | null): Scope {
    return {
        parent: parent,
        locals: [],
        nextSlot: 0
    };
}

function scopeDefine(scope: Scope, name: string): number {
    let slot: number = scope.nextSlot;
    scope.locals.push({ name: name, slot: slot });
    scope.nextSlot = scope.nextSlot + 1;
    return slot;
}

function scopeResolve(scope: Scope, name: string): number {
    let i: number = 0;
    while (i < scope.locals.length) {
        let entry = scope.locals[i];
        if (entry.name == name) {
            return entry.slot;
        }
        i = i + 1;
    }
    return -1;
}

// ============================================================================
// Local Variable Emission Helpers
// ============================================================================

function emitStoreLocal(emitter: Emitter, slot: number): void {
    emitU8(emitter, OP.STORE_LOCAL);
    emitU32(emitter, slot);
}

function emitLoadLocal(emitter: Emitter, slot: number): void {
    emitU8(emitter, OP.LOAD_LOCAL);
    emitU32(emitter, slot);
}

// ============================================================================
// Operator Code Mapping
// ============================================================================

function getOpCodeForBinaryOp(operator: string): number {
    if (operator == "+") { return 2; }
    if (operator == "-") { return 3; }
    if (operator == "*") { return 4; }
    if (operator == "/") { return 5; }
    if (operator == "%") { return 36; }
    if (operator == "**") { return 37; }
    if (operator == "===") { return 38; }
    if (operator == "==") { return 39; }
    if (operator == "!==") { return 40; }
    if (operator == "!=") { return 41; }
    if (operator == "<") { return 22; }
    if (operator == "<=") { return 23; }
    if (operator == ">") { return 24; }
    if (operator == ">=") { return 25; }
    if (operator == "<<") { return 46; }
    if (operator == ">>") { return 47; }
    if (operator == ">>>") { return 48; }
    if (operator == "&") { return 49; }
    if (operator == "^") { return 50; }
    if (operator == "|") { return 51; }
    if (operator == "&&") { return 27; }
    if (operator == "||") { return 28; }
    return -1;
}

function getOpCodeForUnaryOp(operator: string): number {
    if (operator == "-") { return 30; }
    if (operator == "!") { return 29; }
    if (operator == "~") { return 66; }
    if (operator == "+") { return 67; }
    return -1;
}

// ============================================================================
// Main Emit Function (AST Visitor)
// ============================================================================

function emit(emitter: Emitter, node: Node | null): void {
    if (node == null) {
        return;
    }

    let typeVal: string = node.type;

    if (typeVal == "Program") {
        emitProgram(emitter, node);
        return;
    }
    if (typeVal == "VariableDeclaration") {
        emitVariableDeclaration(emitter, node);
        return;
    }
    if (typeVal == "FunctionDeclaration") {
        emitFunctionDeclaration(emitter, node);
        return;
    }
    if (typeVal == "ReturnStatement") {
        emitReturnStatement(emitter, node);
        return;
    }
    if (typeVal == "IfStatement") {
        emitIfStatement(emitter, node);
        return;
    }
    if (typeVal == "WhileStatement") {
        emitWhileStatement(emitter, node);
        return;
    }
    if (typeVal == "BlockStatement") {
        emitBlockStatement(emitter, node);
        return;
    }
    if (typeVal == "ExpressionStatement") {
        emitExpressionStatement(emitter, node);
        return;
    }
    if (typeVal == "BinaryExpression") {
        emitBinaryExpression(emitter, node);
        return;
    }
    if (typeVal == "UnaryExpression") {
        emitUnaryExpression(emitter, node);
        return;
    }
    if (typeVal == "UpdateExpression") {
        emitUpdateExpression(emitter, node);
        return;
    }
    if (typeVal == "AssignmentExpression") {
        emitAssignmentExpression(emitter, node);
        return;
    }
    if (typeVal == "CallExpression") {
        emitCallExpression(emitter, node);
        return;
    }
    if (typeVal == "MemberExpression") {
        emitMemberExpression(emitter, node);
        return;
    }
    if (typeVal == "Identifier") {
        emitIdentifier(emitter, node);
        return;
    }
    if (typeVal == "Literal") {
        emitLiteral(emitter, node);
        return;
    }
    if (typeVal == "ArrayExpression") {
        emitArrayExpression(emitter, node);
        return;
    }
    if (typeVal == "ObjectExpression") {
        emitObjectExpression(emitter, node);
        return;
    }
    if (typeVal == "NewExpression") {
        emitNewExpression(emitter, node);
        return;
    }
    if (typeVal == "ThisExpression") {
        emitThisExpression(emitter, node);
        return;
    }
    if (typeVal == "ArrowFunctionExpression" || typeVal == "FunctionExpression") {
        emitFunctionExpression(emitter, node);
        return;
    }
    if (typeVal == "BreakStatement") {
        emitBreakStatement(emitter, node);
        return;
    }
    if (typeVal == "ContinueStatement") {
        emitContinueStatement(emitter, node);
        return;
    }
    if (typeVal == "EmptyStatement") {
        return;
    }
    if (typeVal == "ForStatement") {
        emitForStatement(emitter, node);
        return;
    }
    if (typeVal == "ImportDeclaration") {
        console.log("Info: Import declaration ignored during bytecode emission. Module: " + node.source);
        return;
    }
    if (typeVal == "ExportNamedDeclaration") {
        console.log("Info: Export named declaration ignored during bytecode emission.");
        if (node.declaration != null) {
            emit(emitter, node.declaration);
        }
        return;
    }
    if (typeVal == "ExportDefaultDeclaration") {
        console.log("Info: Export default declaration ignored during bytecode emission.");
        return;
    }
    if (typeVal == "ExportAllDeclaration") {
        console.log("Info: Export all declaration ignored during bytecode emission. Source: " + node.source);
        return;
    }
    console.log("Unknown node type:", typeVal);
}

// ============================================================================
// Statement Emitters
// ============================================================================

function emitProgram(emitter: Emitter, node: Program): void {
    let i: number = 0;
    while (i < node.body.length) {
        emit(emitter, node.body[i]);
        i = i + 1;
    }
    emitU8(emitter, OP.HALT);
}

function emitBlockStatement(emitter: Emitter, node: BlockStatement): void {
    let i: number = 0;
    while (i < node.body.length) {
        emit(emitter, node.body[i]);
        i = i + 1;
    }
}

function emitExpressionStatement(emitter: Emitter, node: ExpressionStatement): void {
    emit(emitter, node.expression);
    emitU8(emitter, OP.POP);
}

function emitVariableDeclaration(emitter: Emitter, node: VariableDeclaration): void {
    if (node.init != null) {
        emit(emitter, node.init);
    } else {
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.UNDEFINED);
    }
    if (emitter.scope != null) {
        let slot: number = scopeDefine(emitter.scope, node.name);
        emitStoreLocal(emitter, slot);
    } else {
        emitU8(emitter, OP.STORE);
        emitString(emitter, node.name);
    }
}

function emitFunctionDeclaration(emitter: Emitter, node: FunctionDeclaration): void {
    if (node.isAsync === true) {
        console.log("Info: Async function '" + node.name + "' - async semantics not yet implemented, treating as synchronous");
    }

    emitU8(emitter, OP.JUMP);
    let jumpPatch: number = currentOffset(emitter);
    emitU32(emitter, 0);

    let funcAddr: number = currentOffset(emitter);

    let outerScope: Scope | null = emitter.scope;
    emitter.scope = createScope(null);

    let paramCount: number = node.params.length;
    let i: number = 0;
    while (i < paramCount) {
        let param = node.params[i];
        let paramName: string = param;
        if (typeof param === "object" && param.name != null) {
            paramName = param.name;
        }
        scopeDefine(emitter.scope, paramName);
        i = i + 1;
    }

    i = paramCount - 1;
    while (i >= 0) {
        emitStoreLocal(emitter, i);
        i = i - 1;
    }

    emit(emitter, node.body);

    emitter.scope = outerScope;

    emitU8(emitter, OP.PUSH);
    emitU8(emitter, TYPE.UNDEFINED);
    emitU8(emitter, OP.RETURN);

    patchU32(emitter, jumpPatch, currentOffset(emitter));

    emitU8(emitter, OP.NEW_OBJECT);

    emitU8(emitter, OP.MAKE_CLOSURE);
    emitU32(emitter, funcAddr);
    emitU8(emitter, paramCount);

    i = 0;
    while (i < paramCount) {
        let param = node.params[i];
        let paramName: string = param;
        if (typeof param === "object" && param.name != null) {
            paramName = param.name;
        }
        emitString(emitter, paramName);
        i = i + 1;
    }

    emitU8(emitter, OP.STORE);
    emitString(emitter, node.name);
}

function emitReturnStatement(emitter: Emitter, node: ReturnStatement): void {
    if (node.argument != null) {
        emit(emitter, node.argument);
    } else {
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.UNDEFINED);
    }
    emitU8(emitter, OP.RETURN);
}

function emitIfStatement(emitter: Emitter, node: IfStatement): void {
    emit(emitter, node.test);

    emitU8(emitter, OP.JUMP_IF_FALSE);
    let falsePatch: number = currentOffset(emitter);
    emitU32(emitter, 0);

    emit(emitter, node.consequent);

    if (node.alternate != null) {
        emitU8(emitter, OP.JUMP);
        let endPatch: number = currentOffset(emitter);
        emitU32(emitter, 0);

        patchU32(emitter, falsePatch, currentOffset(emitter));

        emit(emitter, node.alternate);

        patchU32(emitter, endPatch, currentOffset(emitter));
    } else {
        patchU32(emitter, falsePatch, currentOffset(emitter));
    }
}

function emitWhileStatement(emitter: Emitter, node: WhileStatement): void {
    pushLoop(emitter);

    let loopStart: number = currentOffset(emitter);
    let loopInfo: LoopInfo | null = currentLoop(emitter);
    if (loopInfo != null) {
        loopInfo.continueTarget = loopStart;
    }

    emit(emitter, node.test);

    emitU8(emitter, OP.JUMP_IF_FALSE);
    let endPatch: number = currentOffset(emitter);
    emitU32(emitter, 0);

    emit(emitter, node.body);

    emitU8(emitter, OP.JUMP);
    emitU32(emitter, loopStart);

    patchU32(emitter, endPatch, currentOffset(emitter));

    let loopData: LoopInfo | undefined = popLoop(emitter);
    if (loopData != null) {
        let j: number = 0;
        while (j < loopData.breakPatches.length) {
            patchU32(emitter, loopData.breakPatches[j], currentOffset(emitter));
            j = j + 1;
        }
    }
}

function emitForStatement(emitter: Emitter, node: ForStatement): void {
    let forNode: ForStatement = node;

    if (forNode.init != null) {
        emit(emitter, forNode.init);
    }

    let loopStart: number = currentOffset(emitter);

    if (forNode.test != null) {
        emit(emitter, forNode.test);
        emitU8(emitter, OP.JUMP_IF_FALSE);
        let endPatch: number = currentOffset(emitter);
        emitU32(emitter, 0);

        emit(emitter, forNode.body);

        if (forNode.update != null) {
            emit(emitter, forNode.update);
            emitU8(emitter, OP.POP);
        }

        emitU8(emitter, OP.JUMP);
        emitU32(emitter, loopStart);

        patchU32(emitter, endPatch, currentOffset(emitter));
    }
}

function emitBreakStatement(emitter: Emitter, node: BreakStatement): void {
    let loopInfo: LoopInfo | null = currentLoop(emitter);
    if (loopInfo == null) {
        console.log("Error: break outside of loop");
        return;
    }
    emitU8(emitter, OP.JUMP);
    loopInfo.breakPatches.push(currentOffset(emitter));
    emitU32(emitter, 0);
}

function emitContinueStatement(emitter: Emitter, node: ContinueStatement): void {
    let loopInfo: LoopInfo | null = currentLoop(emitter);
    if (loopInfo == null) {
        console.log("Error: continue outside of loop");
        return;
    }
    emitU8(emitter, OP.JUMP);
    emitU32(emitter, loopInfo.continueTarget);
}

// ============================================================================
// Expression Emitters
// ============================================================================

function emitBinaryExpression(emitter: Emitter, node: BinaryExpression): void {
    let operator: string = node.operator;

    emit(emitter, node.left);
    emit(emitter, node.right);

    let opcode: number = getOpCodeForBinaryOp(operator);
    if (opcode == -1) {
        console.log("Unknown binary operator:", operator);
        return;
    }
    emitU8(emitter, opcode);
    return;
}

function emitUnaryExpression(emitter: Emitter, node: UnaryExpression): void {
    let operator: string = node.operator;

    emit(emitter, node.argument);

    let opcode: number = getOpCodeForUnaryOp(operator);
    if (opcode == -1) {
        console.log("Unknown unary operator:", operator);
        return;
    }
    emitU8(emitter, opcode);
    return;
}

function emitUpdateExpression(emitter: Emitter, node: UpdateExpression): void {
    // ++x or x++, and obj.prop++ / ++obj.prop
    let addOpcode: number = 2;  // binary ADD
    let subOpcode: number = 3;  // binary SUB

    if (node.argument.type == "Identifier") {
        let isLocal: boolean = false;
        let slot: number = -1;
        if (emitter.scope != null) {
            slot = scopeResolve(emitter.scope, node.argument.name);
            if (slot != -1) {
                isLocal = true;
            }
        }

        if (isLocal) {
            emitLoadLocal(emitter, slot);
        } else {
            emitU8(emitter, OP.LOAD);
            emitString(emitter, node.argument.name);
        }

        if (!node.prefix) {
            emitU8(emitter, OP.DUP);
        }

        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, 1);

        if (node.operator == "++") {
            emitU8(emitter, addOpcode);
        } else {
            emitU8(emitter, subOpcode);
        }

        if (node.prefix) {
            emitU8(emitter, OP.DUP);
        }

        if (isLocal) {
            emitStoreLocal(emitter, slot);
        } else {
            emitU8(emitter, OP.STORE);
            emitString(emitter, node.argument.name);
        }
    } else if (node.argument.type == "MemberExpression") {
        let memberNode: MemberExpression = node.argument;

        if (node.prefix) {
            // ++obj.prop
            emit(emitter, memberNode.object);
            emitU8(emitter, OP.DUP);
            if (memberNode.computed) {
                emit(emitter, memberNode.property);
                emitU8(emitter, OP.LOAD_ELEMENT);
            } else {
                emitU8(emitter, OP.GET_PROP);
                let propName: string = "";
                if (memberNode.property.type == "Identifier") {
                    propName = memberNode.property.name;
                }
                emitString(emitter, propName);
            }
            emitU8(emitter, OP.PUSH);
            emitU8(emitter, TYPE.NUMBER);
            emitF64(emitter, 1);
            if (node.operator == "++") {
                emitU8(emitter, addOpcode);
            } else {
                emitU8(emitter, subOpcode);
            }
            // Stack: [obj, new_val] -> SET_PROP -> []
            if (memberNode.computed) {
                emit(emitter, memberNode.property);
                emitU8(emitter, OP.STORE_ELEMENT);
            } else {
                emitU8(emitter, OP.SET_PROP);
                let propName2: string = "";
                if (memberNode.property.type == "Identifier") {
                    propName2 = memberNode.property.name;
                }
                emitString(emitter, propName2);
            }
            // Reload the new value
            emit(emitter, memberNode.object);
            if (memberNode.computed) {
                emit(emitter, memberNode.property);
                emitU8(emitter, OP.LOAD_ELEMENT);
            } else {
                emitU8(emitter, OP.GET_PROP);
                let propName3: string = "";
                if (memberNode.property.type == "Identifier") {
                    propName3 = memberNode.property.name;
                }
                emitString(emitter, propName3);
            }
        } else {
            // obj.prop++
            emit(emitter, memberNode.object);
            if (memberNode.computed) {
                emit(emitter, memberNode.property);
                emitU8(emitter, OP.LOAD_ELEMENT);
            } else {
                emitU8(emitter, OP.GET_PROP);
                let propName4: string = "";
                if (memberNode.property.type == "Identifier") {
                    propName4 = memberNode.property.name;
                }
                emitString(emitter, propName4);
            }
            // Stack: [old_val] - this is the return value
            // Now store new value back
            emit(emitter, memberNode.object);
            emitU8(emitter, OP.DUP);
            if (memberNode.computed) {
                emit(emitter, memberNode.property);
                emitU8(emitter, OP.LOAD_ELEMENT);
            } else {
                emitU8(emitter, OP.GET_PROP);
                let propName5: string = "";
                if (memberNode.property.type == "Identifier") {
                    propName5 = memberNode.property.name;
                }
                emitString(emitter, propName5);
            }
            emitU8(emitter, OP.PUSH);
            emitU8(emitter, TYPE.NUMBER);
            emitF64(emitter, 1);
            if (node.operator == "++") {
                emitU8(emitter, addOpcode);
            } else {
                emitU8(emitter, subOpcode);
            }
            // Stack: [old_val, obj, new_val] -> SET_PROP -> [old_val]
            if (memberNode.computed) {
                emit(emitter, memberNode.property);
                emitU8(emitter, OP.STORE_ELEMENT);
            } else {
                emitU8(emitter, OP.SET_PROP);
                let propName6: string = "";
                if (memberNode.property.type == "Identifier") {
                    propName6 = memberNode.property.name;
                }
                emitString(emitter, propName6);
            }
        }
    }
    return;
}

function emitAssignmentExpression(emitter: Emitter, node: AssignmentExpression): void {
    let leftNode: Expression = node.left;
    let rightNode: Expression = node.right;

    if (leftNode.type == "Identifier") {
        emit(emitter, rightNode);
        emitU8(emitter, OP.DUP);

        let isLocal: boolean = false;
        let slot: number = -1;
        if (emitter.scope != null) {
            slot = scopeResolve(emitter.scope, leftNode.name);
            if (slot != -1) {
                isLocal = true;
            }
        }

        if (isLocal) {
            emitStoreLocal(emitter, slot);
        } else {
            emitU8(emitter, OP.STORE);
            emitString(emitter, leftNode.name);
        }
    } else if (leftNode.type == "MemberExpression") {
        let memberNode: MemberExpression = leftNode;
        emit(emitter, memberNode.object);
        emit(emitter, rightNode);
        emitU8(emitter, OP.DUP);

        if (memberNode.computed) {
            emit(emitter, memberNode.property);
            emitU8(emitter, OP.STORE_ELEMENT);
        } else {
            emitU8(emitter, OP.SET_PROP);
            let propName: string = "";
            if (memberNode.property.type == "Identifier") {
                propName = memberNode.property.name;
            }
            emitString(emitter, propName);
        }
    } else {
        console.log("Invalid assignment target:", leftNode.type);
    }
    return;
}

function emitCallExpression(emitter: Emitter, node: CallExpression): void {
    let callee: Expression = node.callee;
    let arguments: Array<Expression> = node.arguments;

    if (callee.type == "MemberExpression") {
        let calleeMember: MemberExpression = callee;
        let i: number = 0;
        while (i < arguments.length) {
            emit(emitter, arguments[i]);
            i = i + 1;
        }
        emit(emitter, calleeMember.object);
        emitU8(emitter, OP.CALL_METHOD);
        if (!calleeMember.computed) {
            let methodName: string = "";
            if (calleeMember.property.type == "Identifier") {
                methodName = calleeMember.property.name;
            }
            emitString(emitter, methodName);
        }
        emitU8(emitter, arguments.length);
    } else {
        let i: number = 0;
        while (i < arguments.length) {
            emit(emitter, arguments[i]);
            i = i + 1;
        }
        emit(emitter, callee);
        emitU8(emitter, OP.CALL);
        emitU8(emitter, arguments.length);
    }
    return;
}

function emitMemberExpression(emitter: Emitter, node: MemberExpression): void {
    emit(emitter, node.object);

    if (node.computed) {
        emit(emitter, node.property);
        emitU8(emitter, OP.LOAD_ELEMENT);
    } else {
        emitU8(emitter, OP.GET_PROP);
        let propName: string = "";
        if (node.property.type == "Identifier") {
            propName = node.property.name;
        }
        emitString(emitter, propName);
    }
    return;
}

function emitIdentifier(emitter: Emitter, node: Identifier): void {
    let isLocal: boolean = false;
    let slot: number = -1;

    if (emitter.scope != null) {
        slot = scopeResolve(emitter.scope, node.name);
        if (slot != -1) {
            isLocal = true;
        }
    }

    if (isLocal) {
        emitLoadLocal(emitter, slot);
    } else {
        emitU8(emitter, OP.LOAD);
        emitString(emitter, node.name);
    }
    return;
}

function emitLiteral(emitter: Emitter, node: Literal): void {
    let literalType: string = node.literalType;
    let value: any = node.value;

    emitU8(emitter, OP.PUSH);

    if (literalType == "null") {
        emitU8(emitter, TYPE.NULL);
    } else if (literalType == "boolean") {
        if (value == true) {
            emitU8(emitter, TYPE.TRUE);
        } else {
            emitU8(emitter, TYPE.FALSE);
        }
    } else if (literalType == "number") {
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, value);
    } else if (literalType == "string") {
        emitU8(emitter, TYPE.STRING);
        emitString(emitter, value);
    } else {
        console.log("Warning: unknown literal type:", literalType);
        emitU8(emitter, TYPE.STRING);
        emitString(emitter, value);
    }
    return;
}

function emitArrayExpression(emitter: Emitter, node: ArrayExpression): void {
    emitU8(emitter, OP.NEW_ARRAY);

    let i: number = 0;
    while (i < node.elements.length) {
        emitU8(emitter, OP.DUP);
        emitU8(emitter, OP.PUSH);
        emitU8(emitter, TYPE.NUMBER);
        emitF64(emitter, i);
        let element: Expression | null = node.elements[i];
        if (element != null) {
            emit(emitter, element);
        }
        emitU8(emitter, OP.STORE_ELEMENT);
        i = i + 1;
    }
    return;
}

function emitObjectExpression(emitter: Emitter, node: ObjectExpression): void {
    emitU8(emitter, OP.NEW_OBJECT);

    let i: number = 0;
    while (i < node.properties.length) {
        let prop: ObjectProperty = node.properties[i];
        emitU8(emitter, OP.DUP);
        emit(emitter, prop.value);
        emitU8(emitter, OP.SET_PROP);
        let keyName: string = "";
        if (prop.key.type == "Identifier") {
            keyName = prop.key.name;
        } else if (prop.key.type == "Literal") {
            keyName = prop.key.value;
        }
        emitString(emitter, keyName);
        i = i + 1;
    }
    return;
}

function emitNewExpression(emitter: Emitter, node: NewExpression): void {
    let i: number = 0;
    while (i < node.arguments.length) {
        emit(emitter, node.arguments[i]);
        i = i + 1;
    }
    emit(emitter, node.callee);
    emitU8(emitter, OP.CONSTRUCT);
    emitU8(emitter, node.arguments.length);
    return;
}

function emitThisExpression(emitter: Emitter, node: ThisExpression): void {
    emitU8(emitter, OP.LOAD_THIS);
    return;
}

function emitFunctionExpression(emitter: Emitter, node: FunctionExpression): void {
    if (node.isAsync === true) {
        console.log("Info: Async function expression - async semantics not yet implemented, treating as synchronous");
    }

    let funcNode: FunctionExpression = node;

    emitU8(emitter, OP.JUMP);
    let jumpPatch: number = currentOffset(emitter);
    emitU32(emitter, 0);

    let funcAddr: number = currentOffset(emitter);

    let outerScope: Scope | null = emitter.scope;
    emitter.scope = createScope(null);

    let paramCount: number = funcNode.params.length;
    let i: number = 0;
    while (i < paramCount) {
        let param = funcNode.params[i];
        let paramName: string = param;
        if (typeof param === "object" && param.name != null) {
            paramName = param.name;
        }
        scopeDefine(emitter.scope, paramName);
        i = i + 1;
    }

    i = paramCount - 1;
    while (i >= 0) {
        emitStoreLocal(emitter, i);
        i = i - 1;
    }

    if (funcNode.body.type == "BlockStatement") {
        emit(emitter, funcNode.body);
    } else {
        emit(emitter, funcNode.body);
        emitU8(emitter, OP.RETURN);
    }

    emitter.scope = outerScope;

    emitU8(emitter, OP.PUSH);
    emitU8(emitter, TYPE.UNDEFINED);
    emitU8(emitter, OP.RETURN);

    patchU32(emitter, jumpPatch, currentOffset(emitter));

    emitU8(emitter, OP.NEW_OBJECT);

    emitU8(emitter, OP.MAKE_CLOSURE);
    emitU32(emitter, funcAddr);
    emitU8(emitter, paramCount);

    i = 0;
    while (i < paramCount) {
        let param = funcNode.params[i];
        let paramName: string = param;
        if (typeof param === "object" && param.name != null) {
            paramName = param.name;
        }
        emitString(emitter, paramName);
        i = i + 1;
    }
    return;
}

// ============================================================================
// Main Entry Point
// ============================================================================

function compile(source: string): ByteStream {
    let ast: Program = parseSource(source);
    if (ast == null) {
        console.log("Parse error");
        return null;
    }

    let emitter: Emitter = createEmitter();

    emitU8(emitter, 84);
    emitU8(emitter, 83);
    emitU8(emitter, 67);
    emitU8(emitter, 76);
    emitU8(emitter, 1);
    emitU8(emitter, 0);
    emitU8(emitter, 0);
    emitU8(emitter, 0);

    emit(emitter, ast);

    console.log("Compilation complete");
    return emitter.stream;
}

function compileToFile(source: string, outputPath: string): boolean {
    let bytecode: ByteStream = compile(source);
    if (bytecode == null) {
        return false;
    }
    let bytes: Array<number> = ByteStream.toArray(bytecode);
    fs.writeBinaryFile(outputPath, bytes);
    return true;
}
